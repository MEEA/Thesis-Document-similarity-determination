\section{NoSQL Support Implementation}
\label{sec:implementationnosql}

The prototype requirements described in Chapter \ref{chap:spec} specify the need of support to \ac{NoSQL} Cloud data stores. In Chapter \ref{chap:design} we present a design for accessing backend \ac{NoSQL} Cloud data stores via a standardized protocol which is supported in most of the data stores interfaces: \ac{JSON} over \ac{HTTP}. Gomez \cite{gomez2012} and Muhler \cite{Muhler2012} extend the ServiceMix-http \ac{JBI} \ac{BC} in order to provide multi-tenancy awareness at the communication level. We reuse and extend the \ac{BC} to support the communication protocol required in this diploma thesis.

\subsection{Multi-tenant ServiceMix HTTP Binding Component}

As discussed in previous chapters, the ServiceMix-mt \ac{JBI} \ac{BC} implements multi-tenancy awareness for the \ac{HTTP} communication protocol. However, the multi-tenancy awareness supported ensures endpoint isolation at the tenant level, but not at the user level. Ensuring tenant isolation in a system which connects to multiple tenant's databases, and is accessed by multiple tenant's users, is not enough. Therefore, we modify the operations implemented in Muhler's approach \cite{Muhler2012}, in order to ensure tenant and user isolation. 

The \ac{HTTP} endpoint configuration is described in the \term{xbean.xml} file of the \ac{SU}, and its \ac{XML} format complies the Spring specification. The \term{XBeanDeployerMT} class extends the original \term{BaseXBeanDeployer} class in ServiceMix, which performs the loading of the endpoint properties, and the creation and configuration of the deployed endpoint. The \term{XBeanDeployerMT} created in Muhler's work provides the operations which inject tenant information in the endpoint's \ac{URI} during the deployment process \cite{Muhler2012}. We modify such operations in order to inject tenant and user information in the endpoint's \ac{URI} during the endpoint creation. The \ac{HTTP} consumer and provider endpoints are described in the \term{HttpConsumerEndpoint} and \term{HttpProviderEndpoint} respectively. The former implements the necessary operations for accepting incoming \ac{HTTP} requests to ServiceMix-mt, while the latter implements the operations to communicate with an external \ac{HTTP} server. Both endpoints are created on a Jetty server, which provides an interface for sending \ac{HTTP} requests, and listening on a specific port for incoming \ac{HTTP} requests. Therefore, the endpoints process incoming, and outgoing requests. Request messages are marshaled and demarshaled into or from the \ac{NMF}, a message exchange is created, and the response message is correlated with the initial request.
%we use the same version as amazon aws sdk of jackson, the 1.8.9

As described in Chapter \ref{chap:relatedworks}, the different \ac{NoSQL} Cloud data store provider products available nowadays belong to a specific \ac{NoSQL} family, but the naming the Cloud providers use to identify the storage structures is different. We address this issue in Chapter \ref{chap:design}, but we find further issues in its communication protocol. Although most of the \ac{NoSQL} Cloud data store providers, e.g. Amazon \cite{amazondynamodb}, Google Cloud Storage \cite{googlecloudstorage}, provide a REST interface for accessing their stores, the \ac{HTTP} content and header values are not standardized between the providers. For this reason, they provide their users their Java SDKs for accessing the Cloud services. Operations on the driver's \ac{API} create the \ac{JSON} over \ac{HTTP} requests. Furthermore, MongoDB \cite{mongodb} does not provide a REST interface, but there are several external projects which create an Jetty \ac{HTTP} server, and transform the HTTP requests into parameters of the Mongo Java SDK. For these reason we are not able to provide a standardized marshaling interface in the \ac{HTTP} \ac{JBI} \ac{BC} for all the Cloud data store providers, but we concentrate on the three which we mention before.

\lstinputlisting[label={lst:jsonamazondynamodb},caption={[Amazon Dynamo DB JSON over HTTP Sample Request]Amazon Dynamo DB JSON over HTTP sample request \cite{amazondynamodb}.},style=xml]{./gfx/amazondynamodbexample.txt}

Marshaling operations in the \ac{HTTP} \ac{JBI} \ac{BC} are provided in the classes \term{DefaultHttpConsumerMarshaler}, and \term{DefaultHttpProviderMarshaler}. Hence, we start the extension of the marshalers at this point. On the other hand, the marshalers do not support marshaling of \ac{JSON} content, as the \ac{NMF} stores \ac{XML} format. Therefore, we include \ac{JSON} marshaling operations which are provided by the Jackson v1.8.9 \cite{jackson}. We select this version, as is the one provided in Amazon's AWS SDK \cite{amazonawssdk}. We provide a marshaler handler interface, which is implemented for the different Cloud data store providers. The handler is chosen based on the \ac{HTTP} headers or target \ac{HTTP} URL content (see Listings \ref{lst:jsonamazondynamodb} and \ref{lst:googlecloudstorage}). As in the MySQL approach, marshaling operations include filling the \ac{NMF} properties with the tenant's source and backend data source configuration data retrieved from the service registry, and storage of the \ac{HTTP} request content as an attachment. Properties and attachments identifiers are listed in the \term{NMConstants} class.

\lstinputlisting[label={lst:googlecloudstorage},caption={[Google Coud Storage JSON over HTTP Sample Request]Google Coud Storage JSON over HTTP sample request \cite{googlecloudstorage}.},style=xml]{./gfx/googlecloudstorageexample.txt}

The same method described above applies in the \ac{HTTP} provider endpoints. Demarshaling operations in the multi-tenant aware provider endpoint create the \ac{HTTP} requests for each Cloud provider (see Listings \ref{lst:jsonamazondynamodb} and \ref{lst:googlecloudstorage})  in a separate handler, based on the target data store properties which are stored in the \ac{NMF}.  

Authentication mechanisms in the \ac{HTTP} consumer endpoint processor rely on the tenant and user UUIDs, and follow Gomez's approach \cite{gomez2012}. However, we do not retrieve the UUIDs from the \ac{SOAP} header, but from the \ac{HTTP} header where the authentication data is stored. Both authentication and data retrieval are susceptible of being cashed in the system. The cashing mechanisms we use for this \ac{BC} is the same as in the CDASMix MySQL Proxy component. The difference relies on a separate cache instance for \ac{NoSQL} requests, and the need of including the \ac{JBI} ServiceMix Registry library in the \ac{SA} of this \ac{BC}, due to the problems found when loading external \ac{OSGi} bundles from components packed as \ac{SA}s.