{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=11635",
  "eid" : "fcd50cb0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778503931,
  "textBody" : "Flood fill, also called seed fill, is an algorithm that determines the area connected to a given node in a multi-dimensional array. It is used in the \"bucket\" fill tool of paint programs to fill connected, similarly-colored areas with a different color, and in games such as Go and Minesweeper for determining which pieces are cleared.\n\nThe algorithm\n\nThe flood-fill algorithm takes three parameters: a start node, a target color, and a replacement color. The algorithm looks for all nodes in the array that are connected to the start node by a path of the target color and changes them to the replacement color. There are many ways in which the flood-fill algorithm can be structured, but they all make use of a queue or stack data structure, explicitly or implicitly.\n\nDepending on whether we consider nodes touching at the corners connected or not, we have two variations: eight-way and four-way respectively.\n\nStack-based recursive implementation (four-way) \n\nOne implicitly stack-based (recursive) flood-fill implementation (for a two-dimensional array) goes as follows:\n\n Flood-fill (node, target-color, replacement-color):\n  1. If target-color is equal to replacement-color, return.\n  2. If the color of node is not equal to target-color, return.\n  3. Set the color of node to replacement-color.\n  4. Perform Flood-fill (one step to the south of node, target-color, replacement-color).\n     Perform Flood-fill (one step to the north of node, target-color, replacement-color).\n     Perform Flood-fill (one step to the west of node, target-color, replacement-color).\n     Perform Flood-fill (one step to the east of node, target-color, replacement-color).\n  5. Return.\n\nThough easy to understand, the implementation of the algorithm used above is impractical in languages and environments where stack space is severely constrained (e.g. Java applets).\n\nAlternative implementations\n\nAn explicitly queue-based implementation (sometimes called \"Forest Fire algorithm\") is shown in pseudo-code below. It is similar to the simple recursive solution, except that instead of making recursive calls, it pushes the nodes onto a queue for consumption:\n\n Flood-fill (node, target-color, replacement-color):\n   1. If target-color is equal to replacement-color, return.\n   2. If color of node is not equal to target-color, return.\n   3. Set Q to the empty queue.\n   4.  Set the color of node to replacement-color.\n   5. Add node to the end of Q.\n   6. While Q is not empty:\n   7.     Set n equal to the first element of Q.\n   8.     Remove first element from Q.\n   9.     If the color of the node to the west of n is target-color,\n                     set the color of that node to replacement-color and add that node to the end of Q.\n  10.     If the color of the node to the east of n is target-color,\n                    set the color of that node to replacement-color and add that node to the end of Q.\n  11.    If the color of the node to the north of n is target-color,\n                    set the color of that node to replacement-color and add that node to the end of Q.\n  12.    If the color of the node to the south of n is target-color,\n                    set the color of that node to replacement-color and add that node to the end of Q.\n  13. Continue looping until Q is exhausted.\n  14. Return.\n\nMost practical implementations use a loop for the west and east directions as an optimization to avoid the overhead of stack or queue management:\n\n Flood-fill (node, target-color, replacement-color):\n  1. If target-color is equal to replacement-color, return.\n  2. If color of node is not equal to target-color, return.\n  3. Set Q to the empty queue.\n  4. Add node to Q.\n  5. For each element N of Q:\n  6.         Set w and e equal to N.\n  7.         Move w to the west until the color of the node to the west of w no longer matches target-color.\n  8.         Move e to the east until the color of the node to the east of e no longer matches target-color.\n  9.         For each node n between w and e:\n 10.             Set the color of n to replacement-color.\n 11.             If the color of the node to the north of n is target-color, add that node to Q.\n 12.             If the color of the node to the south of n is target-color, add that node to Q.\n 13. Continue looping until Q is exhausted.\n 14. Return.\n\nAdapting the algorithm to use an additional array to store the shape of the region allows generalization to cover \"fuzzy\" flood filling, where an element can differ by up to a specified threshold from the source symbol. Using this additional array as an alpha channel allows the edges of the filled region to blend somewhat smoothly with the not-filled region.\n\nFixed-memory method (right-hand fill method)\n\nA method exists that uses essentially no memory for four-connected regions by pretending to be a painter trying to paint the region without painting himself into a corner. This is also a method for solving mazes. The four pixels making the primary boundary are examined to see what action should be taken. The painter could find themselves in one of several conditions:\n\n# All four boundary pixels are filled.\n# Three of the boundary pixels are filled.\n# Two of the boundary pixels are filled.\n# One boundary pixel is filled.\n# Zero boundary pixels are filled.\n\nWhere a path or boundary is to be followed, the right-hand rule is used. The painter follows the region by placing their right-hand on the wall (the boundary of the region) and progressing around the edge of the region without removing their hand.\n\nFor case #1, the painter paints (fills) the pixel the painter is standing upon and stops the algorithm.\n\nFor case #2, a path leading out of the area exists. Paint the pixel the painter is standing upon and move in the direction of the open path.\n\nFor case #3, the two boundary pixels define a path which, if we painted the current pixel, may block us from ever getting back to the other side of the path. We need a \"mark\" to define where we are and which direction we are heading to see if we ever get back to exactly the same pixel. If we already created such a \"mark\", then we preserve our previous mark and move to the next pixel following the right-hand rule.\n\nA mark is used for the first 2-pixel boundary that is encountered to remember where the passage started and in what direction the painter was moving. If the mark is encountered again and the painter is traveling in the same direction, then the painter knows that it is safe to paint the square with the mark and to continue in the same direction. This is because (through some unknown path) the pixels on the other side of the mark can be reached and painted in the future. The mark is removed for future use.\n\nIf the painter encounters the mark but is going in a different direction, then some sort of loop has occurred, which caused the painter to return to the mark. This loop must be eliminated. The mark is picked up, and the painter then proceeds in the direction indicated previously by the mark using a left-hand rule for the boundary (similar to the right-hand rule but using the painter's left hand). This continues until an intersection is found (with three or more open boundary pixels). Still using the left-hand rule the painter now searches for a simple passage (made by two boundary pixels). Upon finding this two-pixel boundary path, that pixel is painted. This breaks the loop and allows the algorithm to continue.\n\nFor case #4, we need to check the opposite 8-connected corners to see whether they are filled or not. If either or both are filled, then this creates a many-path intersection and cannot be filled. If both are empty, then the current pixel can be painted and the painter can move following the right-hand rule.\n\nThe algorithm trades time for memory. For simple shapes it is very efficient. However, if the shape is complex with many features, the algorithm spends a large amount of time tracing the edges of the region trying to ensure that all can be painted.\n\nThis algorithm was first available commercially in 1981 on a Vicom Image Processing system manufactured by Vicom Systems, Inc. The classic recursive flood fill algorithm was available on this system as well.\n\nPseudocode \n\nThis is a pseudocode implementation of an optimal fixed-memory flood-fill algorithm written in structured English:\n\nThe variables:\n     cur, mark, and mark2 each hold either pixel coordinates or a null value\n          NOTE: when mark is set to null, do not erase its previous coordinate value.\n                Keep those coordinates available to be recalled if necessary.\n     cur-dir, mark-dir, and mark2-dir each hold a direction (left, right, up, or down)\n     backtrack and findloop each hold boolean values\n     count is an integer\n\nThe algorithm:\n\n(NOTE: All directions (front, back, left, right) are relative to cur-dir)\n\n set cur to starting pixel\n set cur-dir to default direction\n clear mark and mark2 (set values to null)\n set backtrack and findloop to false\n\n while front-pixel is empty\n  move forward\n end while\n\n jump to START\n\n MAIN LOOP:\n  move forward\n  if right-pixel is empty\n   if backtrack is true and findloop is false and either front-pixel or left-pixel is empty\n    set findloop to true\n   end if\n   turn right\n PAINT:\n   move forward\n  end if\n START:\n  set count to number of non-diagonally adjacent pixels filled (front/back/left/right ONLY)\n  if count is not 4\n   do\n    turn right\n   while front-pixel is empty\n   do\n    turn left\n   while front-pixel is filled\n  end if\n  switch count\n   case 1\n    if backtrack is true\n     set findloop to true\n    else if findloop is true\n     if mark is null\n      restore mark\n     end if\n    else if front-left-pixel and back-left-pixel are both empty\n     clear mark\n     fill cur\n     jump to PAINT\n    end if\n   end case\n   case 2\n    if back-pixel is filled\n     if front-left-pixel is not filled\n      clear mark\n      fill cur\n      jump to PAINT\n     end if\n    else if mark is not set\n     set mark to cur\n     set mark-dir to cur-dir\n     clear mark2\n     set findloop and backtrack to false\n    else\n     if mark2 is not set\n      if cur is at mark\n       if cur-dir is the same as mark-dir\n        clear mark\n        turn around\n        fill cur\n        jump to PAINT\n       else\n        set backtrack to true\n        set findloop to false\n        set cur-dir to mark-dir\n       end if\n      else if findloop is true\n       set mark2 to cur\n       set mark2-dir to cur-dir\n      end if\n     else\n      if cur is at mark\n       set cur to mark2\n       set cur-dir to mark2-dir\n       clear mark and mark2\n       set backtrack to false\n       turn around\n       fill cur\n       jump to PAINT\n      else if cur at mark2\n       set mark to cur\n       set cur-dir and mark-dir to mark2-dir\n       clear mark2\n      end\n     end if\n    end if\n   end case\n   case 3\n    clear mark  \n    fill cur\n    jump to PAINT\n   end case\n   case 4\n    fill cur\n    done\n   end case\n  end switch\n end MAIN LOOP\n\nScanline fill\n \n\nThe algorithm can be sped up by filling lines. Instead of pushing each potential future pixel coordinate on the stack, it inspects the neighbour lines (previous and next) to find adjacent segments that may be filled in a future pass; the coordinates (either the start or the end) of the line segment are pushed on the stack. In most cases this scanline algorithm is at least an order of magnitude faster than the per-pixel one.\n\nEfficiency: each pixel is checked once.\n\nVector implementations\n\nVersion 0.46 of Inkscape includes a bucket fill tool, giving output similar to ordinary bitmap operations and indeed using one: the canvas is rendered, a flood fill operation is performed on the selected area and the result is then traced back to a path. It uses the concept of a boundary condition.\n\nLarge-scale behaviour\n\nThe primary technique used to control a flood fill will either be data-centric or process-centric. A data-centric approach can use either a stack or a queue to keep track of seed pixels that need to be checked. A process-centric algorithm must necessarily use a stack.\n\nA 4-way flood-fill algorithm that uses the adjacency technique and a queue as its seed pixel store yields an expanding lozenge-shaped fill.\n\nEfficiency: 4 pixels checked for each pixel filled (8 for an 8-way fill).\n\nA 4-way flood-fill algorithm that use the adjacency technique and a stack as its seed pixel store yields a linear fill with \"gaps filled later\" behaviour. This approach can be particularly seen in older 8-bit computer games, such as those created with Graphic Adventure Creator.\n\nEfficiency: 4 pixels checked for each pixel filled (8 for an 8-way fill).",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Flood fill" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=11635" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Flood fill, also called seed fill, is an algorithm that determines the area connected to a given node in a multi-dimensional array. It is used in the \"bucket\" fill tool of paint programs to fill connected, similarly-colored areas with a different color, and in games such as Go and Minesweeper for determining which pieces are cleared.\n\nThe algorithm\n\nThe flood-fill algorithm takes three parameters: a start node, a target color, and a replacement color. The algorithm looks for all nodes in the array that are connected to the start node by a path of the target color and changes them to the replacement color. There are many ways in which the flood-fill algorithm can be structured, but they all make use of a queue or stack data structure, explicitly or implicitly.\n\nDepending on whether we consider nodes touching at the corners connected or not, we have two variations: eight-way and four-way respectively.\n\nStack-based recursive implementation (four-way) \n\nOne implicitly stack-based (recursive) flood-fill implementation (for a two-dimensional array) goes as follows:\n\n Flood-fill (node, target-color, replacement-color):\n  1. If target-color is equal to replacement-color, return.\n  2. If the color of node is not equal to target-color, return.\n  3. Set the color of node to replacement-color.\n  4. Perform Flood-fill (one step to the south of node, target-color, replacement-color).\n     Perform Flood-fill (one step to the north of node, target-color, replacement-color).\n     Perform Flood-fill (one step to the west of node, target-color, replacement-color).\n     Perform Flood-fill (one step to the east of node, target-color, replacement-color).\n  5. Return.\n\nThough easy to understand, the implementation of the algorithm used above is impractical in languages and environments where stack space is severely constrained (e.g. Java applets).\n\nAlternative implementations\n\nAn explicitly queue-based implementation (sometimes called \"Forest Fire algorithm\") is shown in pseudo-code below. It is similar to the simple recursive solution, except that instead of making recursive calls, it pushes the nodes onto a queue for consumption:\n\n Flood-fill (node, target-color, replacement-color):\n   1. If target-color is equal to replacement-color, return.\n   2. If color of node is not equal to target-color, return.\n   3. Set Q to the empty queue.\n   4.  Set the color of node to replacement-color.\n   5. Add node to the end of Q.\n   6. While Q is not empty:\n   7.     Set n equal to the first element of Q.\n   8.     Remove first element from Q.\n   9.     If the color of the node to the west of n is target-color,\n                     set the color of that node to replacement-color and add that node to the end of Q.\n  10.     If the color of the node to the east of n is target-color,\n                    set the color of that node to replacement-color and add that node to the end of Q.\n  11.    If the color of the node to the north of n is target-color,\n                    set the color of that node to replacement-color and add that node to the end of Q.\n  12.    If the color of the node to the south of n is target-color,\n                    set the color of that node to replacement-color and add that node to the end of Q.\n  13. Continue looping until Q is exhausted.\n  14. Return.\n\nMost practical implementations use a loop for the west and east directions as an optimization to avoid the overhead of stack or queue management:\n\n Flood-fill (node, target-color, replacement-color):\n  1. If target-color is equal to replacement-color, return.\n  2. If color of node is not equal to target-color, return.\n  3. Set Q to the empty queue.\n  4. Add node to Q.\n  5. For each element N of Q:\n  6.         Set w and e equal to N.\n  7.         Move w to the west until the color of the node to the west of w no longer matches target-color.\n  8.         Move e to the east until the color of the node to the east of e no longer matches target-color.\n  9.         For each node n between w and e:\n 10.             Set the color of n to replacement-color.\n 11.             If the color of the node to the north of n is target-color, add that node to Q.\n 12.             If the color of the node to the south of n is target-color, add that node to Q.\n 13. Continue looping until Q is exhausted.\n 14. Return.\n\nAdapting the algorithm to use an additional array to store the shape of the region allows generalization to cover \"fuzzy\" flood filling, where an element can differ by up to a specified threshold from the source symbol. Using this additional array as an alpha channel allows the edges of the filled region to blend somewhat smoothly with the not-filled region.\n\nFixed-memory method (right-hand fill method)\n\nA method exists that uses essentially no memory for four-connected regions by pretending to be a painter trying to paint the region without painting himself into a corner. This is also a method for solving mazes. The four pixels making the primary boundary are examined to see what action should be taken. The painter could find themselves in one of several conditions:\n\n# All four boundary pixels are filled.\n# Three of the boundary pixels are filled.\n# Two of the boundary pixels are filled.\n# One boundary pixel is filled.\n# Zero boundary pixels are filled.\n\nWhere a path or boundary is to be followed, the right-hand rule is used. The painter follows the region by placing their right-hand on the wall (the boundary of the region) and progressing around the edge of the region without removing their hand.\n\nFor case #1, the painter paints (fills) the pixel the painter is standing upon and stops the algorithm.\n\nFor case #2, a path leading out of the area exists. Paint the pixel the painter is standing upon and move in the direction of the open path.\n\nFor case #3, the two boundary pixels define a path which, if we painted the current pixel, may block us from ever getting back to the other side of the path. We need a \"mark\" to define where we are and which direction we are heading to see if we ever get back to exactly the same pixel. If we already created such a \"mark\", then we preserve our previous mark and move to the next pixel following the right-hand rule.\n\nA mark is used for the first 2-pixel boundary that is encountered to remember where the passage started and in what direction the painter was moving. If the mark is encountered again and the painter is traveling in the same direction, then the painter knows that it is safe to paint the square with the mark and to continue in the same direction. This is because (through some unknown path) the pixels on the other side of the mark can be reached and painted in the future. The mark is removed for future use.\n\nIf the painter encounters the mark but is going in a different direction, then some sort of loop has occurred, which caused the painter to return to the mark. This loop must be eliminated. The mark is picked up, and the painter then proceeds in the direction indicated previously by the mark using a left-hand rule for the boundary (similar to the right-hand rule but using the painter's left hand). This continues until an intersection is found (with three or more open boundary pixels). Still using the left-hand rule the painter now searches for a simple passage (made by two boundary pixels). Upon finding this two-pixel boundary path, that pixel is painted. This breaks the loop and allows the algorithm to continue.\n\nFor case #4, we need to check the opposite 8-connected corners to see whether they are filled or not. If either or both are filled, then this creates a many-path intersection and cannot be filled. If both are empty, then the current pixel can be painted and the painter can move following the right-hand rule.\n\nThe algorithm trades time for memory. For simple shapes it is very efficient. However, if the shape is complex with many features, the algorithm spends a large amount of time tracing the edges of the region trying to ensure that all can be painted.\n\nThis algorithm was first available commercially in 1981 on a Vicom Image Processing system manufactured by Vicom Systems, Inc. The classic recursive flood fill algorithm was available on this system as well.\n\nPseudocode \n\nThis is a pseudocode implementation of an optimal fixed-memory flood-fill algorithm written in structured English:\n\nThe variables:\n     cur, mark, and mark2 each hold either pixel coordinates or a null value\n          NOTE: when mark is set to null, do not erase its previous coordinate value.\n                Keep those coordinates available to be recalled if necessary.\n     cur-dir, mark-dir, and mark2-dir each hold a direction (left, right, up, or down)\n     backtrack and findloop each hold boolean values\n     count is an integer\n\nThe algorithm:\n\n(NOTE: All directions (front, back, left, right) are relative to cur-dir)\n\n set cur to starting pixel\n set cur-dir to default direction\n clear mark and mark2 (set values to null)\n set backtrack and findloop to false\n\n while front-pixel is empty\n  move forward\n end while\n\n jump to START\n\n MAIN LOOP:\n  move forward\n  if right-pixel is empty\n   if backtrack is true and findloop is false and either front-pixel or left-pixel is empty\n    set findloop to true\n   end if\n   turn right\n PAINT:\n   move forward\n  end if\n START:\n  set count to number of non-diagonally adjacent pixels filled (front/back/left/right ONLY)\n  if count is not 4\n   do\n    turn right\n   while front-pixel is empty\n   do\n    turn left\n   while front-pixel is filled\n  end if\n  switch count\n   case 1\n    if backtrack is true\n     set findloop to true\n    else if findloop is true\n     if mark is null\n      restore mark\n     end if\n    else if front-left-pixel and back-left-pixel are both empty\n     clear mark\n     fill cur\n     jump to PAINT\n    end if\n   end case\n   case 2\n    if back-pixel is filled\n     if front-left-pixel is not filled\n      clear mark\n      fill cur\n      jump to PAINT\n     end if\n    else if mark is not set\n     set mark to cur\n     set mark-dir to cur-dir\n     clear mark2\n     set findloop and backtrack to false\n    else\n     if mark2 is not set\n      if cur is at mark\n       if cur-dir is the same as mark-dir\n        clear mark\n        turn around\n        fill cur\n        jump to PAINT\n       else\n        set backtrack to true\n        set findloop to false\n        set cur-dir to mark-dir\n       end if\n      else if findloop is true\n       set mark2 to cur\n       set mark2-dir to cur-dir\n      end if\n     else\n      if cur is at mark\n       set cur to mark2\n       set cur-dir to mark2-dir\n       clear mark and mark2\n       set backtrack to false\n       turn around\n       fill cur\n       jump to PAINT\n      else if cur at mark2\n       set mark to cur\n       set cur-dir and mark-dir to mark2-dir\n       clear mark2\n      end\n     end if\n    end if\n   end case\n   case 3\n    clear mark  \n    fill cur\n    jump to PAINT\n   end case\n   case 4\n    fill cur\n    done\n   end case\n  end switch\n end MAIN LOOP\n\nScanline fill\n \n\nThe algorithm can be sped up by filling lines. Instead of pushing each potential future pixel coordinate on the stack, it inspects the neighbour lines (previous and next) to find adjacent segments that may be filled in a future pass; the coordinates (either the start or the end) of the line segment are pushed on the stack. In most cases this scanline algorithm is at least an order of magnitude faster than the per-pixel one.\n\nEfficiency: each pixel is checked once.\n\nVector implementations\n\nVersion 0.46 of Inkscape includes a bucket fill tool, giving output similar to ordinary bitmap operations and indeed using one: the canvas is rendered, a flood fill operation is performed on the selected area and the result is then traced back to a path. It uses the concept of a boundary condition.\n\nLarge-scale behaviour\n\nThe primary technique used to control a flood fill will either be data-centric or process-centric. A data-centric approach can use either a stack or a queue to keep track of seed pixels that need to be checked. A process-centric algorithm must necessarily use a stack.\n\nA 4-way flood-fill algorithm that uses the adjacency technique and a queue as its seed pixel store yields an expanding lozenge-shaped fill.\n\nEfficiency: 4 pixels checked for each pixel filled (8 for an 8-way fill).\n\nA 4-way flood-fill algorithm that use the adjacency technique and a stack as its seed pixel store yields a linear fill with \"gaps filled later\" behaviour. This approach can be particularly seen in older 8-bit computer games, such as those created with Graphic Adventure Creator.\n\nEfficiency: 4 pixels checked for each pixel filled (8 for an 8-way fill). Flood fill. http://en.wikipedia.org/?curid=11635."
  }
}
