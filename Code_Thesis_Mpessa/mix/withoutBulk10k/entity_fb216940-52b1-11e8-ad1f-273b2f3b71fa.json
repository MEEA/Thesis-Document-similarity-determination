{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=11347",
  "eid" : "fb216940-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778501076,
  "textBody" : "FIFO is an acronym for first in, first out, a method for organizing and manipulating a data buffer, where the oldest (first) entry, or 'head' of the queue, is processed first. It is analogous to processing a queue with first-come, first-served (FCFS) behaviour: where the people leave the queue in the order in which they arrive.\n\nFCFS is also the jargon term for the FIFO operating system scheduling algorithm, which gives every process central processing unit (CPU) time in the order in which it is demanded.\n\nFIFO's opposite is LIFO, last-in-first-out, where the youngest entry or 'top of the stack' is processed first.\n\nA priority queue is neither FIFO or LIFO but may adopt similar behaviour temporarily or by default.\n\nQueueing theory encompasses these methods for processing data structures, as well as interactions between strict-FIFO queues.\n\nComputer Science\n\nData structure\n\nDepending on the application, a FIFO could be implemented as a hardware shift register, or using different memory structures, typically a circular buffer or a kind of List. For information on the abstract data structure, see Queue (data structure).\n\nCode \n\nThe following code shows a linked list FIFO C++ language implementation. In practice, a number of list implementations exist, including popular Unix systems C sys/queue.h macros or the C++ standard library std::list template, avoiding the need for implementing the data structure from scratch.\n\n#include \n#include \n \ntemplate \nclass FIFO\n{\nprivate:\n\n    struct Node {\n        T     value;\n        Node *next;\n\n        Node(T _value) : value(_value), next(NULL) {}\n    };\n\n    Node *front;\n    Node *back;\n\npublic:\n    FIFO() : front(NULL), back(NULL) {}\n\n    ~FIFO() {\n        while (front != NULL)\n            dequeue();\n    }\n\n    void enqueue(T _value) {\n        Node *newNode = new Node(_value);\n\n        if (front \n NULL)\n            front = newNode;\n        else\n            back->next = newNode;\n\n        back = newNode;\n    }\n\n    T dequeue() {\n        if (front \n NULL)\n           throw std::underflow_error(\"Nothing to dequeue\");\n\n        Node *temp   = front;        \n        T     result = front->value;\n\n        front = front->next;\n        delete temp;\n\n        return result;\n    }\n};\n\nHead or tail first\n\nThe ends of a FIFO queue are often referred to as head and tail. Unfortunately, a controversy exists regarding those terms:\n* To many people, items should enter a queue at the tail, and remain in the queue until they reach the head and leave the queue from there. This point of view is justified by analogy with queues of people waiting for some kind of service and parallels the use of front and back in the above example.\n* Other people believe that items enter a queue at the head and leave at the tail, in the manner of food passing through a snake. Queues written in that way appear in places that could be considered authoritative, such as the operating system Linux.\n\nPipes\n\nIn computing environments that support the pipes and filters model for interprocess communication, a FIFO is another name for a named pipe.\n\nDisk scheduling\n\nDisk controllers can use the FIFO as a disk scheduling algorithm to determine the order in which to service disk I/O requests.\n\nCommunications and networking\n\nCommunication network bridges, switches and routers used in computer networks use FIFOs to hold data packets en route to their next destination. Typically at least one FIFO structure is used per network connection. Some devices feature multiple FIFOs for simultaneously and independently queuing different types of information.\n\nElectronics\n\nFIFOs are commonly used in electronic circuits for buffering and flow control between hardware and software. In its hardware form, a FIFO primarily consists of a set of read and write pointers, storage and control logic. Storage may be static random access memory (SRAM), flip-flops, latches or any other suitable form of storage. For FIFOs of non-trivial size, a dual-port SRAM is usually used, where one port is dedicated to writing and the other to reading.\n\nA synchronous FIFO is a FIFO where the same clock is used for both reading and writing. An asynchronous FIFO uses different clocks for reading and writing. Asynchronous FIFOs introduce metastability issues.\nA common implementation of an asynchronous FIFO uses a Gray code (or any unit distance code) for the read and write pointers to ensure reliable flag generation. One further note concerning flag generation is that one must necessarily use pointer arithmetic to generate flags for asynchronous FIFO implementations. Conversely, one may use either a leaky bucket approach or pointer arithmetic to generate flags in synchronous FIFO implementations.\n\nExamples of FIFO status flags include: full, empty, almost full, almost empty, etc.\n\nThe first known FIFO implemented in electronics was done by Peter Alfke in 1969 at Fairchild Semiconductors. Peter Alfke was later a Director at Xilinx.\n\nFIFO full-empty \n\nA hardware FIFO is used for synchronization purposes. It is often implemented as a circular queue, and thus has two pointers:\n#Read Pointer/Read Address Register\n#Write Pointer/Write Address Register\n\nRead and write addresses are initially both at the first memory location and the FIFO queue is Empty.\n;FIFO Empty: When the read address register reaches the write address register, the FIFO triggers the Empty signal.\n;FIFO FULL: When the write address register reaches the read address register, the FIFO triggers the FULL signal.\nIn both cases, the read and write addresses end up being equal. To distinguish between the two situations, a simple and robust solution is to add one extra bit for each read and write address which is inverted each time the address wraps. With this set up, the disambiguation conditions are:\n#When the read address register equals the write address register, the FIFO is empty.\n#When the read address LSBs equal the write address LSBs and the extra MSBs are different, the FIFO is full.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "FIFO (computing and electronics)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=11347" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "FIFO is an acronym for first in, first out, a method for organizing and manipulating a data buffer, where the oldest (first) entry, or 'head' of the queue, is processed first. It is analogous to processing a queue with first-come, first-served (FCFS) behaviour: where the people leave the queue in the order in which they arrive.\n\nFCFS is also the jargon term for the FIFO operating system scheduling algorithm, which gives every process central processing unit (CPU) time in the order in which it is demanded.\n\nFIFO's opposite is LIFO, last-in-first-out, where the youngest entry or 'top of the stack' is processed first.\n\nA priority queue is neither FIFO or LIFO but may adopt similar behaviour temporarily or by default.\n\nQueueing theory encompasses these methods for processing data structures, as well as interactions between strict-FIFO queues.\n\nComputer Science\n\nData structure\n\nDepending on the application, a FIFO could be implemented as a hardware shift register, or using different memory structures, typically a circular buffer or a kind of List. For information on the abstract data structure, see Queue (data structure).\n\nCode \n\nThe following code shows a linked list FIFO C++ language implementation. In practice, a number of list implementations exist, including popular Unix systems C sys/queue.h macros or the C++ standard library std::list template, avoiding the need for implementing the data structure from scratch.\n\n#include \n#include \n \ntemplate \nclass FIFO\n{\nprivate:\n\n    struct Node {\n        T     value;\n        Node *next;\n\n        Node(T _value) : value(_value), next(NULL) {}\n    };\n\n    Node *front;\n    Node *back;\n\npublic:\n    FIFO() : front(NULL), back(NULL) {}\n\n    ~FIFO() {\n        while (front != NULL)\n            dequeue();\n    }\n\n    void enqueue(T _value) {\n        Node *newNode = new Node(_value);\n\n        if (front \n NULL)\n            front = newNode;\n        else\n            back->next = newNode;\n\n        back = newNode;\n    }\n\n    T dequeue() {\n        if (front \n NULL)\n           throw std::underflow_error(\"Nothing to dequeue\");\n\n        Node *temp   = front;        \n        T     result = front->value;\n\n        front = front->next;\n        delete temp;\n\n        return result;\n    }\n};\n\nHead or tail first\n\nThe ends of a FIFO queue are often referred to as head and tail. Unfortunately, a controversy exists regarding those terms:\n* To many people, items should enter a queue at the tail, and remain in the queue until they reach the head and leave the queue from there. This point of view is justified by analogy with queues of people waiting for some kind of service and parallels the use of front and back in the above example.\n* Other people believe that items enter a queue at the head and leave at the tail, in the manner of food passing through a snake. Queues written in that way appear in places that could be considered authoritative, such as the operating system Linux.\n\nPipes\n\nIn computing environments that support the pipes and filters model for interprocess communication, a FIFO is another name for a named pipe.\n\nDisk scheduling\n\nDisk controllers can use the FIFO as a disk scheduling algorithm to determine the order in which to service disk I/O requests.\n\nCommunications and networking\n\nCommunication network bridges, switches and routers used in computer networks use FIFOs to hold data packets en route to their next destination. Typically at least one FIFO structure is used per network connection. Some devices feature multiple FIFOs for simultaneously and independently queuing different types of information.\n\nElectronics\n\nFIFOs are commonly used in electronic circuits for buffering and flow control between hardware and software. In its hardware form, a FIFO primarily consists of a set of read and write pointers, storage and control logic. Storage may be static random access memory (SRAM), flip-flops, latches or any other suitable form of storage. For FIFOs of non-trivial size, a dual-port SRAM is usually used, where one port is dedicated to writing and the other to reading.\n\nA synchronous FIFO is a FIFO where the same clock is used for both reading and writing. An asynchronous FIFO uses different clocks for reading and writing. Asynchronous FIFOs introduce metastability issues.\nA common implementation of an asynchronous FIFO uses a Gray code (or any unit distance code) for the read and write pointers to ensure reliable flag generation. One further note concerning flag generation is that one must necessarily use pointer arithmetic to generate flags for asynchronous FIFO implementations. Conversely, one may use either a leaky bucket approach or pointer arithmetic to generate flags in synchronous FIFO implementations.\n\nExamples of FIFO status flags include: full, empty, almost full, almost empty, etc.\n\nThe first known FIFO implemented in electronics was done by Peter Alfke in 1969 at Fairchild Semiconductors. Peter Alfke was later a Director at Xilinx.\n\nFIFO full-empty \n\nA hardware FIFO is used for synchronization purposes. It is often implemented as a circular queue, and thus has two pointers:\n#Read Pointer/Read Address Register\n#Write Pointer/Write Address Register\n\nRead and write addresses are initially both at the first memory location and the FIFO queue is Empty.\n;FIFO Empty: When the read address register reaches the write address register, the FIFO triggers the Empty signal.\n;FIFO FULL: When the write address register reaches the read address register, the FIFO triggers the FULL signal.\nIn both cases, the read and write addresses end up being equal. To distinguish between the two situations, a simple and robust solution is to add one extra bit for each read and write address which is inverted each time the address wraps. With this set up, the disambiguation conditions are:\n#When the read address register equals the write address register, the FIFO is empty.\n#When the read address LSBs equal the write address LSBs and the extra MSBs are different, the FIFO is full. FIFO (computing and electronics). http://en.wikipedia.org/?curid=11347."
  }
}
