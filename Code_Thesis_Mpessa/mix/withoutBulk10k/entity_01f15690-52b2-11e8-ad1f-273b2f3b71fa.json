{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=12354",
  "eid" : "01f15690-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778512505,
  "textBody" : "In mathematics, the greatest common divisor (gcd) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers.  For example, the gcd of 8 and 12 is 4.\n\nThe greatest common divisor is also known as the greatest common factor (gcf),. highest common factor (hcf),. greatest common measure (gcm),. or highest common divisor.\n\nThis notion can be extended to polynomials (see Polynomial greatest common divisor) and other commutative rings (see below).\n\nOverview \n\nNotation \n\nIn this article we will denote the greatest common divisor of two integers a and b as gcd(a,b). Some authors use (a,b). explains his choice of notation: \"Many authors write (a,b) for . We do not, because we shall often use (a,b) to represent a point in the Euclidean plane.\"\n\nExample \n\nWhat is the greatest common divisor of 54 and 24? \n\nThe number 54 can be expressed as a product of two integers in several different ways:\n 54 \\times 1 27 \\times 2 \n 18 \\times 3 = 9 \\times 6. \\, \n\nThus the divisors of 54 are:   1, 2, 3, 6, 9, 18, 27, 54. \\, \n\nSimilarly, the divisors of 24 are:   1, 2, 3, 4, 6, 8, 12, 24. \\, \n\nThe numbers that these two lists share in common are the common divisors of 54 and 24:\n\n 1, 2, 3, 6. \\, \n\nThe greatest of these is 6. That is, the greatest common divisor of 54 and 24. One writes:\n\n \\gcd(54,24) = 6. \\, \n\nReducing fractions \n\nThe greatest common divisor is useful for reducing fractions to be in lowest terms. For example, gcd(42, 56) = 14, therefore,\n\n\\frac{42}{56}\\frac{3 \\cdot 14 }{ 4 \\cdot 14}\n\\frac{3 }{ 4}.\n\nCoprime numbers \n\nTwo numbers are called relatively prime, or coprime, if their greatest common divisor equals 1. For example, 9 and 28 are relatively prime.\n\nA geometric view \n\nFor example, a 24-by-60 rectangular area can be divided into a grid of: 1-by-1 squares, 2-by-2 squares, 3-by-3 squares, 4-by-4 squares, 6-by-6 squares or 12-by-12 squares. Therefore, 12 is the greatest common divisor of 24 and 60. A 24-by-60 rectangular area can be divided into a grid of 12-by-12 squares, with two squares along one edge (24/12  2) and five squares along the other (60/12 \n 5).\n\nCalculation \n\nUsing prime factorizations \n\nGreatest common divisors can in principle be computed by determining the prime factorizations of the two numbers and comparing factors, as in the following example: to compute gcd(18, 84), we find the prime factorizations 18  2 · 32 and 84 \n 22 · 3 · 7 and notice that the \"overlap\" of the two expressions is 2 · 3; so gcd(18, 84) = 6. In practice, this method is only feasible for small numbers; computing prime factorizations in general takes far too long.\n\nHere is another concrete example, illustrated by a Venn diagram. Suppose it is desired to find the greatest common divisor of 48 and 180. First, find the prime factorizations of the two numbers:\n\n48 = 2 × 2 × 2 × 2 × 3,\n180 = 2 × 2 × 3 × 3 × 5.\n\nWhat they share in common is two \"2\"s and a \"3\":\n\n[http://demonstrations.wolfram.com/UnderstandingTheLeastCommonMultipleAndGreatestCommonDivisor/ Gustavo Delfino, \"Understanding the Least Common Multiple and Greatest Common Divisor\", Wolfram Demonstrations Project, Published: February 1, 2013. ]\n \n\nLeast common multiple 2 × 2 × ( 2 × 2 × 3 ) × 3 × 5 \n 720\nGreatest common divisor 2 × 2 × 3 \n 12.\n\nUsing Euclid's algorithm \n\nA much more efficient method is the Euclidean algorithm, which uses a division algorithm such as long division in combination with the observation that the gcd of two numbers also divides their difference. To compute gcd(48,18), divide 48 by 18 to get a quotient of 2 and a remainder of 12. Then divide 18 by 12 to get a quotient of 1 and a remainder of 6. Then divide 12 by 6 to get a remainder of 0, which means that 6 is the gcd. Note that we ignored the quotient in each step except to notice when the remainder reached 0, signalling that we had arrived at the answer. Formally the algorithm can be described as:\n\n\\gcd(a,0) = a\n\\gcd(a,b) = \\gcd(b, a \\,\\mathrm{mod}\\, b),\nwhere\n a \\,\\mathrm{mod}\\, b = a - b \\left\\lfloor {a \\over b} \\right\\rfloor .\n\nIf the arguments are both greater than zero then the algorithm can be written in more elementary terms as follows:\n\n\\gcd(a,a) = a, \n\\gcd(a,b) = \\gcd(a - b,b)\\quad,  if a > b\n\\gcd(a,b) = \\gcd(a, b-a)\\quad, if b > a\n\nBinary method \n\nAn alternative method of computing the gcd is the binary gcd method which uses only subtraction and division by 2.\nIn outline the method is as follows: Let a and b be the two non negative integers. Also set the integer d to 0.  There are five possibilities:\n* a = b.\nAs gcd(a, a) = a, the desired gcd is a×2d (as a and b are changed in the other cases, and d records the number of times that a and b have been both divided by 2 in the next step, the gcd of the initial pair is the product of a by 2d).\n\n* Both a and b are even.\nIn this case 2 is a common divisor. Divide both a and b by 2, increment d by 1 to record the number of times 2 is a common divisor and continue.\n\n* a is even and b is odd.\nIn this case 2 is not a common divisor. Divide a by 2 and continue.\n\n* a is odd and b is even.\nAs in the previous case 2 is not a common divisor. Divide b by 2 and continue.\n\n* Both a and b are odd.\nAs gcd(a,b) gcd(b,a) and we have already considered the case a \n b, we may assume that a > b. The number c a − b is smaller than a yet still positive. Any number that divides a and b must also divide c so every common divisor of a and b is also a common divisor of b and c. Similarly, a \n b + c and every common divisor of b and c is also a common divisor of a and b. So the two pairs (a, b)  and (b, c) have the same common divisors, and thus gcd(a,b) = gcd(b,c). Moreover, as a and b are both odd, c is even, and one may replace c by c/2 without changing the gcd. Thus the process can be continued with the pair (a, b) replaced by the smaller numbers (c/2, b).\n\nEach of the above steps reduces at least one of a and b towards 0 and so can only be repeated a finite number of times. Thus one must eventually reach the case a = b, which is the only stopping case. Then, as quoted above, the gcd is a×2d.\n\nThis algorithm may easily be programmed as follows:\n Input: a, b positive integers\n Output: g and d such that g is odd and gcd(a, b) = g×2d\n     d := 0\n     while a and b are both even do\n         a := a/2\n         b := b/2\n         d := d + 1\n     while a ≠ b do\n         if a is even then a := a/2\n         else if b is even then b := b/2\n         else if a > b then a := (a – b)/2\n         else b := (b – a)/2\n     g := a\n     output g, d\n\nExample: (a, b, d) (48,  18, 0) → (24, 9, 1) → (12, 9, 1) → (6, 9, 1) → (3, 9, 1) → (3, 6, 1) → (3, 3, 1) ; the original gcd is thus 2d \n 21 times ab\n 3, that is 6.\n\nThe Binary GCD algorithm is particularly easy to implement on binary computers. The test for whether a number is divisible by two can be performed by testing the lowest bit in the number. Division by two can be achieved by shifting the input number by one bit. Each step of the algorithm makes at least one such shift. Subtracting two numbers smaller than a and b costs O(\\log a+\\log b) bit operations. Each step makes at most one such subtraction. The total number of steps is at most the sum of the numbers of bits of a and b, hence the computational complexity is\n\nO((\\log a + \\log b)^2).\n\nFor further details see Binary GCD algorithm.\n\nOther methods \n\nIf a and b are both nonzero, the greatest common divisor of a and b can be computed by using least common multiple (lcm) of a and b:\n\n\\gcd(a,b)=\\frac{a\\cdot b}{\\operatorname{lcm}(a,b)},\n\nbut more commonly the lcm is computed from the gcd.\n\nUsing Thomae's function f,\n\\gcd(a,b) = a f\\left(\\frac b a\\right),\nwhich generalizes to a and b rational numbers or commensurable real numbers.\n\nKeith Slavin has shown that for odd a ≥ 1:\n\n\\gcd(a,b)\\log_2\\prod_{k\n0}^{a-1} (1+e^{-2i\\pi k b/a})\n\nwhich is a function that can be evaluated for complex b. Wolfgang Schramm has shown that\n\n\\gcd(a,b)\\sum\\limits_{k\n1}^a \\exp (2\\pi ikb/a) \\cdot \\sum\\limits_{d\\left| a\\right.} \\frac{c_d (k)}{d} \n\nis an entire function in the variable b for all positive integers a where cd(k) is Ramanujan's sum. Donald Knuth proved the following reduction:\n\n\\gcd(2^a-1, 2^b-1)=2^{\\gcd(a,b)}-1\n\nfor non-negative integers a and b, where a and b are not both zero. More generally\n\n\\gcd(n^a-1,n^b-1)=n^{\\gcd(a,b)}-1 \\, \n\nwhich can be proven by considering the Euclidean algorithm in base n. Another useful identity relates \\gcd(a,b) to the Euler's totient function:\n\n \\gcd(a,b) = \\sum_{k|a \\text{ and }k|b} \\varphi(k). \n\nComplexity\n\nThe computational complexity of the computation of greatest common divisors has been widely studied. If one uses the Euclidean algorithm and the elementary algorithms for multiplication and division, the computation of the greatest common divisor of two integers of at most  bits is O(n^2). This means that the computation of greatest common divisor has, up to a constant factor, the same complexity as the multiplication.\n\nHowever, if a fast multiplication algorithm is used, one may modify the Euclidean algorithm for improving the complexity, but the computation of a greatest common divisor becomes slower than the multiplication. More precisely, if the multiplication of two integers of  bits takes a time of , then the best known algorithm for greatest common divisor has a complexity O\\left(T(n)\\log n\\right). This implies that the best known algorithm has a complexity of O\\left(n\\,(\\log n)^2\\log\\log n\\right).\n\nPrevious complexities are valid for the usual models of computation, specifically multitape Turing machines and Random-access machines.\n\nThe computation of the greatest common divisors  belongs thus to the class of problems solvable in quasilinear time. A fortiori, the corresponding decision problem belongs to the class P of problems solvable in polynomial time. The GCD problem is not known to be in NC, and so there is no known way to parallelize it efficiently; nor is it known to be P-complete, which would imply that it is unlikely to be possible to efficiently parallelize GCD computation. Shallcross et al. showed that a related problem (EUGCD, determining the remainder sequence arising during the Euclidean algorithm) is NC-equivalent to the problem of integer linear programming with two variables; if either problem is in NC or is P-complete, the other is as well. Since NC contains NL, it is also unknown whether a space-efficient algorithm for computing the GCD exists, even for nondeterministic Turing machines.\n\nAlthough the problem is not known to be in NC, parallel algorithms asymptotically faster than the Euclidean algorithm exist; the best known deterministic algorithm is by Chor and Goldreich, which (in the CRCW-PRAM model) can solve the problem in O(n/log n) time with n1+ε processors. Randomized algorithms can solve the problem in O((log n)2) time on \\exp\\left[O\\left(\\sqrt{n \\log n}\\right)\\right] processors (note this is superpolynomial).\n\nProperties \n\n*Every common divisor of a and b is a divisor of .\n*, where a and b are not both zero, may be defined alternatively and equivalently as the smallest positive integer d which can be written in the form , where p and q are integers. This expression is called Bézout's identity. Numbers p and q like this can be computed with the extended Euclidean algorithm.\n*, for , since any number is a divisor of 0, and the greatest divisor of a is |a|.  This is usually used as the base case in the Euclidean algorithm.\n*If a divides the product b·c, and , then a/d divides c.\n*If m is a non-negative integer, then .\n*If m is any integer, then .\n*If m is a nonzero common divisor of a and b, then .\n*The gcd is a multiplicative function in the following sense: if a1 and a2 are relatively prime, then . In particular,  recalling that gcd is a positive integer valued function (i.e., gets natural values only)   we obtain that  if and only if  and .\n*The gcd is a commutative function: .\n*The gcd is an associative function: .\n*The gcd of three numbers can be computed as , or in some different way by applying commutativity and associativity. This can be extended to any number of numbers.\n* is closely related to the least common multiple : we have\n:.\nThis formula is often used to compute least common multiples: one first computes the gcd with Euclid's algorithm and then divides the product of the given numbers by their gcd.\n*The following versions of distributivity hold true:\n:\n:.\n*If we have the unique prime factorizations of   and  where  and , then the gcd of a and b is \n:\n*It is sometimes useful to define  and  because then the natural numbers become a complete distributive lattice with gcd as meet and lcm as join operation.. Footnote 27, p. 9: \"For example, the natural numbers with gcd (greatest common divisor) as meet and lcm (least common multiple) as join operation determine a (complete distributive) lattice.\" Including these definitions for 0 is necessary for this result: if one instead omits 0 from the set of natural numbers, the resulting lattice is not complete. This extension of the definition is also compatible with the generalization for commutative rings given below.\n*In a Cartesian coordinate system,  can be interpreted as the number of segments between points with integral coordinates on the straight line segment joining the points  and .\n\nProbabilities and expected value \n\nIn 1972, James E. Nymann showed that k integers, chosen independently and uniformly from {1,...,n}, are coprime with probability 1/ζ(k) as n goes to infinity, where ζ refers to the Riemann zeta function. (See coprime for a derivation.) This result was extended in 1987 to show that the probability that k random integers have greatest common divisor d is d−k/ζ(k).\n\nUsing this information, the expected value of the greatest common divisor function can be seen (informally) to not exist when k  2. In this case the probability that the gcd equals d is d−2/ζ(2), and since ζ(2) \n π2/6 we have\n\n\\mathrm{E}( \\mathrm{2} ) \\sum_{d\n1}^\\infty d \\frac{6}{\\pi^2 d^2} \\frac{6}{\\pi^2} \\sum_{d\n1}^\\infty \\frac{1}{d}.\n\nThis last summation is the harmonic series, which diverges. However, when k ≥ 3, the expected value is well-defined, and by the above argument, it is\n\n \\mathrm{E}(k) \\sum_{d\n1}^\\infty d^{1-k} \\zeta(k)^{-1} = \\frac{\\zeta(k-1)}{\\zeta(k)}. \n\nFor k  3, this is approximately equal to 1.3684. For k \n 4, it is approximately 1.1106.\n\nThe gcd in commutative rings \n\nThe notion of greatest common divisor can more generally be defined for elements of an arbitrary commutative ring, although in general there need not exist one for every pair of elements.\n\nIf  is a commutative ring, and  and  are in , then an element  of  is called a common divisor of  and  if it divides both  and  (that is, if there are elements  and  in  such that d·x  a and d·y \n b).\nIf  is a common divisor of  and , and every common divisor of  and  divides , then  is called a greatest common divisor of  and b.\n\nNote that with this definition, two elements  and  may very well have several greatest common divisors, or none at all. If  is an integral domain then any two gcd's of  and  must be associate elements, since by definition either one must divide the other; indeed if a gcd exists, any one of its associates is a gcd as well. Existence of a gcd is not assured in arbitrary integral domains. However if  is a unique factorization domain, then any two elements have a gcd, and more generally this is true in gcd domains.\nIf  is a Euclidean domain in which euclidean division is given algorithmically (as is the case for instance when R = F[X] where  is a field, or when  is the ring of Gaussian integers), then greatest common divisors can be computed using a form of the Euclidean algorithm based on the division procedure.\n\nThe following is an example of an integral domain with two elements that do not have a gcd:\n\nR \\mathbb{Z}\\left[\\sqrt{-3}\\,\\,\\right],\\quad a \n 4 2\\cdot 2 \n \\left(1+\\sqrt{-3}\\,\\,\\right)\\left(1-\\sqrt{-3}\\,\\,\\right),\\quad b = \\left(1+\\sqrt{-3}\\,\\,\\right)\\cdot 2.\n\nThe elements 2 and 1 +  are two \"maximal common divisors\" (i.e. any common divisor which is a multiple of 2 is associated to 2, the same holds for 1 + , but they are not associated, so there is no greatest common divisor of  and b.\n\nCorresponding to the Bézout property we may, in any commutative ring, consider the collection of elements of the form pa + qb, where  and  range over the ring. This is the ideal generated by  and , and is denoted simply (a, b). In a ring all of whose ideals are principal (a principal ideal domain or PID), this ideal will be identical with the set of multiples of some ring element d; then this  is a greatest common divisor of  and b. But the ideal (a, b) can be useful even when there is no greatest common divisor of  and b. (Indeed, Ernst Kummer used this ideal as a replacement for a gcd in his treatment of Fermat's Last Theorem, although he envisioned it as the set of multiples of some hypothetical, or ideal, ring element , whence the ring-theoretic term.)",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Greatest common divisor" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=12354" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In mathematics, the greatest common divisor (gcd) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers.  For example, the gcd of 8 and 12 is 4.\n\nThe greatest common divisor is also known as the greatest common factor (gcf),. highest common factor (hcf),. greatest common measure (gcm),. or highest common divisor.\n\nThis notion can be extended to polynomials (see Polynomial greatest common divisor) and other commutative rings (see below).\n\nOverview \n\nNotation \n\nIn this article we will denote the greatest common divisor of two integers a and b as gcd(a,b). Some authors use (a,b). explains his choice of notation: \"Many authors write (a,b) for . We do not, because we shall often use (a,b) to represent a point in the Euclidean plane.\"\n\nExample \n\nWhat is the greatest common divisor of 54 and 24? \n\nThe number 54 can be expressed as a product of two integers in several different ways:\n 54 \\times 1 27 \\times 2 \n 18 \\times 3 = 9 \\times 6. \\, \n\nThus the divisors of 54 are:   1, 2, 3, 6, 9, 18, 27, 54. \\, \n\nSimilarly, the divisors of 24 are:   1, 2, 3, 4, 6, 8, 12, 24. \\, \n\nThe numbers that these two lists share in common are the common divisors of 54 and 24:\n\n 1, 2, 3, 6. \\, \n\nThe greatest of these is 6. That is, the greatest common divisor of 54 and 24. One writes:\n\n \\gcd(54,24) = 6. \\, \n\nReducing fractions \n\nThe greatest common divisor is useful for reducing fractions to be in lowest terms. For example, gcd(42, 56) = 14, therefore,\n\n\\frac{42}{56}\\frac{3 \\cdot 14 }{ 4 \\cdot 14}\n\\frac{3 }{ 4}.\n\nCoprime numbers \n\nTwo numbers are called relatively prime, or coprime, if their greatest common divisor equals 1. For example, 9 and 28 are relatively prime.\n\nA geometric view \n\nFor example, a 24-by-60 rectangular area can be divided into a grid of: 1-by-1 squares, 2-by-2 squares, 3-by-3 squares, 4-by-4 squares, 6-by-6 squares or 12-by-12 squares. Therefore, 12 is the greatest common divisor of 24 and 60. A 24-by-60 rectangular area can be divided into a grid of 12-by-12 squares, with two squares along one edge (24/12  2) and five squares along the other (60/12 \n 5).\n\nCalculation \n\nUsing prime factorizations \n\nGreatest common divisors can in principle be computed by determining the prime factorizations of the two numbers and comparing factors, as in the following example: to compute gcd(18, 84), we find the prime factorizations 18  2 · 32 and 84 \n 22 · 3 · 7 and notice that the \"overlap\" of the two expressions is 2 · 3; so gcd(18, 84) = 6. In practice, this method is only feasible for small numbers; computing prime factorizations in general takes far too long.\n\nHere is another concrete example, illustrated by a Venn diagram. Suppose it is desired to find the greatest common divisor of 48 and 180. First, find the prime factorizations of the two numbers:\n\n48 = 2 × 2 × 2 × 2 × 3,\n180 = 2 × 2 × 3 × 3 × 5.\n\nWhat they share in common is two \"2\"s and a \"3\":\n\n[http://demonstrations.wolfram.com/UnderstandingTheLeastCommonMultipleAndGreatestCommonDivisor/ Gustavo Delfino, \"Understanding the Least Common Multiple and Greatest Common Divisor\", Wolfram Demonstrations Project, Published: February 1, 2013. ]\n \n\nLeast common multiple 2 × 2 × ( 2 × 2 × 3 ) × 3 × 5 \n 720\nGreatest common divisor 2 × 2 × 3 \n 12.\n\nUsing Euclid's algorithm \n\nA much more efficient method is the Euclidean algorithm, which uses a division algorithm such as long division in combination with the observation that the gcd of two numbers also divides their difference. To compute gcd(48,18), divide 48 by 18 to get a quotient of 2 and a remainder of 12. Then divide 18 by 12 to get a quotient of 1 and a remainder of 6. Then divide 12 by 6 to get a remainder of 0, which means that 6 is the gcd. Note that we ignored the quotient in each step except to notice when the remainder reached 0, signalling that we had arrived at the answer. Formally the algorithm can be described as:\n\n\\gcd(a,0) = a\n\\gcd(a,b) = \\gcd(b, a \\,\\mathrm{mod}\\, b),\nwhere\n a \\,\\mathrm{mod}\\, b = a - b \\left\\lfloor {a \\over b} \\right\\rfloor .\n\nIf the arguments are both greater than zero then the algorithm can be written in more elementary terms as follows:\n\n\\gcd(a,a) = a, \n\\gcd(a,b) = \\gcd(a - b,b)\\quad,  if a > b\n\\gcd(a,b) = \\gcd(a, b-a)\\quad, if b > a\n\nBinary method \n\nAn alternative method of computing the gcd is the binary gcd method which uses only subtraction and division by 2.\nIn outline the method is as follows: Let a and b be the two non negative integers. Also set the integer d to 0.  There are five possibilities:\n* a = b.\nAs gcd(a, a) = a, the desired gcd is a×2d (as a and b are changed in the other cases, and d records the number of times that a and b have been both divided by 2 in the next step, the gcd of the initial pair is the product of a by 2d).\n\n* Both a and b are even.\nIn this case 2 is a common divisor. Divide both a and b by 2, increment d by 1 to record the number of times 2 is a common divisor and continue.\n\n* a is even and b is odd.\nIn this case 2 is not a common divisor. Divide a by 2 and continue.\n\n* a is odd and b is even.\nAs in the previous case 2 is not a common divisor. Divide b by 2 and continue.\n\n* Both a and b are odd.\nAs gcd(a,b) gcd(b,a) and we have already considered the case a \n b, we may assume that a > b. The number c a − b is smaller than a yet still positive. Any number that divides a and b must also divide c so every common divisor of a and b is also a common divisor of b and c. Similarly, a \n b + c and every common divisor of b and c is also a common divisor of a and b. So the two pairs (a, b)  and (b, c) have the same common divisors, and thus gcd(a,b) = gcd(b,c). Moreover, as a and b are both odd, c is even, and one may replace c by c/2 without changing the gcd. Thus the process can be continued with the pair (a, b) replaced by the smaller numbers (c/2, b).\n\nEach of the above steps reduces at least one of a and b towards 0 and so can only be repeated a finite number of times. Thus one must eventually reach the case a = b, which is the only stopping case. Then, as quoted above, the gcd is a×2d.\n\nThis algorithm may easily be programmed as follows:\n Input: a, b positive integers\n Output: g and d such that g is odd and gcd(a, b) = g×2d\n     d := 0\n     while a and b are both even do\n         a := a/2\n         b := b/2\n         d := d + 1\n     while a ≠ b do\n         if a is even then a := a/2\n         else if b is even then b := b/2\n         else if a > b then a := (a – b)/2\n         else b := (b – a)/2\n     g := a\n     output g, d\n\nExample: (a, b, d) (48,  18, 0) → (24, 9, 1) → (12, 9, 1) → (6, 9, 1) → (3, 9, 1) → (3, 6, 1) → (3, 3, 1) ; the original gcd is thus 2d \n 21 times ab\n 3, that is 6.\n\nThe Binary GCD algorithm is particularly easy to implement on binary computers. The test for whether a number is divisible by two can be performed by testing the lowest bit in the number. Division by two can be achieved by shifting the input number by one bit. Each step of the algorithm makes at least one such shift. Subtracting two numbers smaller than a and b costs O(\\log a+\\log b) bit operations. Each step makes at most one such subtraction. The total number of steps is at most the sum of the numbers of bits of a and b, hence the computational complexity is\n\nO((\\log a + \\log b)^2).\n\nFor further details see Binary GCD algorithm.\n\nOther methods \n\nIf a and b are both nonzero, the greatest common divisor of a and b can be computed by using least common multiple (lcm) of a and b:\n\n\\gcd(a,b)=\\frac{a\\cdot b}{\\operatorname{lcm}(a,b)},\n\nbut more commonly the lcm is computed from the gcd.\n\nUsing Thomae's function f,\n\\gcd(a,b) = a f\\left(\\frac b a\\right),\nwhich generalizes to a and b rational numbers or commensurable real numbers.\n\nKeith Slavin has shown that for odd a ≥ 1:\n\n\\gcd(a,b)\\log_2\\prod_{k\n0}^{a-1} (1+e^{-2i\\pi k b/a})\n\nwhich is a function that can be evaluated for complex b. Wolfgang Schramm has shown that\n\n\\gcd(a,b)\\sum\\limits_{k\n1}^a \\exp (2\\pi ikb/a) \\cdot \\sum\\limits_{d\\left| a\\right.} \\frac{c_d (k)}{d} \n\nis an entire function in the variable b for all positive integers a where cd(k) is Ramanujan's sum. Donald Knuth proved the following reduction:\n\n\\gcd(2^a-1, 2^b-1)=2^{\\gcd(a,b)}-1\n\nfor non-negative integers a and b, where a and b are not both zero. More generally\n\n\\gcd(n^a-1,n^b-1)=n^{\\gcd(a,b)}-1 \\, \n\nwhich can be proven by considering the Euclidean algorithm in base n. Another useful identity relates \\gcd(a,b) to the Euler's totient function:\n\n \\gcd(a,b) = \\sum_{k|a \\text{ and }k|b} \\varphi(k). \n\nComplexity\n\nThe computational complexity of the computation of greatest common divisors has been widely studied. If one uses the Euclidean algorithm and the elementary algorithms for multiplication and division, the computation of the greatest common divisor of two integers of at most  bits is O(n^2). This means that the computation of greatest common divisor has, up to a constant factor, the same complexity as the multiplication.\n\nHowever, if a fast multiplication algorithm is used, one may modify the Euclidean algorithm for improving the complexity, but the computation of a greatest common divisor becomes slower than the multiplication. More precisely, if the multiplication of two integers of  bits takes a time of , then the best known algorithm for greatest common divisor has a complexity O\\left(T(n)\\log n\\right). This implies that the best known algorithm has a complexity of O\\left(n\\,(\\log n)^2\\log\\log n\\right).\n\nPrevious complexities are valid for the usual models of computation, specifically multitape Turing machines and Random-access machines.\n\nThe computation of the greatest common divisors  belongs thus to the class of problems solvable in quasilinear time. A fortiori, the corresponding decision problem belongs to the class P of problems solvable in polynomial time. The GCD problem is not known to be in NC, and so there is no known way to parallelize it efficiently; nor is it known to be P-complete, which would imply that it is unlikely to be possible to efficiently parallelize GCD computation. Shallcross et al. showed that a related problem (EUGCD, determining the remainder sequence arising during the Euclidean algorithm) is NC-equivalent to the problem of integer linear programming with two variables; if either problem is in NC or is P-complete, the other is as well. Since NC contains NL, it is also unknown whether a space-efficient algorithm for computing the GCD exists, even for nondeterministic Turing machines.\n\nAlthough the problem is not known to be in NC, parallel algorithms asymptotically faster than the Euclidean algorithm exist; the best known deterministic algorithm is by Chor and Goldreich, which (in the CRCW-PRAM model) can solve the problem in O(n/log n) time with n1+ε processors. Randomized algorithms can solve the problem in O((log n)2) time on \\exp\\left[O\\left(\\sqrt{n \\log n}\\right)\\right] processors (note this is superpolynomial).\n\nProperties \n\n*Every common divisor of a and b is a divisor of .\n*, where a and b are not both zero, may be defined alternatively and equivalently as the smallest positive integer d which can be written in the form , where p and q are integers. This expression is called Bézout's identity. Numbers p and q like this can be computed with the extended Euclidean algorithm.\n*, for , since any number is a divisor of 0, and the greatest divisor of a is |a|.  This is usually used as the base case in the Euclidean algorithm.\n*If a divides the product b·c, and , then a/d divides c.\n*If m is a non-negative integer, then .\n*If m is any integer, then .\n*If m is a nonzero common divisor of a and b, then .\n*The gcd is a multiplicative function in the following sense: if a1 and a2 are relatively prime, then . In particular,  recalling that gcd is a positive integer valued function (i.e., gets natural values only)   we obtain that  if and only if  and .\n*The gcd is a commutative function: .\n*The gcd is an associative function: .\n*The gcd of three numbers can be computed as , or in some different way by applying commutativity and associativity. This can be extended to any number of numbers.\n* is closely related to the least common multiple : we have\n:.\nThis formula is often used to compute least common multiples: one first computes the gcd with Euclid's algorithm and then divides the product of the given numbers by their gcd.\n*The following versions of distributivity hold true:\n:\n:.\n*If we have the unique prime factorizations of   and  where  and , then the gcd of a and b is \n:\n*It is sometimes useful to define  and  because then the natural numbers become a complete distributive lattice with gcd as meet and lcm as join operation.. Footnote 27, p. 9: \"For example, the natural numbers with gcd (greatest common divisor) as meet and lcm (least common multiple) as join operation determine a (complete distributive) lattice.\" Including these definitions for 0 is necessary for this result: if one instead omits 0 from the set of natural numbers, the resulting lattice is not complete. This extension of the definition is also compatible with the generalization for commutative rings given below.\n*In a Cartesian coordinate system,  can be interpreted as the number of segments between points with integral coordinates on the straight line segment joining the points  and .\n\nProbabilities and expected value \n\nIn 1972, James E. Nymann showed that k integers, chosen independently and uniformly from {1,...,n}, are coprime with probability 1/ζ(k) as n goes to infinity, where ζ refers to the Riemann zeta function. (See coprime for a derivation.) This result was extended in 1987 to show that the probability that k random integers have greatest common divisor d is d−k/ζ(k).\n\nUsing this information, the expected value of the greatest common divisor function can be seen (informally) to not exist when k  2. In this case the probability that the gcd equals d is d−2/ζ(2), and since ζ(2) \n π2/6 we have\n\n\\mathrm{E}( \\mathrm{2} ) \\sum_{d\n1}^\\infty d \\frac{6}{\\pi^2 d^2} \\frac{6}{\\pi^2} \\sum_{d\n1}^\\infty \\frac{1}{d}.\n\nThis last summation is the harmonic series, which diverges. However, when k ≥ 3, the expected value is well-defined, and by the above argument, it is\n\n \\mathrm{E}(k) \\sum_{d\n1}^\\infty d^{1-k} \\zeta(k)^{-1} = \\frac{\\zeta(k-1)}{\\zeta(k)}. \n\nFor k  3, this is approximately equal to 1.3684. For k \n 4, it is approximately 1.1106.\n\nThe gcd in commutative rings \n\nThe notion of greatest common divisor can more generally be defined for elements of an arbitrary commutative ring, although in general there need not exist one for every pair of elements.\n\nIf  is a commutative ring, and  and  are in , then an element  of  is called a common divisor of  and  if it divides both  and  (that is, if there are elements  and  in  such that d·x  a and d·y \n b).\nIf  is a common divisor of  and , and every common divisor of  and  divides , then  is called a greatest common divisor of  and b.\n\nNote that with this definition, two elements  and  may very well have several greatest common divisors, or none at all. If  is an integral domain then any two gcd's of  and  must be associate elements, since by definition either one must divide the other; indeed if a gcd exists, any one of its associates is a gcd as well. Existence of a gcd is not assured in arbitrary integral domains. However if  is a unique factorization domain, then any two elements have a gcd, and more generally this is true in gcd domains.\nIf  is a Euclidean domain in which euclidean division is given algorithmically (as is the case for instance when R = F[X] where  is a field, or when  is the ring of Gaussian integers), then greatest common divisors can be computed using a form of the Euclidean algorithm based on the division procedure.\n\nThe following is an example of an integral domain with two elements that do not have a gcd:\n\nR \\mathbb{Z}\\left[\\sqrt{-3}\\,\\,\\right],\\quad a \n 4 2\\cdot 2 \n \\left(1+\\sqrt{-3}\\,\\,\\right)\\left(1-\\sqrt{-3}\\,\\,\\right),\\quad b = \\left(1+\\sqrt{-3}\\,\\,\\right)\\cdot 2.\n\nThe elements 2 and 1 +  are two \"maximal common divisors\" (i.e. any common divisor which is a multiple of 2 is associated to 2, the same holds for 1 + , but they are not associated, so there is no greatest common divisor of  and b.\n\nCorresponding to the Bézout property we may, in any commutative ring, consider the collection of elements of the form pa + qb, where  and  range over the ring. This is the ideal generated by  and , and is denoted simply (a, b). In a ring all of whose ideals are principal (a principal ideal domain or PID), this ideal will be identical with the set of multiples of some ring element d; then this  is a greatest common divisor of  and b. But the ideal (a, b) can be useful even when there is no greatest common divisor of  and b. (Indeed, Ernst Kummer used this ideal as a replacement for a gcd in his treatment of Fermat's Last Theorem, although he envisioned it as the set of multiples of some hypothetical, or ideal, ring element , whence the ring-theoretic term.). Greatest common divisor. http://en.wikipedia.org/?curid=12354."
  }
}
