{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=3172",
  "eid" : "c49888e0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778409582,
  "textBody" : "ANSI C, ISO C and Standard C refer to the successive standards for the C programming language published by the American National Standards Institute (ANSI) and the International Organization for Standardization (ISO).  Historically, the names referred specifically to the original and best-supported version of the standard (known as C89 or C90).  Software developers writing in C are encouraged to conform to the standards, as doing so helps portability between compilers.\n\nHistory and outlook\n\nThe first standard for C was published by ANSI. Although this document was subsequently adopted by International Organization for Standardization (ISO) and subsequent revisions published by ISO have been adopted by ANSI, many programmers still use \"ANSI C\" to refer to the standard. While some software developers use the term ISO C, others are standards-body neutral and use Standard C.\n\nC89\n\nIn 1983, the American National Standards Institute formed a committee, X3J11, to establish a standard specification of C. The standard was completed in 1989 and ratified as ANSI X3.159-1989 \"Programming Language C.\" This version of the language is often referred to as \"ANSI C\". Later on sometimes the label \"C89\" is used to distinguish it from C99 but using the same labelling method.\n\nC90\n\nThe same standard as C89 was ratified by the International Organization for Standardization as ISO/IEC 9899:1990, with only formatting changes, which is sometimes referred to as C90. Therefore, the terms \"C89\" and \"C90\" refer to essentially the same language.\n\nThis standard has been withdrawn by both ANSI/INCITS and ISO/IEC.\n\nC95\n\nIn 1995, the ISO published an extension, called Amendment 1, for the ANSI-C standard. Its full name finally was ISO/IEC 9899/AMD1:1995 or nicknamed C95. Aside from error correction there were further changes to the language capabilities, such as:\n\n* Improved multi-byte and wide character support in the standard library, introducing  and  as well as multi-byte I/O\n* Addition of digraphs to the language\n* Specification of standard macros for the alternative specification of operators, e.g. and for &&\n* Specification of the standard macro __STDC_VERSION__\n\nIn addition to the amendment, two technical corrigenda were published by ISO for C90:\n\n* ISO/IEC 9899 TCOR1 in 1995\n* ISO/IEC 9899 TCOR2 in 1996\n\nPreprocessor test for C95 compatibility\n\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199409L\n\n/* C95 compatible source code. */\n#elif defined(__ANSI__)\n/* C89 compatible source code. */\n#endif\n\nC99\n\nIn March 2000, ANSI adopted the ISO/IEC 9899:1999 standard. This standard is commonly referred to as C99. Some notable additions to the previous standard include:\n\n* New built-in data types: long long, _Bool, _Complex, and _Imaginary\n* Several new core language features, including static array indices, designated initializers, compound literals, variable-length arrays, flexible array members, variadic macros, and restrict keyword\n* Several new library headers, including stdint.h, , fenv.h, \n* Improved compatibility with several C++ features, including inline functions, single-line comments with //, mixing declarations and code, and universal character names in identifiers\n* Removed several dangerous C89 language features such as implicit function declarations and implicit int\n\nThree technical corrigenda were published by ISO for C99:\n\n* ISO/IEC 9899:1999/Cor.1:2001(E)\n* ISO/IEC 9899:1999/Cor.2:2004(E)\n* ISO/IEC 9899:1999/Cor.3:2007(E), notable for deprecating the standard library function gets\n\nThis standard has been withdrawn by both ANSI/INCITS and ISO/IEC in favour of C11.\n\nC11\n\n\"C11\" is the current standard for the C programming language. Notable features introduced over the previous revision include improved Unicode support, type-generic expressions using the new _Generic keyword, a cross-platform multi-threading API (threads.h) and atomic types support in both core language and the library (stdatomic.h).\n\nOne technical corrigendum has been published by ISO for C11:\n\n* ISO/IEC 9899:2011/Cor 1:2012\n\nOther related ISO publications\n\nAs part of the standardization process, ISO also publishes technical reports and specifications related to the C language:\n\n* ISO/IEC TR 19769:2004, on library extensions to support Unicode transformation formats, integrated into C11\n* ISO/IEC TR 24731-1:2007, on library extensions to support bounds-checked interfaces, integrated into C11\n* ISO/IEC TR 18037:2008, on embedded C extensions\n* ISO/IEC TR 24732:2009, on decimal floating point arithmetic, superseded by ISO/IEC TS 18661-2:2015\n* ISO/IEC TR 24747:2009, on special mathematical functions,\n* ISO/IEC TR 24731-2:2010, on library extensions to support dynamic allocation functions\n* ISO/IEC TS 17961:2013, on secure coding in C\n* ISO/IEC TS 18661-1:2014, on IEC 60559:2011-compatible binary floating-point arithmetic\n* ISO/IEC TS 18661-2:2015, on IEC 60559:2011-compatible decimal floating point arithmetic\n* ISO/IEC TS 18661-3:2015, on IEC 60559:2011-compatible interchange and extended floating-point types\n* ISO/IEC TS 18661-4:2015, on IEC 60559:2011-compatible supplementary functions\nMore technical specifications are in development and pending approval, including the fifth and final part of TS 18661, a software transactional memory specification, and parallel library extensions.See a list at http://en.cppreference.com/w/c/experimental Visited 16 January 2016.\n\nSupport from major compilers\n\nANSI C is now supported by almost all the widely used compilers. Most of the C code being written nowadays is based on ANSI C. Any program written only in standard C and without any hardware dependent assumptions is virtually guaranteed to compile correctly on any platform with a conforming C implementation.  Without such precautions, most programs may compile only on a certain platform or with a particular compiler, due, for example, to the use of non-standard libraries, such as GUI libraries, or to the reliance on compiler- or platform-specific attributes such as the exact size of certain data types and byte endianness.\n\nCompliance detectability\n\nTo mitigate the differences between K&R C and the ANSI C standard, the __STDC__ (\"standard c\") macro can be used to split code into ANSI and K&R sections.\n\n #if defined(__STDC__) && __STDC__\n extern int getopt(int, char * const *, const char *);\n #else\n extern int getopt();\n #endif\n\nIn the above example, a prototype is used in a function declaration for ANSI compliant implementations, while an obsolescent non-prototype declaration is used otherwise. Those are still ANSI-compliant as of C99. Note how this code checks both definition and evaluation: this is because some implementations may set __STDC__ to zero to indicate non-ANSI compliance.\n\nCompilers supporting ANSI C\n\n* Amsterdam Compiler Kit (C K&R and C89/90)\n* ARM RealView\n* Clang, using LLVM backend\n* GCC (full C89/90, C99 and C11)\n* HP C/ANSI C compiler (C89 and C99)\n* IBM XL C/C++ (C11, starting with version 12.1)[http://www.ibm.com/developerworks/rational/library/support-iso-c11/index.html Support for ISO C11 added to IBM XL C/C++ compilers]\n* Intel's ICC\n* LabWindows/CVI\n* LCC\n* OpenWatcom (C89/90 and some C99)\n* Microsoft Visual C++ (C89/90 and some C99)\n* Pelles C (C99 and C11. Windows only.)\n* vbcc (C89/90 and C99)\n* Tiny C Compiler (C89/90 and some C99)",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "ANSI C" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=3172" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "ANSI C, ISO C and Standard C refer to the successive standards for the C programming language published by the American National Standards Institute (ANSI) and the International Organization for Standardization (ISO).  Historically, the names referred specifically to the original and best-supported version of the standard (known as C89 or C90).  Software developers writing in C are encouraged to conform to the standards, as doing so helps portability between compilers.\n\nHistory and outlook\n\nThe first standard for C was published by ANSI. Although this document was subsequently adopted by International Organization for Standardization (ISO) and subsequent revisions published by ISO have been adopted by ANSI, many programmers still use \"ANSI C\" to refer to the standard. While some software developers use the term ISO C, others are standards-body neutral and use Standard C.\n\nC89\n\nIn 1983, the American National Standards Institute formed a committee, X3J11, to establish a standard specification of C. The standard was completed in 1989 and ratified as ANSI X3.159-1989 \"Programming Language C.\" This version of the language is often referred to as \"ANSI C\". Later on sometimes the label \"C89\" is used to distinguish it from C99 but using the same labelling method.\n\nC90\n\nThe same standard as C89 was ratified by the International Organization for Standardization as ISO/IEC 9899:1990, with only formatting changes, which is sometimes referred to as C90. Therefore, the terms \"C89\" and \"C90\" refer to essentially the same language.\n\nThis standard has been withdrawn by both ANSI/INCITS and ISO/IEC.\n\nC95\n\nIn 1995, the ISO published an extension, called Amendment 1, for the ANSI-C standard. Its full name finally was ISO/IEC 9899/AMD1:1995 or nicknamed C95. Aside from error correction there were further changes to the language capabilities, such as:\n\n* Improved multi-byte and wide character support in the standard library, introducing  and  as well as multi-byte I/O\n* Addition of digraphs to the language\n* Specification of standard macros for the alternative specification of operators, e.g. and for &&\n* Specification of the standard macro __STDC_VERSION__\n\nIn addition to the amendment, two technical corrigenda were published by ISO for C90:\n\n* ISO/IEC 9899 TCOR1 in 1995\n* ISO/IEC 9899 TCOR2 in 1996\n\nPreprocessor test for C95 compatibility\n\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199409L\n\n/* C95 compatible source code. */\n#elif defined(__ANSI__)\n/* C89 compatible source code. */\n#endif\n\nC99\n\nIn March 2000, ANSI adopted the ISO/IEC 9899:1999 standard. This standard is commonly referred to as C99. Some notable additions to the previous standard include:\n\n* New built-in data types: long long, _Bool, _Complex, and _Imaginary\n* Several new core language features, including static array indices, designated initializers, compound literals, variable-length arrays, flexible array members, variadic macros, and restrict keyword\n* Several new library headers, including stdint.h, , fenv.h, \n* Improved compatibility with several C++ features, including inline functions, single-line comments with //, mixing declarations and code, and universal character names in identifiers\n* Removed several dangerous C89 language features such as implicit function declarations and implicit int\n\nThree technical corrigenda were published by ISO for C99:\n\n* ISO/IEC 9899:1999/Cor.1:2001(E)\n* ISO/IEC 9899:1999/Cor.2:2004(E)\n* ISO/IEC 9899:1999/Cor.3:2007(E), notable for deprecating the standard library function gets\n\nThis standard has been withdrawn by both ANSI/INCITS and ISO/IEC in favour of C11.\n\nC11\n\n\"C11\" is the current standard for the C programming language. Notable features introduced over the previous revision include improved Unicode support, type-generic expressions using the new _Generic keyword, a cross-platform multi-threading API (threads.h) and atomic types support in both core language and the library (stdatomic.h).\n\nOne technical corrigendum has been published by ISO for C11:\n\n* ISO/IEC 9899:2011/Cor 1:2012\n\nOther related ISO publications\n\nAs part of the standardization process, ISO also publishes technical reports and specifications related to the C language:\n\n* ISO/IEC TR 19769:2004, on library extensions to support Unicode transformation formats, integrated into C11\n* ISO/IEC TR 24731-1:2007, on library extensions to support bounds-checked interfaces, integrated into C11\n* ISO/IEC TR 18037:2008, on embedded C extensions\n* ISO/IEC TR 24732:2009, on decimal floating point arithmetic, superseded by ISO/IEC TS 18661-2:2015\n* ISO/IEC TR 24747:2009, on special mathematical functions,\n* ISO/IEC TR 24731-2:2010, on library extensions to support dynamic allocation functions\n* ISO/IEC TS 17961:2013, on secure coding in C\n* ISO/IEC TS 18661-1:2014, on IEC 60559:2011-compatible binary floating-point arithmetic\n* ISO/IEC TS 18661-2:2015, on IEC 60559:2011-compatible decimal floating point arithmetic\n* ISO/IEC TS 18661-3:2015, on IEC 60559:2011-compatible interchange and extended floating-point types\n* ISO/IEC TS 18661-4:2015, on IEC 60559:2011-compatible supplementary functions\nMore technical specifications are in development and pending approval, including the fifth and final part of TS 18661, a software transactional memory specification, and parallel library extensions.See a list at http://en.cppreference.com/w/c/experimental Visited 16 January 2016.\n\nSupport from major compilers\n\nANSI C is now supported by almost all the widely used compilers. Most of the C code being written nowadays is based on ANSI C. Any program written only in standard C and without any hardware dependent assumptions is virtually guaranteed to compile correctly on any platform with a conforming C implementation.  Without such precautions, most programs may compile only on a certain platform or with a particular compiler, due, for example, to the use of non-standard libraries, such as GUI libraries, or to the reliance on compiler- or platform-specific attributes such as the exact size of certain data types and byte endianness.\n\nCompliance detectability\n\nTo mitigate the differences between K&R C and the ANSI C standard, the __STDC__ (\"standard c\") macro can be used to split code into ANSI and K&R sections.\n\n #if defined(__STDC__) && __STDC__\n extern int getopt(int, char * const *, const char *);\n #else\n extern int getopt();\n #endif\n\nIn the above example, a prototype is used in a function declaration for ANSI compliant implementations, while an obsolescent non-prototype declaration is used otherwise. Those are still ANSI-compliant as of C99. Note how this code checks both definition and evaluation: this is because some implementations may set __STDC__ to zero to indicate non-ANSI compliance.\n\nCompilers supporting ANSI C\n\n* Amsterdam Compiler Kit (C K&R and C89/90)\n* ARM RealView\n* Clang, using LLVM backend\n* GCC (full C89/90, C99 and C11)\n* HP C/ANSI C compiler (C89 and C99)\n* IBM XL C/C++ (C11, starting with version 12.1)[http://www.ibm.com/developerworks/rational/library/support-iso-c11/index.html Support for ISO C11 added to IBM XL C/C++ compilers]\n* Intel's ICC\n* LabWindows/CVI\n* LCC\n* OpenWatcom (C89/90 and some C99)\n* Microsoft Visual C++ (C89/90 and some C99)\n* Pelles C (C99 and C11. Windows only.)\n* vbcc (C89/90 and C99)\n* Tiny C Compiler (C89/90 and some C99). ANSI C. http://en.wikipedia.org/?curid=3172."
  }
}
