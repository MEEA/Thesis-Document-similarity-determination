{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=2049",
  "eid" : "bd6daa50-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778397557,
  "textBody" : "In computer graphics, alpha compositing is the process of combining an image with a background to create the appearance of partial or full transparency. It is often useful to render image elements in separate passes, and then combine the resulting multiple 2D images into a single, final image called the composite. For example, compositing is used extensively when combining computer-rendered image elements with live footage.\n\nIn order to combine these image elements correctly, it is necessary to keep an associated matte for each element. This matte contains the coverage information—the shape of the geometry being drawn—making it possible to distinguish between parts of the image where the geometry was actually drawn and other parts of the image that are empty.\n\nDescription\n\nTo store matte information, the concept of an alpha channel was introduced by Alvy Ray Smith in the late 1970s, and fully developed in a 1984 paper by Thomas Porter and Tom Duff. In a 2D image element, which stores a color for each pixel, additional data is stored in the alpha channel with a value between 0 and 1. A value of 0 means that the pixel does not have any coverage information and is transparent; i.e. there was no color contribution from any geometry because the geometry did not overlap this pixel. A value of 1 means that the pixel is opaque because the geometry completely overlapped the pixel.\n\nIf an alpha channel is used in an image, there are two common representations that are available: straight (unassociated) alpha, and premultiplied (associated) alpha.\n\nWith straight alpha, the RGB components represent the color of the object or pixel, disregarding its opacity.\n\nWith premultiplied alpha, the RGB components represent the color of the object or pixel, adjusted for its opacity by multiplication. A more obvious advantage of this is that, in certain situations, it can save a subsequent multiplication (e.g. if the image is used many times during later compositing). However, the most significant advantages of using premultiplied alpha are for correctness and simplicity rather than performance: premultiplied alpha allows correct filtering and blending. In addition, premultiplied alpha allows regions of regular alpha blending and regions with additive blending mode to be encoded within the same image.https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BPremultiplied%20alpha%5D%5D\n\nAssuming that the pixel color is expressed using straight (non-premultiplied) RGBA tuples, a pixel value of (0, 0.7, 0, 0.5) implies a pixel that has 70% of the maximum green intensity and 50% opacity. If the color were fully green, its RGBA would be (0, 1, 0, 0.5).\n\nHowever, if this pixel uses premultiplied alpha, all of the RGB values (0, 0.7, 0) are multiplied by 0.5 and then the alpha is appended to the end to yield (0, 0.35, 0, 0.5). In this case, the 0.35 value for the G channel actually indicates 70% green intensity (with 50% opacity). Fully green would be encoded as (0, 0.5, 0, 0.5). For this reason, knowing whether a file uses straight or premultiplied alpha is essential to correctly process or composite it.\n\nIt is often said that associativity is an advantage of premultiplied alpha blending over straight alpha blending, but both are associative. The only important difference is in the dynamic range of the colour representation in finite precision numerical calculations (which is in all applications): premultiplied alpha has a unique representation for transparent pixels, avoiding the need to choose a \"clear color\" or resultant artefacts such as edge fringes (see the next paragraphs). In other words, color information of transparent pixels is lost in premultiplied alpha, as the conversion from premultiplied alpha to straight alpha is undefined for alpha equal to zero.\nPremultiplied alpha has some practical advantages over normal alpha blending because interpolation and filtering give correct results.\n\nOrdinary interpolation without premultiplied alpha leads to RGB information leaking out of fully transparent (A=0) regions, even though this RGB information is ideally invisible. When interpolating or filtering images with abrupt borders between transparent and opaque regions, this can result in borders of colors that were not visible in the original image. Errors also occur in areas of semitransparancy\nbecause the RGB components are not correctly weighted, giving incorrectly high weighting to the color of the more transparent (lower alpha) pixels.\n\nPremultiplication can reduce the available relative precision in the RGB values when using integer or fixed-point representation for the color components, which may cause a noticeable loss of quality if the color information is later brightened or if the alpha channel is removed. In practice, this is not usually noticeable because during typical composition operations, such as OVER, the influence of the low-precision colour information in low-alpha areas on the final output image (after composition) is correspondingly reduced. This loss of precision also makes premultiplied images easier to compress using certain compression schemes, as they do not record the color variations hidden inside transparent regions, and can allocate fewer bits to encode low-alpha areas.\n\nWith the existence of an alpha channel, it is possible to express compositing image operations using a compositing algebra. For example, given two image elements A and B, the most common compositing operation is to combine the images such that A appears in the foreground and B appears in the background. This can be expressed as A over B. In addition to over, Porter and Duff defined the compositing operators in, held out by (usually abbreviated out), atop, and xor (and the reverse operators rover, rin, rout, and ratop) from a consideration of choices in blending the colors of two pixels when their coverage is, conceptually, overlaid orthogonally:\n\nThe over operator is, in effect, the normal painting operation (see Painter's algorithm). The in operator is the alpha compositing equivalent of clipping.\n\nAs an example, the over operator can be accomplished by applying the following formula to each pixel value:\n\nC_o = \\frac{C_a \\alpha_a + C_b \\alpha_b \\left(1 - \\alpha_a\\right)}{\\alpha_a + \\alpha_b \\left(1 - \\alpha_a\\right)}\n\nwhere C_o is the result of the operation, C_a is the color of the pixel in element A, C_b is the color of the pixel in element B, and \\alpha_a and \\alpha_b are the alpha of the pixels in elements A and B respectively.  If it is assumed that all color values are premultiplied by their alpha values (c_i = \\alpha_i C_i), we can rewrite the equation for output color as:\n\nc_o = c_a + c_b \\left(1 - \\alpha_a\\right)\nand resulting alpha channel value is\n\\alpha_o \\frac{c_o}{C_o} \n \\alpha_a + \\alpha_b \\left(1 - \\alpha_a\\right)\nExamples \n\nExamples of red overlaid with green with both colours fully opaque:\n\nPorterDuffAdd.png|ADD operation\nPorterDuffClear.png|CLEAR operation\nPorterDuffMultiply.png|MULTIPLY operation\nPorterDuffOverlay.png|OVERLAY operation\n\nAnalytical derivation of the over operator\n\nPorter and Duff gave a geometric interpretation of the alpha compositing formula by studying orthogonal coverages. Another derivation of the formula, based on a physical reflectance/transmittance model, can be found in a 1981 paper by Bruce A. Wallace.\n\nA third approach is found by starting out with two very simple assumptions. For simplicity, we shall here use the shorthand notation a \\odot b for representing the over operator.\n\nThe first assumption is that in the case where the background is opaque (i.e. \\alpha_b = 1), the over operator represents the convex combination of a and b:\n\nC_o = \\alpha_a C_a + (1 - \\alpha_a) C_b\n\nThe second assumption is that the operator must respect the associative rule:\n\n(a \\odot b) \\odot c = a \\odot (b \\odot c)\n\nNow, let us assume that a and b have variable transparencies, whereas c is opaque. We're interested in finding\n\no = a \\odot b.\n\nWe know from the associative rule that the following must be true:\n\no \\odot c = a \\odot (b \\odot c)\n\nWe know that c is opaque and thus follows that b \\odot c is opaque, so in the above equation, each \\odot operator can be written as a convex combination:\n\n\\begin{align}\n  \\alpha_o C_o + (1 - \\alpha_o) C_c &= \\alpha_a C_a + (1 - \\alpha_a) (\\alpha_b C_b + (1 - \\alpha_b) C_c) \\\\\n  &= \\alpha_a C_a + (1 - \\alpha_a) \\alpha_b C_b + (1 - \\alpha_a) (1 - \\alpha_b) C_c\n\\end{align}\n\nHence we see that this represents an equation of the form X_0 + Y_0 C_c X_1 + Y_1 C_c. By setting X_0 \n X_1 and Y_0 = Y_1 we get\n\n\\begin{align}\n  \\alpha_o &= 1 - (1 - \\alpha_a) (1 - \\alpha_b),\\\\\n  C_o &= \\frac{\\alpha_a C_a + (1 - \\alpha_a)\\alpha_b C_b}{\\alpha_o},\n\\end{align}\n\nwhich means that we have analytically derived a formula for the output alpha and the output color of a \\odot b.\n\nAn even more compact representation is given by noticing that (1 - \\alpha_a)\\alpha_b = \\alpha_o - \\alpha_a:\n\n  C_o = \\frac{\\alpha_a}{\\alpha_o} C_a + \\left(1 - \\frac{\\alpha_a}{\\alpha_o}\\right) C_b\n\nIt is also interesting to note that the \\odot operator fulfills all the requirements of a non-commutative monoid, where the identity element e is chosen such that e \\odot a a \\odot e \n a (i.e. the identity element can be any tuple \\langle C,\\alpha\\rangle with \\alpha = 0.)\n\nAlpha blending\n\nAlpha blending is the process of combining a translucent foreground color with a background color, thereby producing a new blended color. The degree of the foreground color's translucency may range from completely transparent to completely opaque. If the foreground color is completely transparent, the blended color will be the background color. Conversely, if it is completely opaque, the blended color will be the foreground color. The translucency can range between these extremes, in which case the blended color is computed as a weighted average of the foreground and background colors.\n\nAlpha blending is a convex combination of two colors allowing for transparency effects in computer graphics. The value of alpha in the color code ranges from 0.0 to 1.0, where 0.0 represents a fully transparent color, and 1.0 represents a fully opaque color. This alpha value also corresponds to the ratio of \"SRC over DST\" in Porter and Duff equations.\n\nThe value of the resulting color is given by:\n\n\\begin{cases}\n\\mathrm{out}_A = \\mathrm{src}_A + \\mathrm{dst}_A (1 - \\mathrm{src}_A) \\\\\n\\mathrm{out}_{RGB} = \\bigl( \\mathrm{src}_{RGB} \\mathrm{src}_A + \\mathrm{dst}_{RGB} \\mathrm{dst}_A \\left( 1 - \\mathrm{src}_A \\right) \\bigr) \\div \\mathrm{out}_A \\\\\n\\mathrm{out}_A 0 \\Rightarrow \\mathrm{out}_{RGB} \n 0\n\\end{cases}\n\nIf the destination background is opaque, then dst_A = 1, and if you enter it to the upper equation:\n\n\\begin{cases}\n\\mathrm{out}_A = 1 \\\\\n\\mathrm{out}_{RGB} = \\mathrm{src}_{RGB} \\mathrm{src}_A + \\mathrm{dst}_{RGB} (1 - \\mathrm{src}_A)\n\\end{cases}\n\nThe alpha component may be used to blend to red, green and blue components equally, as in 32-bit RGBA, or, alternatively, there may be three alpha values specified corresponding to each of the primary colors for spectral color filtering.\n\nIf premultiplied alpha is used, the above equations are simplified to:\n\n\\begin{cases}\n\\mathrm{out}_A = \\mathrm{src}_A + \\mathrm{dst}_A (1 - \\mathrm{src}_A) \\\\\n\\mathrm{out}_{RGB} = \\mathrm{src}_{RGB} + \\mathrm{dst}_{RGB} \\left( 1 - \\mathrm{src}_A \\right)\n\\end{cases}\n\nOther transparency methods\n\nAlthough used for similar purposes, transparent colors and image masks do not permit the smooth blending of the superimposed image pixels with those of the background (only whole image pixels or whole background pixels allowed).\n\nA similar effect can be achieved with a 1-bit alpha channel, as found in the 16-bit RGBA Highcolor mode of the Truevision TGA image file format and related TARGA and AT-Vista/NU-Vista display adapters' Highcolor graphic mode. This mode devotes 5 bits for every primary RGB color (15-bit RGB) plus a remaining bit as the \"alpha channel\".",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Alpha compositing" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=2049" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In computer graphics, alpha compositing is the process of combining an image with a background to create the appearance of partial or full transparency. It is often useful to render image elements in separate passes, and then combine the resulting multiple 2D images into a single, final image called the composite. For example, compositing is used extensively when combining computer-rendered image elements with live footage.\n\nIn order to combine these image elements correctly, it is necessary to keep an associated matte for each element. This matte contains the coverage information—the shape of the geometry being drawn—making it possible to distinguish between parts of the image where the geometry was actually drawn and other parts of the image that are empty.\n\nDescription\n\nTo store matte information, the concept of an alpha channel was introduced by Alvy Ray Smith in the late 1970s, and fully developed in a 1984 paper by Thomas Porter and Tom Duff. In a 2D image element, which stores a color for each pixel, additional data is stored in the alpha channel with a value between 0 and 1. A value of 0 means that the pixel does not have any coverage information and is transparent; i.e. there was no color contribution from any geometry because the geometry did not overlap this pixel. A value of 1 means that the pixel is opaque because the geometry completely overlapped the pixel.\n\nIf an alpha channel is used in an image, there are two common representations that are available: straight (unassociated) alpha, and premultiplied (associated) alpha.\n\nWith straight alpha, the RGB components represent the color of the object or pixel, disregarding its opacity.\n\nWith premultiplied alpha, the RGB components represent the color of the object or pixel, adjusted for its opacity by multiplication. A more obvious advantage of this is that, in certain situations, it can save a subsequent multiplication (e.g. if the image is used many times during later compositing). However, the most significant advantages of using premultiplied alpha are for correctness and simplicity rather than performance: premultiplied alpha allows correct filtering and blending. In addition, premultiplied alpha allows regions of regular alpha blending and regions with additive blending mode to be encoded within the same image.https://tomforsyth1000.github.io/blog.wiki.html#%5B%5BPremultiplied%20alpha%5D%5D\n\nAssuming that the pixel color is expressed using straight (non-premultiplied) RGBA tuples, a pixel value of (0, 0.7, 0, 0.5) implies a pixel that has 70% of the maximum green intensity and 50% opacity. If the color were fully green, its RGBA would be (0, 1, 0, 0.5).\n\nHowever, if this pixel uses premultiplied alpha, all of the RGB values (0, 0.7, 0) are multiplied by 0.5 and then the alpha is appended to the end to yield (0, 0.35, 0, 0.5). In this case, the 0.35 value for the G channel actually indicates 70% green intensity (with 50% opacity). Fully green would be encoded as (0, 0.5, 0, 0.5). For this reason, knowing whether a file uses straight or premultiplied alpha is essential to correctly process or composite it.\n\nIt is often said that associativity is an advantage of premultiplied alpha blending over straight alpha blending, but both are associative. The only important difference is in the dynamic range of the colour representation in finite precision numerical calculations (which is in all applications): premultiplied alpha has a unique representation for transparent pixels, avoiding the need to choose a \"clear color\" or resultant artefacts such as edge fringes (see the next paragraphs). In other words, color information of transparent pixels is lost in premultiplied alpha, as the conversion from premultiplied alpha to straight alpha is undefined for alpha equal to zero.\nPremultiplied alpha has some practical advantages over normal alpha blending because interpolation and filtering give correct results.\n\nOrdinary interpolation without premultiplied alpha leads to RGB information leaking out of fully transparent (A=0) regions, even though this RGB information is ideally invisible. When interpolating or filtering images with abrupt borders between transparent and opaque regions, this can result in borders of colors that were not visible in the original image. Errors also occur in areas of semitransparancy\nbecause the RGB components are not correctly weighted, giving incorrectly high weighting to the color of the more transparent (lower alpha) pixels.\n\nPremultiplication can reduce the available relative precision in the RGB values when using integer or fixed-point representation for the color components, which may cause a noticeable loss of quality if the color information is later brightened or if the alpha channel is removed. In practice, this is not usually noticeable because during typical composition operations, such as OVER, the influence of the low-precision colour information in low-alpha areas on the final output image (after composition) is correspondingly reduced. This loss of precision also makes premultiplied images easier to compress using certain compression schemes, as they do not record the color variations hidden inside transparent regions, and can allocate fewer bits to encode low-alpha areas.\n\nWith the existence of an alpha channel, it is possible to express compositing image operations using a compositing algebra. For example, given two image elements A and B, the most common compositing operation is to combine the images such that A appears in the foreground and B appears in the background. This can be expressed as A over B. In addition to over, Porter and Duff defined the compositing operators in, held out by (usually abbreviated out), atop, and xor (and the reverse operators rover, rin, rout, and ratop) from a consideration of choices in blending the colors of two pixels when their coverage is, conceptually, overlaid orthogonally:\n\nThe over operator is, in effect, the normal painting operation (see Painter's algorithm). The in operator is the alpha compositing equivalent of clipping.\n\nAs an example, the over operator can be accomplished by applying the following formula to each pixel value:\n\nC_o = \\frac{C_a \\alpha_a + C_b \\alpha_b \\left(1 - \\alpha_a\\right)}{\\alpha_a + \\alpha_b \\left(1 - \\alpha_a\\right)}\n\nwhere C_o is the result of the operation, C_a is the color of the pixel in element A, C_b is the color of the pixel in element B, and \\alpha_a and \\alpha_b are the alpha of the pixels in elements A and B respectively.  If it is assumed that all color values are premultiplied by their alpha values (c_i = \\alpha_i C_i), we can rewrite the equation for output color as:\n\nc_o = c_a + c_b \\left(1 - \\alpha_a\\right)\nand resulting alpha channel value is\n\\alpha_o \\frac{c_o}{C_o} \n \\alpha_a + \\alpha_b \\left(1 - \\alpha_a\\right)\nExamples \n\nExamples of red overlaid with green with both colours fully opaque:\n\nPorterDuffAdd.png|ADD operation\nPorterDuffClear.png|CLEAR operation\nPorterDuffMultiply.png|MULTIPLY operation\nPorterDuffOverlay.png|OVERLAY operation\n\nAnalytical derivation of the over operator\n\nPorter and Duff gave a geometric interpretation of the alpha compositing formula by studying orthogonal coverages. Another derivation of the formula, based on a physical reflectance/transmittance model, can be found in a 1981 paper by Bruce A. Wallace.\n\nA third approach is found by starting out with two very simple assumptions. For simplicity, we shall here use the shorthand notation a \\odot b for representing the over operator.\n\nThe first assumption is that in the case where the background is opaque (i.e. \\alpha_b = 1), the over operator represents the convex combination of a and b:\n\nC_o = \\alpha_a C_a + (1 - \\alpha_a) C_b\n\nThe second assumption is that the operator must respect the associative rule:\n\n(a \\odot b) \\odot c = a \\odot (b \\odot c)\n\nNow, let us assume that a and b have variable transparencies, whereas c is opaque. We're interested in finding\n\no = a \\odot b.\n\nWe know from the associative rule that the following must be true:\n\no \\odot c = a \\odot (b \\odot c)\n\nWe know that c is opaque and thus follows that b \\odot c is opaque, so in the above equation, each \\odot operator can be written as a convex combination:\n\n\\begin{align}\n  \\alpha_o C_o + (1 - \\alpha_o) C_c &= \\alpha_a C_a + (1 - \\alpha_a) (\\alpha_b C_b + (1 - \\alpha_b) C_c) \\\\\n  &= \\alpha_a C_a + (1 - \\alpha_a) \\alpha_b C_b + (1 - \\alpha_a) (1 - \\alpha_b) C_c\n\\end{align}\n\nHence we see that this represents an equation of the form X_0 + Y_0 C_c X_1 + Y_1 C_c. By setting X_0 \n X_1 and Y_0 = Y_1 we get\n\n\\begin{align}\n  \\alpha_o &= 1 - (1 - \\alpha_a) (1 - \\alpha_b),\\\\\n  C_o &= \\frac{\\alpha_a C_a + (1 - \\alpha_a)\\alpha_b C_b}{\\alpha_o},\n\\end{align}\n\nwhich means that we have analytically derived a formula for the output alpha and the output color of a \\odot b.\n\nAn even more compact representation is given by noticing that (1 - \\alpha_a)\\alpha_b = \\alpha_o - \\alpha_a:\n\n  C_o = \\frac{\\alpha_a}{\\alpha_o} C_a + \\left(1 - \\frac{\\alpha_a}{\\alpha_o}\\right) C_b\n\nIt is also interesting to note that the \\odot operator fulfills all the requirements of a non-commutative monoid, where the identity element e is chosen such that e \\odot a a \\odot e \n a (i.e. the identity element can be any tuple \\langle C,\\alpha\\rangle with \\alpha = 0.)\n\nAlpha blending\n\nAlpha blending is the process of combining a translucent foreground color with a background color, thereby producing a new blended color. The degree of the foreground color's translucency may range from completely transparent to completely opaque. If the foreground color is completely transparent, the blended color will be the background color. Conversely, if it is completely opaque, the blended color will be the foreground color. The translucency can range between these extremes, in which case the blended color is computed as a weighted average of the foreground and background colors.\n\nAlpha blending is a convex combination of two colors allowing for transparency effects in computer graphics. The value of alpha in the color code ranges from 0.0 to 1.0, where 0.0 represents a fully transparent color, and 1.0 represents a fully opaque color. This alpha value also corresponds to the ratio of \"SRC over DST\" in Porter and Duff equations.\n\nThe value of the resulting color is given by:\n\n\\begin{cases}\n\\mathrm{out}_A = \\mathrm{src}_A + \\mathrm{dst}_A (1 - \\mathrm{src}_A) \\\\\n\\mathrm{out}_{RGB} = \\bigl( \\mathrm{src}_{RGB} \\mathrm{src}_A + \\mathrm{dst}_{RGB} \\mathrm{dst}_A \\left( 1 - \\mathrm{src}_A \\right) \\bigr) \\div \\mathrm{out}_A \\\\\n\\mathrm{out}_A 0 \\Rightarrow \\mathrm{out}_{RGB} \n 0\n\\end{cases}\n\nIf the destination background is opaque, then dst_A = 1, and if you enter it to the upper equation:\n\n\\begin{cases}\n\\mathrm{out}_A = 1 \\\\\n\\mathrm{out}_{RGB} = \\mathrm{src}_{RGB} \\mathrm{src}_A + \\mathrm{dst}_{RGB} (1 - \\mathrm{src}_A)\n\\end{cases}\n\nThe alpha component may be used to blend to red, green and blue components equally, as in 32-bit RGBA, or, alternatively, there may be three alpha values specified corresponding to each of the primary colors for spectral color filtering.\n\nIf premultiplied alpha is used, the above equations are simplified to:\n\n\\begin{cases}\n\\mathrm{out}_A = \\mathrm{src}_A + \\mathrm{dst}_A (1 - \\mathrm{src}_A) \\\\\n\\mathrm{out}_{RGB} = \\mathrm{src}_{RGB} + \\mathrm{dst}_{RGB} \\left( 1 - \\mathrm{src}_A \\right)\n\\end{cases}\n\nOther transparency methods\n\nAlthough used for similar purposes, transparent colors and image masks do not permit the smooth blending of the superimposed image pixels with those of the background (only whole image pixels or whole background pixels allowed).\n\nA similar effect can be achieved with a 1-bit alpha channel, as found in the 16-bit RGBA Highcolor mode of the Truevision TGA image file format and related TARGA and AT-Vista/NU-Vista display adapters' Highcolor graphic mode. This mode devotes 5 bits for every primary RGB color (15-bit RGB) plus a remaining bit as the \"alpha channel\". Alpha compositing. http://en.wikipedia.org/?curid=2049."
  }
}
