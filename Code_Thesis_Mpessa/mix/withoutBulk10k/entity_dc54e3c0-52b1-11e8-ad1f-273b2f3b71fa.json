{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=6604",
  "eid" : "dc54e3c0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778449404,
  "textBody" : "Rendering or image synthesis is the automatic process of generating a photorealistic or non-photorealistic image from a 2D or 3D model (or models in what collectively could be called a scene file) by means of computer programs. Also, the results of displaying such a model can be called a render. A scene file contains objects in a strictly defined language or data structure; it would contain geometry, viewpoint, texture, lighting, and shading information as a description of the virtual scene. The data contained in the scene file is then passed to a rendering program to be processed and output to a digital image or raster graphics image file. The term \"rendering\" may be by analogy with an \"artist's rendering\" of a scene.\n\nThough the technical details of rendering methods vary, the general challenges to overcome in producing a 2D image from a 3D representation stored in a scene file are outlined as the graphics pipeline along a rendering device, such as a GPU. A GPU is a purpose-built device able to assist a CPU in performing complex rendering calculations. If a scene is to look relatively realistic and predictable under virtual lighting, the rendering software should solve the rendering equation. The rendering equation doesn't account for all lighting phenomena, but is a general lighting model for computer-generated imagery. 'Rendering' is also used to describe the process of calculating effects in a video editing program to produce final video output.\n\nRendering is one of the major sub-topics of 3D computer graphics, and in practice is always connected to the others. In the graphics pipeline, it is the last major step, giving the final appearance to the models and animation. With the increasing sophistication of computer graphics since the 1970s, it has become a more distinct subject.\n\nRendering has uses in architecture, video games, simulators, movie or TV visual effects, and design visualization, each employing a different balance of features and techniques. As a product, a wide variety of renderers are available. Some are integrated into larger modeling and animation packages, some are stand-alone, some are free open-source projects. On the inside, a renderer is a carefully engineered program, based on a selective mixture of disciplines related to: light physics, visual perception, mathematics, and software development.\n\nIn the case of 3D graphics, rendering may be done slowly, as in pre-rendering, or in realtime.  Pre-rendering is a computationally intensive process that is typically used for movie creation, while real-time rendering is often done for 3D video games which rely on the use of graphics cards with 3D hardware accelerators.\n\nUsage \n\nWhen the pre-image (a wireframe sketch usually) is complete, rendering is used, which adds in bitmap textures or procedural textures, lights, bump mapping and relative position to other objects. The result is a completed image the consumer or intended viewer sees.\n\nFor movie animations, several images (frames) must be rendered, and stitched together in a program capable of making an animation of this sort. Most 3D image editing programs can do this.\n\nFeatures \n\nA rendered image can be understood in terms of a number of visible features. Rendering research and development has been largely motivated by finding ways to simulate these efficiently. Some relate directly to particular algorithms and techniques, while others are produced together.\n\n* Shading how the color and brightness of a surface varies with lighting\n* Texture-mapping a method of applying detail to surfaces\n* Bump-mapping a method of simulating small-scale bumpiness on surfaces\n* Fogging/participating medium how light dims when passing through non-clear atmosphere or air\n* Shadows the effect of obstructing light\n* Soft shadows varying darkness caused by partially obscured light sources\n* Reflection mirror-like or highly glossy reflection\n* Transparency (optics), transparency (graphic) or opacity sharp transmission of light through solid objects\n* Translucency highly scattered transmission of light through solid objects\n* Refraction bending of light associated with transparency\n* Diffraction bending, spreading, and interference of light passing by an object or aperture that disrupts the ray\n* Indirect illumination surfaces illuminated by light reflected off other surfaces, rather than directly from a light source (also known as global illumination)\n* Caustics (a form of indirect illumination) reflection of light off a shiny object, or focusing of light through a transparent object, to produce bright highlights on another object\n* Depth of field objects appear blurry or out of focus when too far in front of or behind the object in focus\n* Motion blur objects appear blurry due to high-speed motion, or the motion of the camera\n* Non-photorealistic rendering rendering of scenes in an artistic style, intended to look like a painting or drawing\n\nTechniques \n\nMany rendering  have been researched, and software used for rendering may employ a number of different techniques to obtain a final image.\n\nTracing every particle of light in a scene is nearly always completely impractical and would take a stupendous amount of time. Even tracing a portion large enough to produce an image takes an inordinate amount of time if the sampling is not intelligently restricted.\n\nTherefore, a few loose families of more-efficient light transport modelling techniques have emerged:\n* rasterization, including scanline rendering, geometrically projects objects in the scene to an image plane, without advanced optical effects;\n* ray casting considers the scene as observed from a specific point of view, calculating the observed image based only on geometry and very basic optical laws of reflection intensity, and perhaps using Monte Carlo techniques to reduce artifacts;\n* ray tracing is similar to ray casting, but employs more advanced optical simulation, and usually uses Monte Carlo techniques to obtain more realistic results at a speed that is often orders of magnitude faster.\nThe fourth type of light transport technique, radiosity is not usually implemented as a rendering technique, but instead calculates the passage of light as it leaves the light source and illuminates surfaces. These surfaces are usually rendered to the display using one of the other three techniques.\n\nMost advanced software combines two or more of the techniques to obtain good-enough results at reasonable cost.\n\nAnother distinction is between image order algorithms, which iterate over pixels of the image plane, and object order algorithms, which iterate over objects in the scene. Generally object order is more efficient, as there are usually fewer objects in a scene than pixels.\n\nScanline rendering and rasterisation \n\nA high-level representation of an image necessarily contains elements in a different domain from pixels.  These elements are referred to as s.  In a schematic drawing, for instance, line segments and curves might be primitives.  In a graphical user interface, windows and buttons might be the primitives.  In rendering of 3D models, triangles and polygons in space might be primitives.\n\nIf a pixel-by-pixel (image order) approach to rendering is impractical or too slow for some task, then a primitive-by-primitive (object order) approach to rendering may prove useful.  Here, one loops through each of the primitives, determines which pixels in the image it affects, and modifies those pixels accordingly.  This is called rasterization, and is the rendering method used by all current graphics cards.\n\nRasterization is frequently faster than pixel-by-pixel rendering.  First, large areas of the image may be empty of primitives; rasterization will ignore these areas, but pixel-by-pixel rendering must pass through them.  Second, rasterization can improve cache coherency and reduce redundant work by taking advantage of the fact that the pixels occupied by a single primitive tend to be contiguous in the image.  For these reasons, rasterization is usually the approach of choice when interactive rendering is required; however, the pixel-by-pixel approach can often produce higher-quality images and is more versatile because it does not depend on as many assumptions about the image as rasterization.\n\nThe older form of rasterization is characterized by rendering an entire face (primitive) as a single color.  Alternatively, rasterization can be done in a more complicated manner by first rendering the vertices of a face and then rendering the pixels of that face as a blending of the vertex colors.  This version of rasterization has overtaken the old method as it allows the graphics to flow without complicated textures (a rasterized image when used face by face tends to have a very block-like effect if not covered in complex textures; the faces are not smooth because there is no gradual color change from one primitive to the next).  This newer method of rasterization utilizes the graphics card's more taxing shading functions and still achieves better performance because the simpler textures stored in memory use less space. Sometimes designers will use one rasterization method on some faces and the other method on others based on the angle at which that face meets other joined faces, thus increasing speed and not hurting the overall effect.\n\nRay casting \n\nIn ray casting the geometry which has been modeled is parsed pixel by pixel, line by line, from the point of view outward, as if casting rays out from the point of view. Where an object is intersected, the color value at the point may be evaluated using several methods. In the simplest, the color value of the object at the point of intersection becomes the value of that pixel. The color may be determined from a texture-map. A more sophisticated method is to modify the colour value by an illumination factor, but without calculating the relationship to a simulated light source. To reduce artifacts, a number of rays in slightly different directions may be averaged.\n\nRough simulations of optical properties may be additionally employed: a simple calculation of the ray from the object to the point of view is made. Another calculation is made of the angle of incidence of light rays from the light source(s), and from these as well as the specified intensities of the light sources, the value of the pixel is calculated. Another simulation uses illumination plotted from a radiosity algorithm, or a combination of these two.\n\nRaycasting is primarily used for realtime simulations, such as those used in 3D computer games and cartoon animations, where detail is not important, or where it is more efficient to manually fake the details in order to obtain better performance in the computational stage. This is usually the case when a large number of frames need to be animated. The resulting surfaces have a characteristic 'flat' appearance when no additional tricks are used, as if objects in the scene were all painted with matte finish.\n\nRay tracing \n\nRay tracing aims to simulate the natural flow of light, interpreted as particles. Often, ray tracing methods are utilized to approximate the solution to the rendering equation by applying Monte Carlo methods to it. Some of the most used methods are path tracing, bidirectional path tracing, or Metropolis light transport, but also semi realistic methods are in use, like Whitted Style Ray Tracing, or hybrids. While most implementations let light propagate on straight lines, applications exist to simulate relativistic spacetime effects.\n\nIn a final, production quality rendering of a ray traced work, multiple rays are generally shot for each pixel, and traced not just to the first object of intersection, but rather, through a number of sequential 'bounces', using the known laws of optics such as \"angle of incidence equals angle of reflection\" and more advanced laws that deal with refraction and surface roughness.\n\nOnce the ray either encounters a light source, or more probably once a set limiting number of bounces has been evaluated, then the surface illumination at that final point is evaluated using techniques described above, and the changes along the way through the various bounces evaluated to estimate a value observed at the point of view. This is all repeated for each sample, for each pixel.\n\nIn distribution ray tracing, at each point of intersection, multiple rays may be spawned. In path tracing, however, only a single ray or none is fired at each intersection, utilizing the statistical nature of Monte Carlo experiments.\n\nAs a brute-force method, ray tracing has been too slow to consider for real-time, and until recently too slow even to consider for short films of any degree of quality, although it has been used for special effects sequences, and in advertising, where a short portion of high quality (perhaps even photorealistic) footage is required.\n\nHowever, efforts at optimizing to reduce the number of calculations needed in portions of a work where detail is not high or does not depend on ray tracing features have led to a realistic possibility of wider use of ray tracing. There is now some hardware accelerated ray tracing equipment, at least in prototype phase, and some game demos which show use of real-time software or hardware ray tracing.\n\nRadiosity \n\nRadiosity is a method which attempts to simulate the way in which directly illuminated surfaces act as indirect light sources that illuminate other surfaces.  This produces more realistic shading and seems to better capture the 'ambience' of an indoor scene. A classic example is the way that shadows 'hug' the corners of rooms.\n\nThe optical basis of the simulation is that some diffused light from a given point on a given surface is reflected in a large spectrum of directions and illuminates the area around it.\n\nThe simulation technique may vary in complexity. Many renderings have a very rough estimate of radiosity, simply illuminating an entire scene very slightly with a factor known as ambiance. However, when advanced radiosity estimation is coupled with a high quality ray tracing algorithm, images may exhibit convincing realism, particularly for indoor scenes.\n\nIn advanced radiosity simulation, recursive, finite-element algorithms 'bounce' light back and forth between surfaces in the model, until some recursion limit is reached. The colouring of one surface in this way influences the colouring of a neighbouring surface, and vice versa. The resulting values of illumination throughout the model (sometimes including for empty spaces) are stored and used as additional inputs when performing calculations in a ray-casting or ray-tracing model.\n\nDue to the iterative/recursive nature of the technique, complex objects are particularly slow to emulate. Prior to the standardization of rapid radiosity calculation, some digital artists used a technique referred to loosely as false radiosity by darkening areas of texture maps corresponding to corners, joints and recesses, and applying them via self-illumination or diffuse mapping for scanline rendering. Even now, advanced radiosity calculations may be reserved for calculating the ambiance of the room, from the light reflecting off walls, floor and ceiling, without examining the contribution that complex objects make to the radiosity—or complex objects may be replaced in the radiosity calculation with simpler objects of similar size and texture.\n\nRadiosity calculations are viewpoint independent which increases the computations involved, but makes them useful for all viewpoints. If there is little rearrangement of radiosity objects in the scene, the same radiosity data may be reused for a number of frames, making radiosity an effective way to improve on the flatness of ray casting, without seriously impacting the overall rendering time-per-frame.\n\nBecause of this, radiosity is a prime component of leading real-time rendering methods, and has been used from beginning-to-end to create a large number of well-known recent feature-length animated 3D-cartoon films.\n\nSampling and filtering \n\nOne problem that any rendering system must deal with, no matter which approach it takes, is the sampling problem.  Essentially, the rendering process tries to depict a continuous function from image space to colors by using a finite number of pixels.  As a consequence of the Nyquist–Shannon sampling theorem (or Kotelnikov theorem), any spatial waveform that can be displayed must consist of at least two pixels, which is proportional to image resolution.  In simpler terms, this expresses the idea that an image cannot display details, peaks or troughs in color or intensity, that are smaller than one pixel.\n\nIf a naive rendering algorithm is used without any filtering, high frequencies in the image function will cause ugly aliasing to be present in the final image.  Aliasing typically manifests itself as jaggies, or jagged edges on objects where the pixel grid is visible.  In order to remove aliasing, all rendering algorithms (if they are to produce good-looking images) must use some kind of low-pass filter on the image function to remove high frequencies, a process called antialiasing.\n\nOptimization \n\nOptimizations used by an artist when a scene is being developed \n\nDue to the large number of calculations, a work in progress is usually only rendered in detail appropriate to the portion of the work being developed at a given time, so in the initial stages of modeling, wireframe and ray casting may be used, even where the target output is ray tracing with radiosity. It is also common to render only parts of the scene at high detail, and to remove objects that are not important to what is currently being developed.\n\nCommon optimizations for real time rendering \n\nFor real-time, it is appropriate to simplify one or more common approximations, and tune to the exact parameters of the scenery in question, which is also tuned to the agreed parameters to get the most 'bang for the buck'.\n\nAcademic core \n\nThe implementation of a realistic renderer always has some basic element of physical simulation or emulation — some computation which resembles or abstracts a real physical process.\n\nThe term \"physically based\" indicates the use of physical models and approximations that are more general and widely accepted outside rendering. A particular set of related techniques have gradually become established in the rendering community.\n\nThe basic concepts are moderately straightforward, but intractable to calculate; and a single elegant algorithm or approach has been elusive for more general purpose renderers. In order to meet demands of robustness, accuracy and practicality, an implementation will be a complex combination of different techniques.\n\nRendering research is concerned with both the adaptation of scientific models and their efficient application.\n\nThe rendering equation \n\nThis is the key academic/theoretical concept in rendering. It serves as the most abstract formal expression of the non-perceptual aspect of rendering. All more complete algorithms can be seen as solutions to particular formulations of this equation.\n\nL_o(x, \\vec w) = L_e(x, \\vec w) + \\int_\\Omega f_r(x, \\vec w', \\vec w) L_i(x, \\vec w') (\\vec w' \\cdot \\vec n) \\mathrm{d}\\vec w'\nMeaning: at a particular position and direction, the outgoing light (Lo) is the sum of the emitted light (Le) and the reflected light. The reflected light being the sum of the incoming light (Li) from all directions, multiplied by the surface reflection and incoming angle. By connecting outward light to inward light, via an interaction point, this equation stands for the whole 'light transport' — all the movement of light — in a scene.\n\nThe bidirectional reflectance distribution function \n\nThe bidirectional reflectance distribution function (BRDF) expresses a simple model of light interaction with a surface as follows:\n\nf_r(x, \\vec w', \\vec w) = \\frac{\\mathrm{d}L_r(x, \\vec w)}{L_i(x, \\vec w')(\\vec w' \\cdot \\vec n) \\mathrm{d}\\vec w'}\n\nLight interaction is often approximated by the even simpler models: diffuse reflection and specular reflection, although both can ALSO be BRDFs.\n\nGeometric optics \n\nRendering is practically exclusively concerned with the particle aspect of light physics — known as geometrical optics. Treating light, at its basic level, as particles bouncing around is a simplification, but appropriate: the wave aspects of light are negligible in most scenes, and are significantly more difficult to simulate. Notable wave aspect phenomena include diffraction (as seen in the colours of CDs and DVDs) and polarisation (as seen in LCDs). Both types of effect, if needed, are made by appearance-oriented adjustment of the reflection model.\n\nVisual perception \n\nThough it receives less attention, an understanding of human visual perception is valuable to rendering. This is mainly because image displays and human perception have restricted ranges. A renderer can simulate an almost infinite range of light brightness and color, but current displays — movie screen, computer monitor, etc. — cannot handle so much, and something must be discarded or compressed. Human perception also has limits, and so does not need to be given large-range images to create realism. This can help solve the problem of fitting images into displays, and, furthermore, suggest what short-cuts could be used in the rendering simulation, since certain subtleties won't be noticeable. This related subject is tone mapping.\n\nMathematics used in rendering includes: linear algebra, calculus, numerical mathematics, signal processing, and Monte Carlo methods.\n\nRendering for movies often takes place on a network of tightly connected computers known as a render farm.\n\nThe current state of the art in 3-D image description for movie creation is the mental ray scene description language designed at mental images and RenderMan Shading Language designed at Pixar.[http://portal.acm.org/citation.cfm?id1185817&jmp\nabstract&collGUIDE&dl\nGUIDE A brief introduction to RenderMan] (compare with simpler 3D fileformats such as VRML or APIs such as OpenGL and DirectX tailored for 3D hardware accelerators).\n\nOther renderers (including proprietary ones) can and are sometimes used, but most other renderers tend to miss one or more of the often needed features like good texture filtering, texture caching, programmable shaders, highend geometry types like hair, subdivision or nurbs surfaces with tesselation on demand, geometry caching, raytracing with geometry caching, high quality shadow mapping, speed or patent-free implementations.  Other highly sought features these days may include interactive photorealistic rendering (IPR) and hardware rendering/shading.\n\nSome kind of render use GPU instead of CPU (FurryBall, Redshift, Octane) - the results are much faster. Disadvantages are limits of GPU memory.\n\nChronology of important published ideas \n\n* 1968 Ray casting\n* 1970 Scanline rendering\n* 1971 Gouraud shading\n* 1973 Phong shadingUniversity of Utah School of Computing, http://www.cs.utah.edu/school/history/#phong-ref\n* 1973 Phong reflection\n* 1973 Diffuse reflectionBui Tuong Phong, [http://www.cs.northwestern.edu/~ago820/cs395/Papers/Phong_1975.pdf Illumination for computer generated pictures], Communications of ACM 18 (1975), no. 6, 311–317.\n* 1973 Specular highlight\n* 1973 Specular reflection\n* 1974 Spriteshttp://vintage3d.org/history.php\n* 1974 Scrolling\n* 1974 Texture mapping\n* 1974 Z-buffering\n* 1976 Environment mapping\n* 1977 Blinn shadinghttp://dl.acm.org/citation.cfm?doid=563858.563893\n* 1977 Side-scrollinghttp://www.arcade-museum.com/game_detail.php?game_id=12797\n* 1977 Shadow volumes\n* 1978 Shadow mapping\n* 1978 Bump mapping\n* 1979 Tile maphttps://books.google.com/books?idoK3D4i5ldKgC&pg\nPA173\n* 1980 BSP trees\n* 1980 Ray tracing\n* 1981 Parallax scrollinghttps://books.google.com/books?idlB4PAwAAQBAJ&pg\nPA181\n* 1981 Sprite zoominghttp://www.system16.com/hardware.php?id=690\n* 1981 Cook shader\n* 1983 MIP maps\n* 1984 Octree ray tracing\n* 1984 Alpha compositing\n* 1984 Distributed ray tracing\n* 1984 Radiosity\n* 1985 Row/column scrollinghttp://cgfm2.emuviews.com/txt/s16tech.txt\n* 1985 Hemicube radiosity\n* 1986 Light source tracing\n* 1986 Rendering equation\n* 1987 Reyes rendering\n* 1988 Depth cuehttp://mamedev.org/source/src/mame/drivers/namcos21.c.html\n* 1988 Distance fog\n* 1988 Tiled rendering\n* 1991 Xiaolin Wu line anti-aliasing\n* 1991 Hierarchical radiosity\n* 1993 Texture filteringhttp://ign.com/articles/2009/04/21/ign-presents-the-history-of-sega?page=8\n* 1993 Perspective correctionhttp://www.system16.com/hardware.php?id=713\n* 1993 Transform, clipping, and lightinghttp://www.system16.com/hardware.php?id\n832\n* 1993 Directional lighting\n* 1993 Trilinear interpolation\n* 1993 Z-culling\n* 1993 Oren–Nayar reflectanceM. Oren and S.K. Nayar, \"[http://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf Generalization of Lambert's Reflectance Model]\". SIGGRAPH. pp.239-246, Jul, 1994\n* 1993 Tone mapping\n* 1993 Subsurface scattering\n* 1994 Ambient Occlusionhttp://dl.acm.org/citation.cfm?id=192244\n* 1995 Hidden surface determinationhttp://www.hotchips.org/wp-content/uploads/hc_archives/hc07/3_Tue/HC7.S5/HC7.5.1.pdf\n* 1995 Photon mapping\n* 1996 Multisample anti-aliasinghttp://www.system16.com/hardware.php?id=717\n* 1997 Metropolis light transport\n* 1997 Instant Radiosity\n* 1998 Hidden surface removalhttps://web.archive.org/web/20070811102018/http://www3.sharkyextreme.com/hardware/reviews/video/neon250/2.shtml\n* 2000 Pose space deformationhttp://dl.acm.org/citation.cfm?id=344862\n* 2002 Precomputed Radiance Transfer",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Rendering (computer graphics)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=6604" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Rendering or image synthesis is the automatic process of generating a photorealistic or non-photorealistic image from a 2D or 3D model (or models in what collectively could be called a scene file) by means of computer programs. Also, the results of displaying such a model can be called a render. A scene file contains objects in a strictly defined language or data structure; it would contain geometry, viewpoint, texture, lighting, and shading information as a description of the virtual scene. The data contained in the scene file is then passed to a rendering program to be processed and output to a digital image or raster graphics image file. The term \"rendering\" may be by analogy with an \"artist's rendering\" of a scene.\n\nThough the technical details of rendering methods vary, the general challenges to overcome in producing a 2D image from a 3D representation stored in a scene file are outlined as the graphics pipeline along a rendering device, such as a GPU. A GPU is a purpose-built device able to assist a CPU in performing complex rendering calculations. If a scene is to look relatively realistic and predictable under virtual lighting, the rendering software should solve the rendering equation. The rendering equation doesn't account for all lighting phenomena, but is a general lighting model for computer-generated imagery. 'Rendering' is also used to describe the process of calculating effects in a video editing program to produce final video output.\n\nRendering is one of the major sub-topics of 3D computer graphics, and in practice is always connected to the others. In the graphics pipeline, it is the last major step, giving the final appearance to the models and animation. With the increasing sophistication of computer graphics since the 1970s, it has become a more distinct subject.\n\nRendering has uses in architecture, video games, simulators, movie or TV visual effects, and design visualization, each employing a different balance of features and techniques. As a product, a wide variety of renderers are available. Some are integrated into larger modeling and animation packages, some are stand-alone, some are free open-source projects. On the inside, a renderer is a carefully engineered program, based on a selective mixture of disciplines related to: light physics, visual perception, mathematics, and software development.\n\nIn the case of 3D graphics, rendering may be done slowly, as in pre-rendering, or in realtime.  Pre-rendering is a computationally intensive process that is typically used for movie creation, while real-time rendering is often done for 3D video games which rely on the use of graphics cards with 3D hardware accelerators.\n\nUsage \n\nWhen the pre-image (a wireframe sketch usually) is complete, rendering is used, which adds in bitmap textures or procedural textures, lights, bump mapping and relative position to other objects. The result is a completed image the consumer or intended viewer sees.\n\nFor movie animations, several images (frames) must be rendered, and stitched together in a program capable of making an animation of this sort. Most 3D image editing programs can do this.\n\nFeatures \n\nA rendered image can be understood in terms of a number of visible features. Rendering research and development has been largely motivated by finding ways to simulate these efficiently. Some relate directly to particular algorithms and techniques, while others are produced together.\n\n* Shading how the color and brightness of a surface varies with lighting\n* Texture-mapping a method of applying detail to surfaces\n* Bump-mapping a method of simulating small-scale bumpiness on surfaces\n* Fogging/participating medium how light dims when passing through non-clear atmosphere or air\n* Shadows the effect of obstructing light\n* Soft shadows varying darkness caused by partially obscured light sources\n* Reflection mirror-like or highly glossy reflection\n* Transparency (optics), transparency (graphic) or opacity sharp transmission of light through solid objects\n* Translucency highly scattered transmission of light through solid objects\n* Refraction bending of light associated with transparency\n* Diffraction bending, spreading, and interference of light passing by an object or aperture that disrupts the ray\n* Indirect illumination surfaces illuminated by light reflected off other surfaces, rather than directly from a light source (also known as global illumination)\n* Caustics (a form of indirect illumination) reflection of light off a shiny object, or focusing of light through a transparent object, to produce bright highlights on another object\n* Depth of field objects appear blurry or out of focus when too far in front of or behind the object in focus\n* Motion blur objects appear blurry due to high-speed motion, or the motion of the camera\n* Non-photorealistic rendering rendering of scenes in an artistic style, intended to look like a painting or drawing\n\nTechniques \n\nMany rendering  have been researched, and software used for rendering may employ a number of different techniques to obtain a final image.\n\nTracing every particle of light in a scene is nearly always completely impractical and would take a stupendous amount of time. Even tracing a portion large enough to produce an image takes an inordinate amount of time if the sampling is not intelligently restricted.\n\nTherefore, a few loose families of more-efficient light transport modelling techniques have emerged:\n* rasterization, including scanline rendering, geometrically projects objects in the scene to an image plane, without advanced optical effects;\n* ray casting considers the scene as observed from a specific point of view, calculating the observed image based only on geometry and very basic optical laws of reflection intensity, and perhaps using Monte Carlo techniques to reduce artifacts;\n* ray tracing is similar to ray casting, but employs more advanced optical simulation, and usually uses Monte Carlo techniques to obtain more realistic results at a speed that is often orders of magnitude faster.\nThe fourth type of light transport technique, radiosity is not usually implemented as a rendering technique, but instead calculates the passage of light as it leaves the light source and illuminates surfaces. These surfaces are usually rendered to the display using one of the other three techniques.\n\nMost advanced software combines two or more of the techniques to obtain good-enough results at reasonable cost.\n\nAnother distinction is between image order algorithms, which iterate over pixels of the image plane, and object order algorithms, which iterate over objects in the scene. Generally object order is more efficient, as there are usually fewer objects in a scene than pixels.\n\nScanline rendering and rasterisation \n\nA high-level representation of an image necessarily contains elements in a different domain from pixels.  These elements are referred to as s.  In a schematic drawing, for instance, line segments and curves might be primitives.  In a graphical user interface, windows and buttons might be the primitives.  In rendering of 3D models, triangles and polygons in space might be primitives.\n\nIf a pixel-by-pixel (image order) approach to rendering is impractical or too slow for some task, then a primitive-by-primitive (object order) approach to rendering may prove useful.  Here, one loops through each of the primitives, determines which pixels in the image it affects, and modifies those pixels accordingly.  This is called rasterization, and is the rendering method used by all current graphics cards.\n\nRasterization is frequently faster than pixel-by-pixel rendering.  First, large areas of the image may be empty of primitives; rasterization will ignore these areas, but pixel-by-pixel rendering must pass through them.  Second, rasterization can improve cache coherency and reduce redundant work by taking advantage of the fact that the pixels occupied by a single primitive tend to be contiguous in the image.  For these reasons, rasterization is usually the approach of choice when interactive rendering is required; however, the pixel-by-pixel approach can often produce higher-quality images and is more versatile because it does not depend on as many assumptions about the image as rasterization.\n\nThe older form of rasterization is characterized by rendering an entire face (primitive) as a single color.  Alternatively, rasterization can be done in a more complicated manner by first rendering the vertices of a face and then rendering the pixels of that face as a blending of the vertex colors.  This version of rasterization has overtaken the old method as it allows the graphics to flow without complicated textures (a rasterized image when used face by face tends to have a very block-like effect if not covered in complex textures; the faces are not smooth because there is no gradual color change from one primitive to the next).  This newer method of rasterization utilizes the graphics card's more taxing shading functions and still achieves better performance because the simpler textures stored in memory use less space. Sometimes designers will use one rasterization method on some faces and the other method on others based on the angle at which that face meets other joined faces, thus increasing speed and not hurting the overall effect.\n\nRay casting \n\nIn ray casting the geometry which has been modeled is parsed pixel by pixel, line by line, from the point of view outward, as if casting rays out from the point of view. Where an object is intersected, the color value at the point may be evaluated using several methods. In the simplest, the color value of the object at the point of intersection becomes the value of that pixel. The color may be determined from a texture-map. A more sophisticated method is to modify the colour value by an illumination factor, but without calculating the relationship to a simulated light source. To reduce artifacts, a number of rays in slightly different directions may be averaged.\n\nRough simulations of optical properties may be additionally employed: a simple calculation of the ray from the object to the point of view is made. Another calculation is made of the angle of incidence of light rays from the light source(s), and from these as well as the specified intensities of the light sources, the value of the pixel is calculated. Another simulation uses illumination plotted from a radiosity algorithm, or a combination of these two.\n\nRaycasting is primarily used for realtime simulations, such as those used in 3D computer games and cartoon animations, where detail is not important, or where it is more efficient to manually fake the details in order to obtain better performance in the computational stage. This is usually the case when a large number of frames need to be animated. The resulting surfaces have a characteristic 'flat' appearance when no additional tricks are used, as if objects in the scene were all painted with matte finish.\n\nRay tracing \n\nRay tracing aims to simulate the natural flow of light, interpreted as particles. Often, ray tracing methods are utilized to approximate the solution to the rendering equation by applying Monte Carlo methods to it. Some of the most used methods are path tracing, bidirectional path tracing, or Metropolis light transport, but also semi realistic methods are in use, like Whitted Style Ray Tracing, or hybrids. While most implementations let light propagate on straight lines, applications exist to simulate relativistic spacetime effects.\n\nIn a final, production quality rendering of a ray traced work, multiple rays are generally shot for each pixel, and traced not just to the first object of intersection, but rather, through a number of sequential 'bounces', using the known laws of optics such as \"angle of incidence equals angle of reflection\" and more advanced laws that deal with refraction and surface roughness.\n\nOnce the ray either encounters a light source, or more probably once a set limiting number of bounces has been evaluated, then the surface illumination at that final point is evaluated using techniques described above, and the changes along the way through the various bounces evaluated to estimate a value observed at the point of view. This is all repeated for each sample, for each pixel.\n\nIn distribution ray tracing, at each point of intersection, multiple rays may be spawned. In path tracing, however, only a single ray or none is fired at each intersection, utilizing the statistical nature of Monte Carlo experiments.\n\nAs a brute-force method, ray tracing has been too slow to consider for real-time, and until recently too slow even to consider for short films of any degree of quality, although it has been used for special effects sequences, and in advertising, where a short portion of high quality (perhaps even photorealistic) footage is required.\n\nHowever, efforts at optimizing to reduce the number of calculations needed in portions of a work where detail is not high or does not depend on ray tracing features have led to a realistic possibility of wider use of ray tracing. There is now some hardware accelerated ray tracing equipment, at least in prototype phase, and some game demos which show use of real-time software or hardware ray tracing.\n\nRadiosity \n\nRadiosity is a method which attempts to simulate the way in which directly illuminated surfaces act as indirect light sources that illuminate other surfaces.  This produces more realistic shading and seems to better capture the 'ambience' of an indoor scene. A classic example is the way that shadows 'hug' the corners of rooms.\n\nThe optical basis of the simulation is that some diffused light from a given point on a given surface is reflected in a large spectrum of directions and illuminates the area around it.\n\nThe simulation technique may vary in complexity. Many renderings have a very rough estimate of radiosity, simply illuminating an entire scene very slightly with a factor known as ambiance. However, when advanced radiosity estimation is coupled with a high quality ray tracing algorithm, images may exhibit convincing realism, particularly for indoor scenes.\n\nIn advanced radiosity simulation, recursive, finite-element algorithms 'bounce' light back and forth between surfaces in the model, until some recursion limit is reached. The colouring of one surface in this way influences the colouring of a neighbouring surface, and vice versa. The resulting values of illumination throughout the model (sometimes including for empty spaces) are stored and used as additional inputs when performing calculations in a ray-casting or ray-tracing model.\n\nDue to the iterative/recursive nature of the technique, complex objects are particularly slow to emulate. Prior to the standardization of rapid radiosity calculation, some digital artists used a technique referred to loosely as false radiosity by darkening areas of texture maps corresponding to corners, joints and recesses, and applying them via self-illumination or diffuse mapping for scanline rendering. Even now, advanced radiosity calculations may be reserved for calculating the ambiance of the room, from the light reflecting off walls, floor and ceiling, without examining the contribution that complex objects make to the radiosity—or complex objects may be replaced in the radiosity calculation with simpler objects of similar size and texture.\n\nRadiosity calculations are viewpoint independent which increases the computations involved, but makes them useful for all viewpoints. If there is little rearrangement of radiosity objects in the scene, the same radiosity data may be reused for a number of frames, making radiosity an effective way to improve on the flatness of ray casting, without seriously impacting the overall rendering time-per-frame.\n\nBecause of this, radiosity is a prime component of leading real-time rendering methods, and has been used from beginning-to-end to create a large number of well-known recent feature-length animated 3D-cartoon films.\n\nSampling and filtering \n\nOne problem that any rendering system must deal with, no matter which approach it takes, is the sampling problem.  Essentially, the rendering process tries to depict a continuous function from image space to colors by using a finite number of pixels.  As a consequence of the Nyquist–Shannon sampling theorem (or Kotelnikov theorem), any spatial waveform that can be displayed must consist of at least two pixels, which is proportional to image resolution.  In simpler terms, this expresses the idea that an image cannot display details, peaks or troughs in color or intensity, that are smaller than one pixel.\n\nIf a naive rendering algorithm is used without any filtering, high frequencies in the image function will cause ugly aliasing to be present in the final image.  Aliasing typically manifests itself as jaggies, or jagged edges on objects where the pixel grid is visible.  In order to remove aliasing, all rendering algorithms (if they are to produce good-looking images) must use some kind of low-pass filter on the image function to remove high frequencies, a process called antialiasing.\n\nOptimization \n\nOptimizations used by an artist when a scene is being developed \n\nDue to the large number of calculations, a work in progress is usually only rendered in detail appropriate to the portion of the work being developed at a given time, so in the initial stages of modeling, wireframe and ray casting may be used, even where the target output is ray tracing with radiosity. It is also common to render only parts of the scene at high detail, and to remove objects that are not important to what is currently being developed.\n\nCommon optimizations for real time rendering \n\nFor real-time, it is appropriate to simplify one or more common approximations, and tune to the exact parameters of the scenery in question, which is also tuned to the agreed parameters to get the most 'bang for the buck'.\n\nAcademic core \n\nThe implementation of a realistic renderer always has some basic element of physical simulation or emulation — some computation which resembles or abstracts a real physical process.\n\nThe term \"physically based\" indicates the use of physical models and approximations that are more general and widely accepted outside rendering. A particular set of related techniques have gradually become established in the rendering community.\n\nThe basic concepts are moderately straightforward, but intractable to calculate; and a single elegant algorithm or approach has been elusive for more general purpose renderers. In order to meet demands of robustness, accuracy and practicality, an implementation will be a complex combination of different techniques.\n\nRendering research is concerned with both the adaptation of scientific models and their efficient application.\n\nThe rendering equation \n\nThis is the key academic/theoretical concept in rendering. It serves as the most abstract formal expression of the non-perceptual aspect of rendering. All more complete algorithms can be seen as solutions to particular formulations of this equation.\n\nL_o(x, \\vec w) = L_e(x, \\vec w) + \\int_\\Omega f_r(x, \\vec w', \\vec w) L_i(x, \\vec w') (\\vec w' \\cdot \\vec n) \\mathrm{d}\\vec w'\nMeaning: at a particular position and direction, the outgoing light (Lo) is the sum of the emitted light (Le) and the reflected light. The reflected light being the sum of the incoming light (Li) from all directions, multiplied by the surface reflection and incoming angle. By connecting outward light to inward light, via an interaction point, this equation stands for the whole 'light transport' — all the movement of light — in a scene.\n\nThe bidirectional reflectance distribution function \n\nThe bidirectional reflectance distribution function (BRDF) expresses a simple model of light interaction with a surface as follows:\n\nf_r(x, \\vec w', \\vec w) = \\frac{\\mathrm{d}L_r(x, \\vec w)}{L_i(x, \\vec w')(\\vec w' \\cdot \\vec n) \\mathrm{d}\\vec w'}\n\nLight interaction is often approximated by the even simpler models: diffuse reflection and specular reflection, although both can ALSO be BRDFs.\n\nGeometric optics \n\nRendering is practically exclusively concerned with the particle aspect of light physics — known as geometrical optics. Treating light, at its basic level, as particles bouncing around is a simplification, but appropriate: the wave aspects of light are negligible in most scenes, and are significantly more difficult to simulate. Notable wave aspect phenomena include diffraction (as seen in the colours of CDs and DVDs) and polarisation (as seen in LCDs). Both types of effect, if needed, are made by appearance-oriented adjustment of the reflection model.\n\nVisual perception \n\nThough it receives less attention, an understanding of human visual perception is valuable to rendering. This is mainly because image displays and human perception have restricted ranges. A renderer can simulate an almost infinite range of light brightness and color, but current displays — movie screen, computer monitor, etc. — cannot handle so much, and something must be discarded or compressed. Human perception also has limits, and so does not need to be given large-range images to create realism. This can help solve the problem of fitting images into displays, and, furthermore, suggest what short-cuts could be used in the rendering simulation, since certain subtleties won't be noticeable. This related subject is tone mapping.\n\nMathematics used in rendering includes: linear algebra, calculus, numerical mathematics, signal processing, and Monte Carlo methods.\n\nRendering for movies often takes place on a network of tightly connected computers known as a render farm.\n\nThe current state of the art in 3-D image description for movie creation is the mental ray scene description language designed at mental images and RenderMan Shading Language designed at Pixar.[http://portal.acm.org/citation.cfm?id1185817&jmp\nabstract&collGUIDE&dl\nGUIDE A brief introduction to RenderMan] (compare with simpler 3D fileformats such as VRML or APIs such as OpenGL and DirectX tailored for 3D hardware accelerators).\n\nOther renderers (including proprietary ones) can and are sometimes used, but most other renderers tend to miss one or more of the often needed features like good texture filtering, texture caching, programmable shaders, highend geometry types like hair, subdivision or nurbs surfaces with tesselation on demand, geometry caching, raytracing with geometry caching, high quality shadow mapping, speed or patent-free implementations.  Other highly sought features these days may include interactive photorealistic rendering (IPR) and hardware rendering/shading.\n\nSome kind of render use GPU instead of CPU (FurryBall, Redshift, Octane) - the results are much faster. Disadvantages are limits of GPU memory.\n\nChronology of important published ideas \n\n* 1968 Ray casting\n* 1970 Scanline rendering\n* 1971 Gouraud shading\n* 1973 Phong shadingUniversity of Utah School of Computing, http://www.cs.utah.edu/school/history/#phong-ref\n* 1973 Phong reflection\n* 1973 Diffuse reflectionBui Tuong Phong, [http://www.cs.northwestern.edu/~ago820/cs395/Papers/Phong_1975.pdf Illumination for computer generated pictures], Communications of ACM 18 (1975), no. 6, 311–317.\n* 1973 Specular highlight\n* 1973 Specular reflection\n* 1974 Spriteshttp://vintage3d.org/history.php\n* 1974 Scrolling\n* 1974 Texture mapping\n* 1974 Z-buffering\n* 1976 Environment mapping\n* 1977 Blinn shadinghttp://dl.acm.org/citation.cfm?doid=563858.563893\n* 1977 Side-scrollinghttp://www.arcade-museum.com/game_detail.php?game_id=12797\n* 1977 Shadow volumes\n* 1978 Shadow mapping\n* 1978 Bump mapping\n* 1979 Tile maphttps://books.google.com/books?idoK3D4i5ldKgC&pg\nPA173\n* 1980 BSP trees\n* 1980 Ray tracing\n* 1981 Parallax scrollinghttps://books.google.com/books?idlB4PAwAAQBAJ&pg\nPA181\n* 1981 Sprite zoominghttp://www.system16.com/hardware.php?id=690\n* 1981 Cook shader\n* 1983 MIP maps\n* 1984 Octree ray tracing\n* 1984 Alpha compositing\n* 1984 Distributed ray tracing\n* 1984 Radiosity\n* 1985 Row/column scrollinghttp://cgfm2.emuviews.com/txt/s16tech.txt\n* 1985 Hemicube radiosity\n* 1986 Light source tracing\n* 1986 Rendering equation\n* 1987 Reyes rendering\n* 1988 Depth cuehttp://mamedev.org/source/src/mame/drivers/namcos21.c.html\n* 1988 Distance fog\n* 1988 Tiled rendering\n* 1991 Xiaolin Wu line anti-aliasing\n* 1991 Hierarchical radiosity\n* 1993 Texture filteringhttp://ign.com/articles/2009/04/21/ign-presents-the-history-of-sega?page=8\n* 1993 Perspective correctionhttp://www.system16.com/hardware.php?id=713\n* 1993 Transform, clipping, and lightinghttp://www.system16.com/hardware.php?id\n832\n* 1993 Directional lighting\n* 1993 Trilinear interpolation\n* 1993 Z-culling\n* 1993 Oren–Nayar reflectanceM. Oren and S.K. Nayar, \"[http://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf Generalization of Lambert's Reflectance Model]\". SIGGRAPH. pp.239-246, Jul, 1994\n* 1993 Tone mapping\n* 1993 Subsurface scattering\n* 1994 Ambient Occlusionhttp://dl.acm.org/citation.cfm?id=192244\n* 1995 Hidden surface determinationhttp://www.hotchips.org/wp-content/uploads/hc_archives/hc07/3_Tue/HC7.S5/HC7.5.1.pdf\n* 1995 Photon mapping\n* 1996 Multisample anti-aliasinghttp://www.system16.com/hardware.php?id=717\n* 1997 Metropolis light transport\n* 1997 Instant Radiosity\n* 1998 Hidden surface removalhttps://web.archive.org/web/20070811102018/http://www3.sharkyextreme.com/hardware/reviews/video/neon250/2.shtml\n* 2000 Pose space deformationhttp://dl.acm.org/citation.cfm?id=344862\n* 2002 Precomputed Radiance Transfer. Rendering (computer graphics). http://en.wikipedia.org/?curid=6604."
  }
}
