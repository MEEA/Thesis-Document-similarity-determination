{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=7850",
  "eid" : "e3bf1540-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778461844,
  "textBody" : "In formal language theory, a context-free grammar G is said to be in Chomsky normal form (first described by Noam Chomsky) if all of its production rules are of the form:\nA → BC,   or\nA → a,   or\nS → ε,\nwhere A, B, and C are nonterminal symbols, a is a terminal symbol (a symbol that represents a constant value), S is the start symbol, and ε denotes the empty string.  Also, neither B nor C may be the start symbol, and the third production rule can only appear if ε is in L(G), namely, the language produced by the context-free grammar G.\n\nEvery grammar in Chomsky normal form is context-free, and conversely, every context-free grammar can be transformed into an equivalent onethat is, one that produces the same language which is in Chomsky normal form and has a size no larger than the square of the original grammar's size.\n\nConverting a grammar to Chomsky normal form\n\nTo convert a grammar to Chomsky normal form, a sequence of simple transformations is applied in a certain order; this is described in most textbooks on automata theory. Section 7.1.5, p.272 Section 6.2 \"Die Chomsky-Normalform für kontextfreie Grammatiken\", p. 149–152\nThe presentation here follows Hopcroft, Ullman (1979), but is adapted to use the transformation names from Lange, Leiß (2009).For example, Hopcroft, Ullman (1979) merged TERM and BIN into a single transformation. Each of the following transformations establishes one of the properties required for Chomsky normal form.\n\nSTART: Eliminate the start symbol from right-hand sides\n\nIntroduce a new start symbol S0, and a new rule \nS0 → S, \nwhere S is the previous start symbol.\nThis doesn't change the grammar's produced language, and S0 won't occur on any rule's right-hand side.\n\nTERM: Eliminate rules with nonsolitary terminals\n\nTo eliminate each rule \nA → X1 ... a ... Xn\nwith a terminal symbol a being not the only symbol on the right-hand side, introduce, for every such terminal, a new nonterminal symbol Na, and a new rule \nNa → a. \nChange every rule \nA → X1 ... a ... Xn \nto \nA → X1 ... Na ... Xn.\nIf several terminal symbols occur on the right-hand side, simultaneously replace each of them by its associated nonterminal symbol.\nThis doesn't change the grammar's produced language.\n\nBIN: Eliminate right-hand sides with more than 2 nonterminals\n\nReplace each rule \nA → X1 X2 ... Xn \nwith more than 2 nonterminals X1,...,Xn by rules \nA → X1 A1, \nA1 → X2 A2, \n... , \nAn-2 → Xn-1 Xn, \nwhere Ai are new nonterminal symbols.\nAgain, this doesn't change the grammar's produced language.\n\nDEL: Eliminate ε-rules\n\nAn ε-rule is a rule of the form \nA → ε, \nwhere A is not S0, the grammar's start symbol.\n\nTo eliminate all rules of this form, first determine the set of all nonterminals that derive ε.\nHopcroft and Ullman (1979) call such nonterminals nullable, and compute them as follows:\n* If a rule A → ε exists, then A is nullable.\n* If a rule A → X1 ... Xn exists, and every single Xi is nullable, then A is nullable, too.\n\nObtain an intermediate grammar by replacing each rule \nA → X1 ... Xn \nby all versions with some nullable Xi omitted.\nBy deleting in this grammar each ε-rule, unless its left-hand side is the start symbol, the transformed grammar is obtained.\n\nFor example, in the following grammar, with start symbol S0,\nS0 → AbB | C\nB → AA | AC\nC → b | c\nA → a | ε\nthe nonterminal A, and hence also B, is nullable, while neither C nor S0 is.\nHence the following intermediate grammar is obtained:indicating a kept and omitted nonterminal N by ' and ', respectively\nS0 → b | b | b | b   |   C\nB → ' | ' | ' | ε   |   C | C\nC → b | c\nA → a | ε\nIn this grammar, all ε-rules have been \"inlined at the call site\".If the grammar had a rule S0 → ε, it could not be \"inlined\", since it had no \"call sites\". Therefore it couldn't be deleted in the next step.\nIn the next step, they can hence be deleted, yielding the grammar:\nS0 → AbB | Ab | bB | b   |   C\nB → AA | A   |   AC | C\nC → b | c\nA → a\nThis grammar produces the same language as the original example grammar, viz. {ab,aba,abaa,abab,abac,abb,abc,b,bab,bac,bb,bc,c}, but apparently has no ε-rules.\n\nUNIT: Eliminate unit rules\n\nA unit rule is a rule of the form \nA → B, \nwhere A, B are nonterminal symbols.\nTo remove it, for each rule \nB →  X1 ... Xn, \nwhere  X1 ... Xn is a string of nonterminals and terminals, add rule \nA →  X1 ... Xn \nunless this is a unit rule which has already been (or is being) removed.\n\nOrder of transformations\n\nWhen choosing the order in which the above transformations are to be applied, it has to be considered that some transformations may destroy the result achieved by other ones. For example, START will re-introduce a unit rule if it is applied after UNIT. The table shows which orderings are admitted.\n\nMoreover, the worst-case bloat in grammar sizei.e. written length, measured in symbols depends on the transformation order. Using |G| to denote the size of the original grammar G, the size blow-up in the worst case may range from |G|2 to 22 |G|, depending on the transformation algorithm used. The blow-up in grammar size depends on the order between DEL and BIN. It may be exponential when DEL is done first, but is linear otherwise. UNIT can incur a quadratic blow-up in the size of the grammar. The orderings START,TERM,BIN,DEL,UNIT and START,BIN,DEL,UNIT,TERM lead to the least (i.e. quadratic) blow-up.\n\nExample\n\nThe following grammar, with start symbol Expr, describes a simplified version of the set of all syntactical valid arithmetic expressions in programming languages like C or Algol60. Both number and variable are considered terminal symbols here for simplicity, since in a compiler front-end their internal structure is usually not considered by the parser. The terminal symbol \"^\" denoted exponentiation in Algol60.\n\nIn step \"START\" of the above conversion algorithm, just a rule S0→Expr is added to the grammar.\nAfter step \"TERM\", the grammar looks like this:\n\nAfter step \"BIN\", the following grammar is obtained:\n\nSince there are no ε-rules, step \"DEL\" doesn't change the grammar.\nAfter step \"UNIT\", the following grammar is obtained, which is in Chomsky normal form:\n\nThe Na introduced in step \"TERM\" are PowOp, Open, and Close.\nThe Ai introduced in step \"BIN\" are AddOp_Term, MulOp_Factor, PowOp_Primary, and Expr_Close.\n\nAlternative definition\n\nChomsky reduced form \n\nAnother wayHopcroft et al. (2006) to define the Chomsky normal form is:\n\nA formal grammar is in Chomsky reduced form if all of its production rules are of the form:\nA \\rightarrow\\, BC or\nA \\rightarrow\\, a,\nwhere A, B and C are nonterminal symbols, and a is a terminal symbol.  When using this definition, B or C may be the start symbol.  Only those context-free grammars which do not generate the empty string can be transformed into Chomsky reduced form.\n\nFloyd normal form \n\nIn a paper where he proposed a term Backus–Naur form (BNF), Donald E. Knuth implied a BNF \"syntax in which all definitions have such a form may be said to be in 'Floyd Normal Form'\",\n\\langle A \\rangle ::= \\, \\langle B \\rangle \\mid \\langle C \\rangle or\n\\langle A \\rangle ::= \\, \\langle B \\rangle \\langle C \\rangle or\n\\langle A \\rangle ::=\\, a,\nwhere \\langle A \\rangle, \\langle B \\rangle and \\langle C \\rangle are nonterminal symbols, and a is a terminal symbol,\nbecause Robert W. Floyd found any BNF syntax can be converted to the above one in 1961. But he withdrew this term, \"since doubtless many people have independently used this simple fact in their own work, and the point is only incidental to the main considerations of Floyd's note.\"\n\nApplication \n\nBesides its theoretical significance, CNF conversion is used in some algorithms as a preprocessing step, e.g., the CYK algorithm, a bottom-up parsing for context-free grammars, and its variant probabilistic CKY.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Chomsky normal form" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=7850" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In formal language theory, a context-free grammar G is said to be in Chomsky normal form (first described by Noam Chomsky) if all of its production rules are of the form:\nA → BC,   or\nA → a,   or\nS → ε,\nwhere A, B, and C are nonterminal symbols, a is a terminal symbol (a symbol that represents a constant value), S is the start symbol, and ε denotes the empty string.  Also, neither B nor C may be the start symbol, and the third production rule can only appear if ε is in L(G), namely, the language produced by the context-free grammar G.\n\nEvery grammar in Chomsky normal form is context-free, and conversely, every context-free grammar can be transformed into an equivalent onethat is, one that produces the same language which is in Chomsky normal form and has a size no larger than the square of the original grammar's size.\n\nConverting a grammar to Chomsky normal form\n\nTo convert a grammar to Chomsky normal form, a sequence of simple transformations is applied in a certain order; this is described in most textbooks on automata theory. Section 7.1.5, p.272 Section 6.2 \"Die Chomsky-Normalform für kontextfreie Grammatiken\", p. 149–152\nThe presentation here follows Hopcroft, Ullman (1979), but is adapted to use the transformation names from Lange, Leiß (2009).For example, Hopcroft, Ullman (1979) merged TERM and BIN into a single transformation. Each of the following transformations establishes one of the properties required for Chomsky normal form.\n\nSTART: Eliminate the start symbol from right-hand sides\n\nIntroduce a new start symbol S0, and a new rule \nS0 → S, \nwhere S is the previous start symbol.\nThis doesn't change the grammar's produced language, and S0 won't occur on any rule's right-hand side.\n\nTERM: Eliminate rules with nonsolitary terminals\n\nTo eliminate each rule \nA → X1 ... a ... Xn\nwith a terminal symbol a being not the only symbol on the right-hand side, introduce, for every such terminal, a new nonterminal symbol Na, and a new rule \nNa → a. \nChange every rule \nA → X1 ... a ... Xn \nto \nA → X1 ... Na ... Xn.\nIf several terminal symbols occur on the right-hand side, simultaneously replace each of them by its associated nonterminal symbol.\nThis doesn't change the grammar's produced language.\n\nBIN: Eliminate right-hand sides with more than 2 nonterminals\n\nReplace each rule \nA → X1 X2 ... Xn \nwith more than 2 nonterminals X1,...,Xn by rules \nA → X1 A1, \nA1 → X2 A2, \n... , \nAn-2 → Xn-1 Xn, \nwhere Ai are new nonterminal symbols.\nAgain, this doesn't change the grammar's produced language.\n\nDEL: Eliminate ε-rules\n\nAn ε-rule is a rule of the form \nA → ε, \nwhere A is not S0, the grammar's start symbol.\n\nTo eliminate all rules of this form, first determine the set of all nonterminals that derive ε.\nHopcroft and Ullman (1979) call such nonterminals nullable, and compute them as follows:\n* If a rule A → ε exists, then A is nullable.\n* If a rule A → X1 ... Xn exists, and every single Xi is nullable, then A is nullable, too.\n\nObtain an intermediate grammar by replacing each rule \nA → X1 ... Xn \nby all versions with some nullable Xi omitted.\nBy deleting in this grammar each ε-rule, unless its left-hand side is the start symbol, the transformed grammar is obtained.\n\nFor example, in the following grammar, with start symbol S0,\nS0 → AbB | C\nB → AA | AC\nC → b | c\nA → a | ε\nthe nonterminal A, and hence also B, is nullable, while neither C nor S0 is.\nHence the following intermediate grammar is obtained:indicating a kept and omitted nonterminal N by ' and ', respectively\nS0 → b | b | b | b   |   C\nB → ' | ' | ' | ε   |   C | C\nC → b | c\nA → a | ε\nIn this grammar, all ε-rules have been \"inlined at the call site\".If the grammar had a rule S0 → ε, it could not be \"inlined\", since it had no \"call sites\". Therefore it couldn't be deleted in the next step.\nIn the next step, they can hence be deleted, yielding the grammar:\nS0 → AbB | Ab | bB | b   |   C\nB → AA | A   |   AC | C\nC → b | c\nA → a\nThis grammar produces the same language as the original example grammar, viz. {ab,aba,abaa,abab,abac,abb,abc,b,bab,bac,bb,bc,c}, but apparently has no ε-rules.\n\nUNIT: Eliminate unit rules\n\nA unit rule is a rule of the form \nA → B, \nwhere A, B are nonterminal symbols.\nTo remove it, for each rule \nB →  X1 ... Xn, \nwhere  X1 ... Xn is a string of nonterminals and terminals, add rule \nA →  X1 ... Xn \nunless this is a unit rule which has already been (or is being) removed.\n\nOrder of transformations\n\nWhen choosing the order in which the above transformations are to be applied, it has to be considered that some transformations may destroy the result achieved by other ones. For example, START will re-introduce a unit rule if it is applied after UNIT. The table shows which orderings are admitted.\n\nMoreover, the worst-case bloat in grammar sizei.e. written length, measured in symbols depends on the transformation order. Using |G| to denote the size of the original grammar G, the size blow-up in the worst case may range from |G|2 to 22 |G|, depending on the transformation algorithm used. The blow-up in grammar size depends on the order between DEL and BIN. It may be exponential when DEL is done first, but is linear otherwise. UNIT can incur a quadratic blow-up in the size of the grammar. The orderings START,TERM,BIN,DEL,UNIT and START,BIN,DEL,UNIT,TERM lead to the least (i.e. quadratic) blow-up.\n\nExample\n\nThe following grammar, with start symbol Expr, describes a simplified version of the set of all syntactical valid arithmetic expressions in programming languages like C or Algol60. Both number and variable are considered terminal symbols here for simplicity, since in a compiler front-end their internal structure is usually not considered by the parser. The terminal symbol \"^\" denoted exponentiation in Algol60.\n\nIn step \"START\" of the above conversion algorithm, just a rule S0→Expr is added to the grammar.\nAfter step \"TERM\", the grammar looks like this:\n\nAfter step \"BIN\", the following grammar is obtained:\n\nSince there are no ε-rules, step \"DEL\" doesn't change the grammar.\nAfter step \"UNIT\", the following grammar is obtained, which is in Chomsky normal form:\n\nThe Na introduced in step \"TERM\" are PowOp, Open, and Close.\nThe Ai introduced in step \"BIN\" are AddOp_Term, MulOp_Factor, PowOp_Primary, and Expr_Close.\n\nAlternative definition\n\nChomsky reduced form \n\nAnother wayHopcroft et al. (2006) to define the Chomsky normal form is:\n\nA formal grammar is in Chomsky reduced form if all of its production rules are of the form:\nA \\rightarrow\\, BC or\nA \\rightarrow\\, a,\nwhere A, B and C are nonterminal symbols, and a is a terminal symbol.  When using this definition, B or C may be the start symbol.  Only those context-free grammars which do not generate the empty string can be transformed into Chomsky reduced form.\n\nFloyd normal form \n\nIn a paper where he proposed a term Backus–Naur form (BNF), Donald E. Knuth implied a BNF \"syntax in which all definitions have such a form may be said to be in 'Floyd Normal Form'\",\n\\langle A \\rangle ::= \\, \\langle B \\rangle \\mid \\langle C \\rangle or\n\\langle A \\rangle ::= \\, \\langle B \\rangle \\langle C \\rangle or\n\\langle A \\rangle ::=\\, a,\nwhere \\langle A \\rangle, \\langle B \\rangle and \\langle C \\rangle are nonterminal symbols, and a is a terminal symbol,\nbecause Robert W. Floyd found any BNF syntax can be converted to the above one in 1961. But he withdrew this term, \"since doubtless many people have independently used this simple fact in their own work, and the point is only incidental to the main considerations of Floyd's note.\"\n\nApplication \n\nBesides its theoretical significance, CNF conversion is used in some algorithms as a preprocessing step, e.g., the CYK algorithm, a bottom-up parsing for context-free grammars, and its variant probabilistic CKY. Chomsky normal form. http://en.wikipedia.org/?curid=7850."
  }
}
