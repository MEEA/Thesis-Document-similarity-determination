{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=9647",
  "eid" : "f0c547f0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778483695,
  "textBody" : "Euphoria is a programming language originally created by Robert Craig of Rapid Deployment Software in Toronto, Ontario, Canada. Initially developed (though not publicly released) on the Atari ST, the first commercial release was for the 16-bit DOS platform and was proprietary. In 2006, with the release of version 3, Euphoria became open-source software. The openEuphoria Group continues to administer and develop the project.  In December 2010, the openEuphoria Group released version 4 of openEuphoria along with a new identity and mascot for the project. OpenEuphoria is currently available for Windows, Linux, macOS and three flavors of *BSD.\n\nEuphoria is a general-purpose high-level imperative-procedural interpreted language. A translator generates C source code and the GNU compiler collection (GCC) and Open Watcom compilers are supported. Alternatively, Euphoria programs may be bound with the interpreter to create stand-alone executables. A number of graphical user interface (GUI) libraries are supported including Win32lib and wrappers for wxWidgets, GTK+ and IUP. Euphoria has a simple built-in database and wrappers for a variety of other databases.\n\nOverview\n\nThe Euphoria language is a general purpose procedural language that focuses on simplicity, legibility, rapid development and performance via several means.\n*Simplicity – It uses just four built-in data types (see below) and implements automatic garbage collection.\n*Legibility – The syntax favors simple English keywords over the use of punctuation to delineate constructs.\n*Rapid development – An interpreter encourages prototyping and incremental development.\n*Performance – An efficient reference-counting garbage collector correctly handles cyclic references.\n\nHistory\n\nDeveloped as a personal project to invent a programming language from scratch, Euphoria was created by Robert Craig on an Atari Mega-ST. Many design ideas for the language came from Craig's Master's thesis in computer science at the University of Toronto. Craig's thesis was heavily influenced by the work of John Backus on functional programming (FP) languages.\n\nCraig ported his original Atari implementation to the 16-bit DOS platform and Euphoria was first released, version 1.0, in July 1993 under a proprietary licence. The original Atari implementation is described by Craig as \"primitive\" and has not been publicly released. Euphoria continued to be developed and released by Craig via his company Rapid Deployment Software (RDS) and website rapideuphoria.com. In October 2006 RDS released version 3 of Euphoria and announced that henceforth Euphoria would be freely distributed under an open-source software licence.\n\nRDS continued to develop Euphoria, culminating with the release of version 3.1.1 in August, 2007. Subsequently, RDS ceased unilateral development of Euphoria and the openEuphoria Group took over ongoing development. The openEuphoria Group released version 4 in December, 2010 along with a new logo and mascot for the openEuphoria project.\n\nVersion 3.1.1 remains an important milestone release, being the last version of Euphoria which supports the DOS platform.\n\nEuphoria is an acronym for End-User Programming with Hierarchical Objects for Robust Interpreted Applications although there is some suspicion that this is a backronym.\n\nThe Euphoria interpreter was originally written in C. With the release of version 2.5 in November 2004 the Euphoria interpreter was split into two parts: a front-end parser, and a back-end interpreter. The front-end is now written in Euphoria (and used with the Euphoria-to-C translator and the Binder). The main back-end and run time library are written in C.\n\nFeatures\n\nEuphoria was conceived and developed with the following design goals and features:\n\n* Ease of learning and with consistent high-level constructs (more so than e.g., the BASIC language)\n* Implementation of flat-form 32-bit memory to avoid complex memory management and size-addressing limits\n* Debugging support and run-time error-handling\n* Subscript and type checking\n* Loose and strict variable typing\n* Programming via objects as types (user-defined or otherwise)\n* Interpreted, with automatic memory management and garbage collection\n* Heterogeneous collection types (sequences)\n* DOS graphics library (Euphoria language versions up to and including 3.1.1)\n* Debugger\n* Integrated database system\n* Low-level memory handling\n* Straightforward wrapping of (or access to) C libraries\n\nExecution modes\n\n* Interpreter\n* C translator (E2C) for standalone executables or dynamic linking\n* Bytecode compiler and interpreter (shrouder)\n* The Binder binds the Euphoria source code to the interpreter to create an executable.\n* A read–eval–print loop (REPL) version is on the openEuphoria roadmap.\n\nUse\n\nEuphoria is designed to readily facilitate handling of dynamic sets of data of varying types and is particularly useful for string and image processing. Euphoria has been used in artificial intelligence experiments, the study of mathematics, for teaching programming, and to implement fonts involving thousands of characters. A large part of the Euphoria interpreter is written in Euphoria.\n\nData types\n\nEuphoria has two basic data types:\nAtom – A number, implemented as a 31-bit signed integer or a 64-bit IEEE floating-point. Euphoria dynamically changes between integer and floating point representation according to the current value.\nSequence – A vector (array) with zero or more elements. Each element may be an atom or another sequence. The number of elements in a sequence is not fixed (i.e., the size of the vector/array does not have to be declared). The program may add or remove elements as needed during run-time. Memory allocation-deallocation is automatically handled by reference counting. Individual elements are referenced using an index value enclosed in square brackets. The first element in a sequence has an index of one [1]. Elements inside embedded sequences are referenced by additional bracked index values, thus X[3][2] refers to the second element contained in the sequence that is the third element of X. Each element of a sequence is an object type (see below).\n\nEuphoria has two additional data types predefined:\nInteger – An atom, restricted to 31-bit signed integer values in the range -1073741824 to 1073741823 (-2^30 to 2^30-1). Integer data types are more efficient than the atom data types, but cannot contain the same range of values. Characters are stored as integers, e.g., coding ASCII-'A' is exactly the same as coding 65.\nObject – A generic datatype which may contain any of the above (i.e., atom, sequence or integer) and which may be changed to another type during run-time.\n\nThere is no character string data type. Strings are represented by a sequence of integer values. However, because literal strings are so commonly used in programming, Euphoria interprets double-quote enclosed characters as a sequence of integers. Thus\n \"ABC\"\nis seen as if the coder had written:\n {'A', 'B', 'C'}\nwhich is the same as:\n {65, 66, 67}\n\nHello, World!\n\n puts(1, \"Hello, World!\\n\")\n\nExamples\n\nProgram comments start with a double hyphen -- and go through the end of line.\n\nThe following code looks for an old item in a group of items. If found, it removes it by concatenating all the elements before it with all the elements after it. Note that the first element in a sequence has the index one [1] and that $ refers to the length (i.e., total number of elements) of the sequence.\n\n global function delete_item( object old, sequence group )\n    integer pos\n              -- Code begins --\n    pos find( old, group )\n    if pos > 0 then\n        group = group[1 .. pos-1] & group[pos+1 .. $]\n    end if\n    return group\n end function\n\nThe following modification to the above example replaces an old item with a new item. As the variables old and new have been defined as objects, they could be atoms or sequences. Type checking is not needed as the function will work with any sequence of data of any type and needs no external libraries.\n\n global function replace_item( object old, object new, sequence group )\n    integer pos\n              -- Code begins --\n    pos find( old, group )\n    if pos > 0 then\n        group[pos] = new\n    end if\n    return group\n end function\n\nFurthermore, no pointers are involved and subscripts are automatically checked. Thus the function cannot access memory out-of-bounds. There is no need to allocate or deallocate memory explicitly and no chance of a memory leak.\n\nThe line\n\n group = group[1 .. pos-1] & group[pos+1 .. $]\n\nshows some of the sequence handling facilities. A sequence may contain a set of any types, and this can be sliced (to take a subset of the data in a sequence) and concatenated in expressions with no need for special functions.\n\nParameter passing\n\nArguments to routines are always passed by value; there is no pass-by-reference facility. However, parameters are allowed to be modified locally (i.e., within the callee) which is implemented very efficiently as sequences have automatic copy-on-write semantics. In other words, when you pass a sequence to a routine, initially only a reference to it is passed, but at the point the routine modifies this sequence parameter the sequence is copied and the routine updates only a copy of the original.\n\nComparable languages\n\n* Lua\n* [http://phix.x10.mx Phix]\n* Python\n* REBOL\n* Ruby",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Euphoria (programming language)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=9647" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Euphoria is a programming language originally created by Robert Craig of Rapid Deployment Software in Toronto, Ontario, Canada. Initially developed (though not publicly released) on the Atari ST, the first commercial release was for the 16-bit DOS platform and was proprietary. In 2006, with the release of version 3, Euphoria became open-source software. The openEuphoria Group continues to administer and develop the project.  In December 2010, the openEuphoria Group released version 4 of openEuphoria along with a new identity and mascot for the project. OpenEuphoria is currently available for Windows, Linux, macOS and three flavors of *BSD.\n\nEuphoria is a general-purpose high-level imperative-procedural interpreted language. A translator generates C source code and the GNU compiler collection (GCC) and Open Watcom compilers are supported. Alternatively, Euphoria programs may be bound with the interpreter to create stand-alone executables. A number of graphical user interface (GUI) libraries are supported including Win32lib and wrappers for wxWidgets, GTK+ and IUP. Euphoria has a simple built-in database and wrappers for a variety of other databases.\n\nOverview\n\nThe Euphoria language is a general purpose procedural language that focuses on simplicity, legibility, rapid development and performance via several means.\n*Simplicity – It uses just four built-in data types (see below) and implements automatic garbage collection.\n*Legibility – The syntax favors simple English keywords over the use of punctuation to delineate constructs.\n*Rapid development – An interpreter encourages prototyping and incremental development.\n*Performance – An efficient reference-counting garbage collector correctly handles cyclic references.\n\nHistory\n\nDeveloped as a personal project to invent a programming language from scratch, Euphoria was created by Robert Craig on an Atari Mega-ST. Many design ideas for the language came from Craig's Master's thesis in computer science at the University of Toronto. Craig's thesis was heavily influenced by the work of John Backus on functional programming (FP) languages.\n\nCraig ported his original Atari implementation to the 16-bit DOS platform and Euphoria was first released, version 1.0, in July 1993 under a proprietary licence. The original Atari implementation is described by Craig as \"primitive\" and has not been publicly released. Euphoria continued to be developed and released by Craig via his company Rapid Deployment Software (RDS) and website rapideuphoria.com. In October 2006 RDS released version 3 of Euphoria and announced that henceforth Euphoria would be freely distributed under an open-source software licence.\n\nRDS continued to develop Euphoria, culminating with the release of version 3.1.1 in August, 2007. Subsequently, RDS ceased unilateral development of Euphoria and the openEuphoria Group took over ongoing development. The openEuphoria Group released version 4 in December, 2010 along with a new logo and mascot for the openEuphoria project.\n\nVersion 3.1.1 remains an important milestone release, being the last version of Euphoria which supports the DOS platform.\n\nEuphoria is an acronym for End-User Programming with Hierarchical Objects for Robust Interpreted Applications although there is some suspicion that this is a backronym.\n\nThe Euphoria interpreter was originally written in C. With the release of version 2.5 in November 2004 the Euphoria interpreter was split into two parts: a front-end parser, and a back-end interpreter. The front-end is now written in Euphoria (and used with the Euphoria-to-C translator and the Binder). The main back-end and run time library are written in C.\n\nFeatures\n\nEuphoria was conceived and developed with the following design goals and features:\n\n* Ease of learning and with consistent high-level constructs (more so than e.g., the BASIC language)\n* Implementation of flat-form 32-bit memory to avoid complex memory management and size-addressing limits\n* Debugging support and run-time error-handling\n* Subscript and type checking\n* Loose and strict variable typing\n* Programming via objects as types (user-defined or otherwise)\n* Interpreted, with automatic memory management and garbage collection\n* Heterogeneous collection types (sequences)\n* DOS graphics library (Euphoria language versions up to and including 3.1.1)\n* Debugger\n* Integrated database system\n* Low-level memory handling\n* Straightforward wrapping of (or access to) C libraries\n\nExecution modes\n\n* Interpreter\n* C translator (E2C) for standalone executables or dynamic linking\n* Bytecode compiler and interpreter (shrouder)\n* The Binder binds the Euphoria source code to the interpreter to create an executable.\n* A read–eval–print loop (REPL) version is on the openEuphoria roadmap.\n\nUse\n\nEuphoria is designed to readily facilitate handling of dynamic sets of data of varying types and is particularly useful for string and image processing. Euphoria has been used in artificial intelligence experiments, the study of mathematics, for teaching programming, and to implement fonts involving thousands of characters. A large part of the Euphoria interpreter is written in Euphoria.\n\nData types\n\nEuphoria has two basic data types:\nAtom – A number, implemented as a 31-bit signed integer or a 64-bit IEEE floating-point. Euphoria dynamically changes between integer and floating point representation according to the current value.\nSequence – A vector (array) with zero or more elements. Each element may be an atom or another sequence. The number of elements in a sequence is not fixed (i.e., the size of the vector/array does not have to be declared). The program may add or remove elements as needed during run-time. Memory allocation-deallocation is automatically handled by reference counting. Individual elements are referenced using an index value enclosed in square brackets. The first element in a sequence has an index of one [1]. Elements inside embedded sequences are referenced by additional bracked index values, thus X[3][2] refers to the second element contained in the sequence that is the third element of X. Each element of a sequence is an object type (see below).\n\nEuphoria has two additional data types predefined:\nInteger – An atom, restricted to 31-bit signed integer values in the range -1073741824 to 1073741823 (-2^30 to 2^30-1). Integer data types are more efficient than the atom data types, but cannot contain the same range of values. Characters are stored as integers, e.g., coding ASCII-'A' is exactly the same as coding 65.\nObject – A generic datatype which may contain any of the above (i.e., atom, sequence or integer) and which may be changed to another type during run-time.\n\nThere is no character string data type. Strings are represented by a sequence of integer values. However, because literal strings are so commonly used in programming, Euphoria interprets double-quote enclosed characters as a sequence of integers. Thus\n \"ABC\"\nis seen as if the coder had written:\n {'A', 'B', 'C'}\nwhich is the same as:\n {65, 66, 67}\n\nHello, World!\n\n puts(1, \"Hello, World!\\n\")\n\nExamples\n\nProgram comments start with a double hyphen -- and go through the end of line.\n\nThe following code looks for an old item in a group of items. If found, it removes it by concatenating all the elements before it with all the elements after it. Note that the first element in a sequence has the index one [1] and that $ refers to the length (i.e., total number of elements) of the sequence.\n\n global function delete_item( object old, sequence group )\n    integer pos\n              -- Code begins --\n    pos find( old, group )\n    if pos > 0 then\n        group = group[1 .. pos-1] & group[pos+1 .. $]\n    end if\n    return group\n end function\n\nThe following modification to the above example replaces an old item with a new item. As the variables old and new have been defined as objects, they could be atoms or sequences. Type checking is not needed as the function will work with any sequence of data of any type and needs no external libraries.\n\n global function replace_item( object old, object new, sequence group )\n    integer pos\n              -- Code begins --\n    pos find( old, group )\n    if pos > 0 then\n        group[pos] = new\n    end if\n    return group\n end function\n\nFurthermore, no pointers are involved and subscripts are automatically checked. Thus the function cannot access memory out-of-bounds. There is no need to allocate or deallocate memory explicitly and no chance of a memory leak.\n\nThe line\n\n group = group[1 .. pos-1] & group[pos+1 .. $]\n\nshows some of the sequence handling facilities. A sequence may contain a set of any types, and this can be sliced (to take a subset of the data in a sequence) and concatenated in expressions with no need for special functions.\n\nParameter passing\n\nArguments to routines are always passed by value; there is no pass-by-reference facility. However, parameters are allowed to be modified locally (i.e., within the callee) which is implemented very efficiently as sequences have automatic copy-on-write semantics. In other words, when you pass a sequence to a routine, initially only a reference to it is passed, but at the point the routine modifies this sequence parameter the sequence is copied and the routine updates only a copy of the original.\n\nComparable languages\n\n* Lua\n* [http://phix.x10.mx Phix]\n* Python\n* REBOL\n* Ruby. Euphoria (programming language). http://en.wikipedia.org/?curid=9647."
  }
}
