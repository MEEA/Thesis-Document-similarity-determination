{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=9685",
  "eid" : "f11a6cd0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778484253,
  "textBody" : "In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in abbreviated, more legible form in a journal).\n\nEarley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case {O}(n^3), where n is the length of the parsed string, quadratic time for unambiguous grammars {O}(n^2), p.145 and linear time for almost all LR(k) grammars. It performs particularly well when the rules are written left-recursively.\n\nEarley recogniser \n\nThe following algorithm describes the Earley recogniser. The recogniser can be easily modified to create a parse tree as it recognises, and in that way can be turned into a parser.\n\nThe algorithm \n\nIn the following descriptions, α, β, and γ represent any string of terminals/nonterminals (including the empty string), X and Y represent single nonterminals, and a represents a terminal symbol.\n\nEarley's algorithm is a top-down dynamic programming algorithm. In the following, we use Earley's dot notation: given a production X → αβ, the notation X → α • β represents a condition in which α has already been parsed and β is expected.\n\nInput position 0 is the position prior to input.  Input position n is the position after accepting the nth token.  (Informally, input positions can be thought of as locations at token boundaries.)  For every input position, the parser generates a state set.  Each state is a tuple (X → α • β, i), consisting of\n\n* the production currently being matched (X → α β)\n* our current position in that production (represented by the dot)\n* the position i in the input at which the matching of this production began: the origin position\n\n(Earley's original algorithm included a look-ahead in the state; later research showed this to have little practical effect on the parsing efficiency, and it has subsequently been dropped from most implementations.)\n\nThe state set at input position k is called S(k).  The parser is seeded with S(0) consisting of only the top-level rule.  The parser then repeatedly executes three operations:  prediction, scanning, and completion.\n\n* Prediction:  For every state in S(k) of the form (X → α • Y β, j) (where j is the origin position as above), add (Y → • γ, k) to S(k) for every production in the grammar with Y on the left-hand side (Y → γ).\n* Scanning: If a is the next symbol in the input stream, for every state in S(k) of the form (X → α • a β, j), add (X → α a • β, j) to S(k+1).\n* Completion: For every state in S(k) of the form (X → γ •, j), find states in S(j) of the form (Y → α • X β, i) and add (Y → α X • β, i) to S(k).\n\nIt is important to note that duplicate states are not added to the state set, only new ones.  These three operations are repeated until no new states can be added to the set.  The set is generally implemented as a queue of states to process, with the operation to be performed depending on what kind of state it is.\n\nThe algorithm accepts if (X → γ •, 0) ends up in S(n), where (X → γ) is the top level-rule and n the input length, otherwise it rejects.\n\nPseudocode \n\nAdapted from Speech and Language Processing by Daniel Jurafsky and James H. Martin, \n\nDECLARE ARRAY S;\n\nfunction INIT(words)\n    S ← CREATE-ARRAY(LENGTH(words))\n    for k ← from 0 to LENGTH(words) do\n        S[k] ← EMPTY-ORDERED-SET\n\nfunction EARLEY-PARSE(words, grammar)\n    INIT(words)\n    ADD-TO-SET((γ → •S, 0), S[0])\n    for k ← from 0 to LENGTH(words) do\n        for each state in S[k] do  // S[k] can expand during this loop\n            if not FINISHED(state) then\n                if NEXT-ELEMENT-OF(state) is a nonterminal then\n                    PREDICTOR(state, k, grammar)         // non-terminal\n                else do\n                    SCANNER(state, k, words)             // terminal\n            else do\n                COMPLETER(state, k)\n        end\n    end\n    return chart\n\nprocedure PREDICTOR((A → α•Bβ, j), k, grammar)\n    for each (B → γ) in GRAMMAR-RULES-FOR(B, grammar) do\n        ADD-TO-SET((B → •γ, k), S[k])\n    end\n\nprocedure SCANNER((A → α•aβ, j), k, words)\n    if a ⊂ PARTS-OF-SPEECH(words[k]) then\n        ADD-TO-SET((A → αa•β, j), S[k+1])\n    end\n\nprocedure COMPLETER((B → γ•, x), k)\n    for each (A → α•Bβ, j) in S[x] do\n        ADD-TO-SET((A → αB•β, j), S[k])\n    end\n\nExample \n\nConsider the following simple grammar for arithmetic expressions:\n\n ::=       # the start rule\n ::=  \"+\"  | \n ::=  \"*\"  | \n ::= \"1\" | \"2\" | \"3\" | \"4\"\n\nWith the input:\n 2 + 3 * 4\n\nThis is the sequence of state sets:\n\nThe state (P → S •, 0) represents a completed parse.  This state also appears in S(3) and S(1), which are complete sentences.\n\nConstructing the parse forest \n\nEarley's dissertation briefly describes an algorithm for constructing parse trees by adding a set of pointers from each non-terminal in an Earley item back to the items that caused it to be recognized.  But Tomita noticed that this does not take into account the relations between symbols, so if we consider the grammar S → SS | b and the string bbb, it only notes that each S can match one or two b's, and thus produces spurious derivations for bb and bbbb as well as the two correct derivations for bbb.\n\nAnother method is to build the parse forest as you go, augmenting each Earley item with a pointer to a shared packed parse forest (SPPF) node labelled with a triple (s, i, j) where s is a symbol or an LR(0) item (production rule with dot), and i and j give the section of the input string derived by this node. A node's contents are either a pair of child pointers giving a single derivation, or a list of \"packed\" nodes each containing a pair of pointers and representing one derivation.  SPPF nodes are unique (there is only one with a given label), but may contain more than one derivation for ambiguous parses.  So even if an operation does not add an Earley item (because it already exists), it may still add a derivation to the item's parse forest.\n\n* Predicted items have a null SPPF pointer.\n* The scanner creates an SPPF node representing the non-terminal it is scanning.\n* Then when the scanner or completer advance an item, they add a derivation whose children are the node from the item whose dot was advanced, and the one for the new symbol that was advanced over (the non-terminal or completed item).\n\nNote also that SPPF nodes are never labeled with a completed LR(0) item: instead they are labelled with the symbol that is produced so that all derivations are combined under one node regardless of which alternative production they come from.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Earley parser" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=9685" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In computer science, the Earley parser is an algorithm for parsing strings that belong to a given context-free language, though (depending on the variant) it may suffer problems with certain nullable grammars. The algorithm, named after its inventor, Jay Earley, is a chart parser that uses dynamic programming; it is mainly used for parsing in computational linguistics. It was first introduced in his dissertation in 1968 (and later appeared in abbreviated, more legible form in a journal).\n\nEarley parsers are appealing because they can parse all context-free languages, unlike LR parsers and LL parsers, which are more typically used in compilers but which can only handle restricted classes of languages.  The Earley parser executes in cubic time in the general case {O}(n^3), where n is the length of the parsed string, quadratic time for unambiguous grammars {O}(n^2), p.145 and linear time for almost all LR(k) grammars. It performs particularly well when the rules are written left-recursively.\n\nEarley recogniser \n\nThe following algorithm describes the Earley recogniser. The recogniser can be easily modified to create a parse tree as it recognises, and in that way can be turned into a parser.\n\nThe algorithm \n\nIn the following descriptions, α, β, and γ represent any string of terminals/nonterminals (including the empty string), X and Y represent single nonterminals, and a represents a terminal symbol.\n\nEarley's algorithm is a top-down dynamic programming algorithm. In the following, we use Earley's dot notation: given a production X → αβ, the notation X → α • β represents a condition in which α has already been parsed and β is expected.\n\nInput position 0 is the position prior to input.  Input position n is the position after accepting the nth token.  (Informally, input positions can be thought of as locations at token boundaries.)  For every input position, the parser generates a state set.  Each state is a tuple (X → α • β, i), consisting of\n\n* the production currently being matched (X → α β)\n* our current position in that production (represented by the dot)\n* the position i in the input at which the matching of this production began: the origin position\n\n(Earley's original algorithm included a look-ahead in the state; later research showed this to have little practical effect on the parsing efficiency, and it has subsequently been dropped from most implementations.)\n\nThe state set at input position k is called S(k).  The parser is seeded with S(0) consisting of only the top-level rule.  The parser then repeatedly executes three operations:  prediction, scanning, and completion.\n\n* Prediction:  For every state in S(k) of the form (X → α • Y β, j) (where j is the origin position as above), add (Y → • γ, k) to S(k) for every production in the grammar with Y on the left-hand side (Y → γ).\n* Scanning: If a is the next symbol in the input stream, for every state in S(k) of the form (X → α • a β, j), add (X → α a • β, j) to S(k+1).\n* Completion: For every state in S(k) of the form (X → γ •, j), find states in S(j) of the form (Y → α • X β, i) and add (Y → α X • β, i) to S(k).\n\nIt is important to note that duplicate states are not added to the state set, only new ones.  These three operations are repeated until no new states can be added to the set.  The set is generally implemented as a queue of states to process, with the operation to be performed depending on what kind of state it is.\n\nThe algorithm accepts if (X → γ •, 0) ends up in S(n), where (X → γ) is the top level-rule and n the input length, otherwise it rejects.\n\nPseudocode \n\nAdapted from Speech and Language Processing by Daniel Jurafsky and James H. Martin, \n\nDECLARE ARRAY S;\n\nfunction INIT(words)\n    S ← CREATE-ARRAY(LENGTH(words))\n    for k ← from 0 to LENGTH(words) do\n        S[k] ← EMPTY-ORDERED-SET\n\nfunction EARLEY-PARSE(words, grammar)\n    INIT(words)\n    ADD-TO-SET((γ → •S, 0), S[0])\n    for k ← from 0 to LENGTH(words) do\n        for each state in S[k] do  // S[k] can expand during this loop\n            if not FINISHED(state) then\n                if NEXT-ELEMENT-OF(state) is a nonterminal then\n                    PREDICTOR(state, k, grammar)         // non-terminal\n                else do\n                    SCANNER(state, k, words)             // terminal\n            else do\n                COMPLETER(state, k)\n        end\n    end\n    return chart\n\nprocedure PREDICTOR((A → α•Bβ, j), k, grammar)\n    for each (B → γ) in GRAMMAR-RULES-FOR(B, grammar) do\n        ADD-TO-SET((B → •γ, k), S[k])\n    end\n\nprocedure SCANNER((A → α•aβ, j), k, words)\n    if a ⊂ PARTS-OF-SPEECH(words[k]) then\n        ADD-TO-SET((A → αa•β, j), S[k+1])\n    end\n\nprocedure COMPLETER((B → γ•, x), k)\n    for each (A → α•Bβ, j) in S[x] do\n        ADD-TO-SET((A → αB•β, j), S[k])\n    end\n\nExample \n\nConsider the following simple grammar for arithmetic expressions:\n\n ::=       # the start rule\n ::=  \"+\"  | \n ::=  \"*\"  | \n ::= \"1\" | \"2\" | \"3\" | \"4\"\n\nWith the input:\n 2 + 3 * 4\n\nThis is the sequence of state sets:\n\nThe state (P → S •, 0) represents a completed parse.  This state also appears in S(3) and S(1), which are complete sentences.\n\nConstructing the parse forest \n\nEarley's dissertation briefly describes an algorithm for constructing parse trees by adding a set of pointers from each non-terminal in an Earley item back to the items that caused it to be recognized.  But Tomita noticed that this does not take into account the relations between symbols, so if we consider the grammar S → SS | b and the string bbb, it only notes that each S can match one or two b's, and thus produces spurious derivations for bb and bbbb as well as the two correct derivations for bbb.\n\nAnother method is to build the parse forest as you go, augmenting each Earley item with a pointer to a shared packed parse forest (SPPF) node labelled with a triple (s, i, j) where s is a symbol or an LR(0) item (production rule with dot), and i and j give the section of the input string derived by this node. A node's contents are either a pair of child pointers giving a single derivation, or a list of \"packed\" nodes each containing a pair of pointers and representing one derivation.  SPPF nodes are unique (there is only one with a given label), but may contain more than one derivation for ambiguous parses.  So even if an operation does not add an Earley item (because it already exists), it may still add a derivation to the item's parse forest.\n\n* Predicted items have a null SPPF pointer.\n* The scanner creates an SPPF node representing the non-terminal it is scanning.\n* Then when the scanner or completer advance an item, they add a derivation whose children are the node from the item whose dot was advanced, and the one for the new symbol that was advanced over (the non-terminal or completed item).\n\nNote also that SPPF nodes are never labeled with a completed LR(0) item: instead they are labelled with the symbol that is produced so that all derivations are combined under one node regardless of which alternative production they come from. Earley parser. http://en.wikipedia.org/?curid=9685."
  }
}
