{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=9646",
  "eid" : "f0c43680-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778483688,
  "textBody" : "Erlang ( ) is a general-purpose, concurrent, functional programming language, as well as a garbage-collected runtime system.\n\nThe term Erlang is used interchangeably with Erlang/OTP, or OTP, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang, and a set of design principles for Erlang programs.http://erlang.org/doc/system_architecture_intro/sys_arch_intro.html#id58791\n\nThe Erlang runtime system is known for its designs that are well suited for systems with the following characteristics:\n\n*Distributed\n*Fault-tolerant\n*Soft real-time, \n*Highly available, non-stop applications\n*Hot swapping, where code can be changed without stopping a system.\n\nThe Erlang programming language is known for the following properties:Hitchhiker’s Tour of the\nBEAM – Robert Virding http://www.erlang-factory.com/upload/presentations/708/HitchhikersTouroftheBEAM.pdf\n\n* Immutable data\n* Pattern matching\n* Functional programming\n\nThe sequential subset of the Erlang language supports eager evaluation, single assignment, and dynamic typing.\n\nIt was originally a proprietary language within Ericsson, developed by Joe Armstrong, Robert Virding and Mike Williams in 1986,Joe Armstrong, \"History of Erlang\", in HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages, 2007,  but was released as open source in 1998. Erlang/OTP is supported and maintained by the OTP product unit at Ericsson.\n\nHistory\n\nThe name \"Erlang\", attributed to Bjarne Däcker, has been presumed by those working on the telephony switches (for whom the language was designed) to be a reference to Danish mathematician and engineer Agner Krarup Erlang as well as a syllabic abbreviation of \"Ericsson Language\".\n\nErlang was designed with the aim of improving the development of telephony applications. The initial version of Erlang was implemented in Prolog and was influenced by the programming language PLEX used in earlier Ericsson exchanges. By 1988 Erlang had proven that it was suitable for prototyping telephone exchanges, but the Prolog interpreter was far too slow. One group within Ericsson estimated that it would need to be 40 times faster in order to be suitable for production use. In 1992 work began on the BEAM virtual machine which compiles Erlang to C using a mix of natively compiled code and threaded code to strike a balance between performance and disk space. According to Armstrong, the language went from lab product to real applications following the collapse of the next-generation AXE exchange named AXE-N in 1995. As a result, Erlang was chosen for the next ATM exchange AXD.\n\nIn 1998 Ericsson announced the AXD301 switch, containing over a million lines of Erlang and reported to achieve a high availability of nine \"9\"s.\n\n Shortly thereafter, Ericsson Radio Systems banned the in-house use of Erlang for new products, citing a preference for non-proprietary languages. The ban caused Armstrong and others to leave Ericsson. The implementation was open-sourced at the end of the year. Ericsson eventually lifted the ban; it re-hired Armstrong in 2004.\n\nIn 2006, native symmetric multiprocessing support was added to the runtime system and virtual machine.\n\nErlang Worldview\n\nThe Erlang view of the world, as Joe Armstrong, co-inventor of Erlang, summarized in his PhD thesis:http://erlang.org/download/armstrong_thesis_2003.pdf\n\n*Everything is a process.\n*Processes are strongly isolated.\n*Process creation and destruction is a lightweight operation.\n*Message passing is the only way for processes to interact.\n*Processes have unique names.\n*If you know the name of a process you can send it a message.\n*Processes share no resources.\n*Error handling is non-local.\n*Processes do what they are supposed to do or fail.\n\nJoe Armstrong remarked in an interview with Rackspace in 2013: “If Java is 'write once, run anywhere', then Erlang is 'write once, run forever'.”\n\nUsage\n\nErlang has now been adopted by companies worldwide, including Nortel and T-Mobile. Erlang is used in Ericsson’s support nodes, and in GPRS, 3G and LTE mobile networks worldwide.\n\nAs Tim Bray, director of Web Technologies at Sun Microsystems, expressed in his keynote at OSCON in July 2008:\n\nFunctional programming examples\n\nAn Erlang function that uses recursion to count to ten:\n\n-module(count_to_ten).\n-export([count_to_ten/0]).\n \ncount_to_ten() -> do_count(0).\n \ndo_count(10) -> 10;\ndo_count(N) -> do_count(N + 1).\n\nA factorial algorithm implemented in Erlang:\n\n-module(fact).    % This is the file 'fact.erl', the module and the filename must match\n-export([fac/1]). % This exports the function 'fac' of arity 1 (1 parameter, no type, no name)\n\nfac(0) -> 1; % If 0, then return 1, otherwise (note the semicolon ; meaning 'else')\nfac(N) when N > 0, is_integer(N) -> N * fac(N-1).\n% Recursively determine, then return the result\n% (note the period . meaning 'endif' or 'function end')\n%% This function will crash if anything other than a nonnegative integer is given.\n%% It illustrates the \"Let it crash\" philosophy of Erlang.\n\nA Fibonacci algorithm implemented in Erlang (Note: This is only for demonstrating the Erlang syntax. This algorithm is rather slow.):\n\n-module(fibonacci).    % This is the file 'fibonacci.erl', the module and the filename must match\n-export([fib/1]). % This exports the function 'fib' of arity 1\n\nfib(0) -> 0; % If 0, then return 0, otherwise (note the semicolon ; meaning 'else')\nfib(1) -> 1; % If 1, then return 1, otherwise\nfib(N) when N > 1 -> fib(N - 1) + fib(N - 2). \n\nQuicksort in Erlang, using list comprehension:http://erlang.org/doc/programming_examples/list_comprehensions.html\n\n%% qsort:qsort(List)\n%% Sort a list of items\n-module(qsort).     % This is the file 'qsort.erl'\n-export([qsort/1]). % A function 'qsort' with 1 parameter is exported (no type, no name)\n\nqsort([]) -> []; % If the list [] is empty, return an empty list (nothing to sort)\nqsort([Pivot|Rest]) ->\n    % Compose recursively a list with 'Front' for all elements that should be before 'Pivot'\n    % then 'Pivot' then 'Back' for all elements that should be after 'Pivot'\n    qsort([Front || Front = Pivot]).\n\nThe above example recursively invokes the function qsort until nothing remains to be sorted. The expression [Front || Front  is a list comprehension, meaning \"Construct a list of elements Front such that Front is a member of Rest, and Front is less than Pivot.\" ++ is the list concatenation operator.\n\nA comparison function can be used for more complicated structures for the sake of readability.\n\nThe following code would sort lists according to length:\n\n% This is file 'listsort.erl' (the compiler is made this way)\n-module(listsort).\n% Export 'by_length' with 1 parameter (don't care about the type and name)\n-export([by_length/1]).\n\nby_length(Lists) -> % Use 'qsort/2' and provides an anonymous function as a parameter\n   qsort(Lists, fun(A,B) -> length(A)  []; % If list is empty, return an empty list (ignore the second parameter)\nqsort([Pivot|Rest], Smaller) ->\n    % Partition list with 'Smaller' elements in front of 'Pivot' and not-'Smaller' elements\n    % after 'Pivot' and sort the sublists.\n    qsort([X || X \n\nHere again, a Pivot is taken from the first parameter given to qsort() and the rest of Lists is named Rest. Note that the expression\n\n[X || X \n\nis no different in form from\n\n[Front || Front \n\n(in the previous example) except for the use of a comparison function in the last part, saying \"Construct a list of elements X such that X is a member of Rest, and Smaller is true\", with Smaller being defined earlier as\n\nfun(A,B) -> length(A) \n\nNote also that the anonymous function is named Smaller in the parameter list of the second definition of qsort so that it can be referenced by that name within that function. It is not named in the first definition of qsort, which deals with the base case of an empty list and thus has no need of this function, let alone a name for it.\n\nData types\n\nErlang has eight primitive data types:\n\n;Integers: Integers are written as sequences of decimal digits, for example, 12, 12375 and -23427 are integers. Integer arithmetic is exact and only limited by available memory on the machine. (This is called arbitrary-precision arithmetic.)\n;Atoms: Atoms are used within a program to denote distinguished values. They are written as strings of consecutive alphanumeric characters, the first character being lowercase. Atoms can contain any character if they are enclosed within single quotes and an escape convention exists which allows any character to be used within an atom.\n;Floats: Floating point numbers use the IEEE 754 64-bit representation.\n;References: References are globally unique symbols whose only property is that they can be compared for equality. They are created by evaluating the Erlang primitive make_ref().\n;Binaries: A binary is a sequence of bytes. Binaries provide a space-efficient way of storing binary data. Erlang primitives exist for composing and decomposing binaries and for efficient input/output of binaries.\n;Pids: Pid is short for process identifiera Pid is created by the Erlang primitive spawn(...) Pids are references to Erlang processes.\n;Ports: Ports are used to communicate with the external world. Ports are created with the built-in function open_port. Messages can be sent to and received from ports, but these messages must obey the so-called \"port protocol.\"\n;Funs: Funs are function closures. Funs are created by expressions of the form: fun(...) -> ... end.\n\nAnd three compound data types:\n\n;Tuples: Tuples are containers for a fixed number of Erlang data types. The syntax {D1,D2,...,Dn} denotes a tuple whose arguments are D1, D2, ... Dn. The arguments can be primitive data types or compound data types. Any element of a tuple can be accessed in constant time.\n;Lists: Lists are containers for a variable number of Erlang data types. The syntax [Dh|Dt] denotes a list whose first element is Dh, and whose remaining elements are the list Dt. The syntax [] denotes an empty list. The syntax [D1,D2,..,Dn] is short for [D1|[D2|..|[Dn|[. The first element of a list can be accessed in constant time. The first element of a list is called the head of the list. The remainder of a list when its head has been removed is called the tail of the list.\n;Maps: Maps contain a variable number of key-value associations. The syntax is#{Key1>Value1,...,KeyN\n>ValueN}.\n\nTwo forms of syntactic sugar are provided:\n\n;Strings: Strings are written as doubly quoted lists of characters. This is syntactic sugar for a list of the integer ASCII codes for the characters in the string. Thus, for example, the string \"cat\" is shorthand for [99,97,116]. It has partial support for Unicode strings.\n;Records: Records provide a convenient way for associating a tag with each of the elements in a tuple. This allows one to refer to an element of a tuple by name and not by position. A pre-compiler takes the record definition and replaces it with the appropriate tuple reference.\n\nErlang has no method of defining classes, although there are external libraries available.\n\nConcurrency and distribution orientation\n\nErlang's main strength is support for concurrency. It has a small but powerful set of primitives to create processes and communicate among them. Erlang is conceptually similar to the occam programming language, though it recasts the ideas of communicating sequential processes (CSP) in a functional framework and uses asynchronous message passing. Processes are the primary means to structure an Erlang application.  They are neither operating system processes nor operating system threads, but lightweight processes that are scheduled by Erlang's BEAM VM. Like operating system processes (but unlike operating system threads), they share no state with each other. The estimated minimal overhead for each is 300 words. Thus, many processes can be created without degrading performance. A benchmark with 20 million processes has been successfully performed. Erlang has supported symmetric multiprocessing since release R11B of May 2006.\n\nWhile threads require external library support in most languages, Erlang provides language-level features for creating and managing processes with the aim of simplifying concurrent programming. Though all concurrency is explicit in Erlang, processes communicate using message passing instead of shared variables, which removes the need for explicit locks (a locking scheme is still used internally by the VM).\n\nInter-process communication works via a shared-nothing asynchronous message passing system: every process has a \"mailbox\", a queue of messages that have been sent by other processes and not yet consumed. A process uses the receive primitive to retrieve messages that match desired patterns. A message-handling routine tests messages in turn against each pattern, until one of them matches. When the message is consumed and removed from the mailbox the process resumes execution. A message may comprise any Erlang structure, including primitives (integers, floats, characters, atoms), tuples, lists, and functions.\n\nThe code example below shows the built-in support for distributed processes:\n\n % Create a process and invoke the function web:start_server(Port, MaxConnections)\n ServerProcess = spawn(web, start_server, [Port, MaxConnections]),\n\n % Create a remote process and invoke the function\n % web:start_server(Port, MaxConnections) on machine RemoteNode\n RemoteProcess = spawn(RemoteNode, web, start_server, [Port, MaxConnections]),\n\n % Send a message to ServerProcess (asynchronously). The message consists of a tuple\n % with the atom \"pause\" and the number \"10\".\n ServerProcess ! {pause, 10},\n\n % Receive messages sent to this process\n receive\n         a_message -> do_something;\n         {data, DataContent} -> handle(DataContent);\n         {hello, Text} -> io:format(\"Got hello message: ~s\", [Text]);\n         {goodbye, Text} -> io:format(\"Got goodbye message: ~s\", [Text])\n end.\n\nAs the example shows, processes may be created on remote nodes, and communication with them is transparent in the sense that communication with remote processes works exactly as communication with local processes.\n\nConcurrency supports the primary method of error-handling in Erlang. When a process crashes, it neatly exits and sends a message to the controlling process which can then take action, such as for instance starting a new process that takes over the old process's task.\n\nImplementation\n\nThe official reference implementation of Erlang is called BEAM. It is included in the official distribution of Erlang, which is called Erlang/OTP. BEAM loads virtual machine bytecode which is converted to threaded code at load time. It also includes a native code compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at Uppsala University. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system. It also supports interpreting, directly from source code via abstract syntax tree, via script as of R11B-5 release of Erlang.\n\nHot code loading and modules\n\nErlang supports language-level Dynamic Software Updating. To implement this, code is loaded and managed as \"module\" units; the module is a compilation unit. The system can keep two versions of a module in memory at the same time, and processes can concurrently run code from each. The versions are referred to as the \"new\" and the \"old\" version. A process will not move into the new version until it makes an external call to its module.\n\nAn example of the mechanism of hot code loading:\n\n  %% A process whose only job is to keep a counter.\n  %% First version\n  -module(counter).\n  -export([start/0, codeswitch/1]).\n\n  start() -> loop(0).\n\n  loop(Sum) ->\n    receive\n       {increment, Count} ->\n          loop(Sum+Count);\n       {counter, Pid} ->\n          Pid ! {counter, Sum},\n          loop(Sum);\n       code_switch ->\n          ?MODULE:codeswitch(Sum)\n          % Force the use of 'codeswitch/1' from the latest MODULE version\n    end.\n\n  codeswitch(Sum) -> loop(Sum).\n\nFor the second version, we add the possibility to reset the count to zero.\n\n  %% Second version\n  -module(counter).\n  -export([start/0, codeswitch/1]).\n\n  start() -> loop(0).\n\n  loop(Sum) ->\n    receive\n       {increment, Count} ->\n          loop(Sum+Count);\n       reset ->\n          loop(0);\n       {counter, Pid} ->\n          Pid ! {counter, Sum},\n          loop(Sum);\n       code_switch ->\n          ?MODULE:codeswitch(Sum)\n    end.\n\n  codeswitch(Sum) -> loop(Sum).\n\nOnly when receiving a message consisting of the atom 'code_switch' will the loop execute an external call to codeswitch/1 (?MODULE is a preprocessor macro for the current module). If there is a new version of the \"counter\" module in memory, then its codeswitch/1 function will be called. The practice of having a specific entry-point into a new version allows the programmer to transform state to what is required in the newer version. In our example we keep the state as an integer.\n\nIn practice, systems are built up using design principles from the Open Telecom Platform which leads to more code upgradable designs. Successful hot code loading is a tricky subject; Code needs to be written with care to make use of Erlang's facilities.\n\nDistribution\n\nIn 1998, Ericsson released Erlang as open source to ensure its independence from a single vendor and to increase awareness of the language. Erlang, together with libraries and the real-time distributed database Mnesia, forms the Open Telecom Platform (OTP) collection of libraries. Ericsson and a few other companies offer commercial support for Erlang.\n\nSince the open source release, Erlang has been used by several firms worldwide, including Nortel and T-Mobile. Although Erlang was designed to fill a niche and has remained an obscure language for most of its existence, its popularity is growing due to demand for concurrent services.\nErlang has found some use in fielding MMORPG servers.\n\nVariants\n\n* Elixir: a functional, concurrent, general-purpose programming language that runs on the Erlang Virtual Machine (BEAM).\n* Lisp Flavored Erlang:  a LISP based programming language that runs on the Erlang Virtual Machine (BEAM).",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Erlang (programming language)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=9646" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Erlang ( ) is a general-purpose, concurrent, functional programming language, as well as a garbage-collected runtime system.\n\nThe term Erlang is used interchangeably with Erlang/OTP, or OTP, which consists of the Erlang runtime system, a number of ready-to-use components mainly written in Erlang, and a set of design principles for Erlang programs.http://erlang.org/doc/system_architecture_intro/sys_arch_intro.html#id58791\n\nThe Erlang runtime system is known for its designs that are well suited for systems with the following characteristics:\n\n*Distributed\n*Fault-tolerant\n*Soft real-time, \n*Highly available, non-stop applications\n*Hot swapping, where code can be changed without stopping a system.\n\nThe Erlang programming language is known for the following properties:Hitchhiker’s Tour of the\nBEAM – Robert Virding http://www.erlang-factory.com/upload/presentations/708/HitchhikersTouroftheBEAM.pdf\n\n* Immutable data\n* Pattern matching\n* Functional programming\n\nThe sequential subset of the Erlang language supports eager evaluation, single assignment, and dynamic typing.\n\nIt was originally a proprietary language within Ericsson, developed by Joe Armstrong, Robert Virding and Mike Williams in 1986,Joe Armstrong, \"History of Erlang\", in HOPL III: Proceedings of the third ACM SIGPLAN conference on History of programming languages, 2007,  but was released as open source in 1998. Erlang/OTP is supported and maintained by the OTP product unit at Ericsson.\n\nHistory\n\nThe name \"Erlang\", attributed to Bjarne Däcker, has been presumed by those working on the telephony switches (for whom the language was designed) to be a reference to Danish mathematician and engineer Agner Krarup Erlang as well as a syllabic abbreviation of \"Ericsson Language\".\n\nErlang was designed with the aim of improving the development of telephony applications. The initial version of Erlang was implemented in Prolog and was influenced by the programming language PLEX used in earlier Ericsson exchanges. By 1988 Erlang had proven that it was suitable for prototyping telephone exchanges, but the Prolog interpreter was far too slow. One group within Ericsson estimated that it would need to be 40 times faster in order to be suitable for production use. In 1992 work began on the BEAM virtual machine which compiles Erlang to C using a mix of natively compiled code and threaded code to strike a balance between performance and disk space. According to Armstrong, the language went from lab product to real applications following the collapse of the next-generation AXE exchange named AXE-N in 1995. As a result, Erlang was chosen for the next ATM exchange AXD.\n\nIn 1998 Ericsson announced the AXD301 switch, containing over a million lines of Erlang and reported to achieve a high availability of nine \"9\"s.\n\n Shortly thereafter, Ericsson Radio Systems banned the in-house use of Erlang for new products, citing a preference for non-proprietary languages. The ban caused Armstrong and others to leave Ericsson. The implementation was open-sourced at the end of the year. Ericsson eventually lifted the ban; it re-hired Armstrong in 2004.\n\nIn 2006, native symmetric multiprocessing support was added to the runtime system and virtual machine.\n\nErlang Worldview\n\nThe Erlang view of the world, as Joe Armstrong, co-inventor of Erlang, summarized in his PhD thesis:http://erlang.org/download/armstrong_thesis_2003.pdf\n\n*Everything is a process.\n*Processes are strongly isolated.\n*Process creation and destruction is a lightweight operation.\n*Message passing is the only way for processes to interact.\n*Processes have unique names.\n*If you know the name of a process you can send it a message.\n*Processes share no resources.\n*Error handling is non-local.\n*Processes do what they are supposed to do or fail.\n\nJoe Armstrong remarked in an interview with Rackspace in 2013: “If Java is 'write once, run anywhere', then Erlang is 'write once, run forever'.”\n\nUsage\n\nErlang has now been adopted by companies worldwide, including Nortel and T-Mobile. Erlang is used in Ericsson’s support nodes, and in GPRS, 3G and LTE mobile networks worldwide.\n\nAs Tim Bray, director of Web Technologies at Sun Microsystems, expressed in his keynote at OSCON in July 2008:\n\nFunctional programming examples\n\nAn Erlang function that uses recursion to count to ten:\n\n-module(count_to_ten).\n-export([count_to_ten/0]).\n \ncount_to_ten() -> do_count(0).\n \ndo_count(10) -> 10;\ndo_count(N) -> do_count(N + 1).\n\nA factorial algorithm implemented in Erlang:\n\n-module(fact).    % This is the file 'fact.erl', the module and the filename must match\n-export([fac/1]). % This exports the function 'fac' of arity 1 (1 parameter, no type, no name)\n\nfac(0) -> 1; % If 0, then return 1, otherwise (note the semicolon ; meaning 'else')\nfac(N) when N > 0, is_integer(N) -> N * fac(N-1).\n% Recursively determine, then return the result\n% (note the period . meaning 'endif' or 'function end')\n%% This function will crash if anything other than a nonnegative integer is given.\n%% It illustrates the \"Let it crash\" philosophy of Erlang.\n\nA Fibonacci algorithm implemented in Erlang (Note: This is only for demonstrating the Erlang syntax. This algorithm is rather slow.):\n\n-module(fibonacci).    % This is the file 'fibonacci.erl', the module and the filename must match\n-export([fib/1]). % This exports the function 'fib' of arity 1\n\nfib(0) -> 0; % If 0, then return 0, otherwise (note the semicolon ; meaning 'else')\nfib(1) -> 1; % If 1, then return 1, otherwise\nfib(N) when N > 1 -> fib(N - 1) + fib(N - 2). \n\nQuicksort in Erlang, using list comprehension:http://erlang.org/doc/programming_examples/list_comprehensions.html\n\n%% qsort:qsort(List)\n%% Sort a list of items\n-module(qsort).     % This is the file 'qsort.erl'\n-export([qsort/1]). % A function 'qsort' with 1 parameter is exported (no type, no name)\n\nqsort([]) -> []; % If the list [] is empty, return an empty list (nothing to sort)\nqsort([Pivot|Rest]) ->\n    % Compose recursively a list with 'Front' for all elements that should be before 'Pivot'\n    % then 'Pivot' then 'Back' for all elements that should be after 'Pivot'\n    qsort([Front || Front = Pivot]).\n\nThe above example recursively invokes the function qsort until nothing remains to be sorted. The expression [Front || Front  is a list comprehension, meaning \"Construct a list of elements Front such that Front is a member of Rest, and Front is less than Pivot.\" ++ is the list concatenation operator.\n\nA comparison function can be used for more complicated structures for the sake of readability.\n\nThe following code would sort lists according to length:\n\n% This is file 'listsort.erl' (the compiler is made this way)\n-module(listsort).\n% Export 'by_length' with 1 parameter (don't care about the type and name)\n-export([by_length/1]).\n\nby_length(Lists) -> % Use 'qsort/2' and provides an anonymous function as a parameter\n   qsort(Lists, fun(A,B) -> length(A)  []; % If list is empty, return an empty list (ignore the second parameter)\nqsort([Pivot|Rest], Smaller) ->\n    % Partition list with 'Smaller' elements in front of 'Pivot' and not-'Smaller' elements\n    % after 'Pivot' and sort the sublists.\n    qsort([X || X \n\nHere again, a Pivot is taken from the first parameter given to qsort() and the rest of Lists is named Rest. Note that the expression\n\n[X || X \n\nis no different in form from\n\n[Front || Front \n\n(in the previous example) except for the use of a comparison function in the last part, saying \"Construct a list of elements X such that X is a member of Rest, and Smaller is true\", with Smaller being defined earlier as\n\nfun(A,B) -> length(A) \n\nNote also that the anonymous function is named Smaller in the parameter list of the second definition of qsort so that it can be referenced by that name within that function. It is not named in the first definition of qsort, which deals with the base case of an empty list and thus has no need of this function, let alone a name for it.\n\nData types\n\nErlang has eight primitive data types:\n\n;Integers: Integers are written as sequences of decimal digits, for example, 12, 12375 and -23427 are integers. Integer arithmetic is exact and only limited by available memory on the machine. (This is called arbitrary-precision arithmetic.)\n;Atoms: Atoms are used within a program to denote distinguished values. They are written as strings of consecutive alphanumeric characters, the first character being lowercase. Atoms can contain any character if they are enclosed within single quotes and an escape convention exists which allows any character to be used within an atom.\n;Floats: Floating point numbers use the IEEE 754 64-bit representation.\n;References: References are globally unique symbols whose only property is that they can be compared for equality. They are created by evaluating the Erlang primitive make_ref().\n;Binaries: A binary is a sequence of bytes. Binaries provide a space-efficient way of storing binary data. Erlang primitives exist for composing and decomposing binaries and for efficient input/output of binaries.\n;Pids: Pid is short for process identifiera Pid is created by the Erlang primitive spawn(...) Pids are references to Erlang processes.\n;Ports: Ports are used to communicate with the external world. Ports are created with the built-in function open_port. Messages can be sent to and received from ports, but these messages must obey the so-called \"port protocol.\"\n;Funs: Funs are function closures. Funs are created by expressions of the form: fun(...) -> ... end.\n\nAnd three compound data types:\n\n;Tuples: Tuples are containers for a fixed number of Erlang data types. The syntax {D1,D2,...,Dn} denotes a tuple whose arguments are D1, D2, ... Dn. The arguments can be primitive data types or compound data types. Any element of a tuple can be accessed in constant time.\n;Lists: Lists are containers for a variable number of Erlang data types. The syntax [Dh|Dt] denotes a list whose first element is Dh, and whose remaining elements are the list Dt. The syntax [] denotes an empty list. The syntax [D1,D2,..,Dn] is short for [D1|[D2|..|[Dn|[. The first element of a list can be accessed in constant time. The first element of a list is called the head of the list. The remainder of a list when its head has been removed is called the tail of the list.\n;Maps: Maps contain a variable number of key-value associations. The syntax is#{Key1>Value1,...,KeyN\n>ValueN}.\n\nTwo forms of syntactic sugar are provided:\n\n;Strings: Strings are written as doubly quoted lists of characters. This is syntactic sugar for a list of the integer ASCII codes for the characters in the string. Thus, for example, the string \"cat\" is shorthand for [99,97,116]. It has partial support for Unicode strings.\n;Records: Records provide a convenient way for associating a tag with each of the elements in a tuple. This allows one to refer to an element of a tuple by name and not by position. A pre-compiler takes the record definition and replaces it with the appropriate tuple reference.\n\nErlang has no method of defining classes, although there are external libraries available.\n\nConcurrency and distribution orientation\n\nErlang's main strength is support for concurrency. It has a small but powerful set of primitives to create processes and communicate among them. Erlang is conceptually similar to the occam programming language, though it recasts the ideas of communicating sequential processes (CSP) in a functional framework and uses asynchronous message passing. Processes are the primary means to structure an Erlang application.  They are neither operating system processes nor operating system threads, but lightweight processes that are scheduled by Erlang's BEAM VM. Like operating system processes (but unlike operating system threads), they share no state with each other. The estimated minimal overhead for each is 300 words. Thus, many processes can be created without degrading performance. A benchmark with 20 million processes has been successfully performed. Erlang has supported symmetric multiprocessing since release R11B of May 2006.\n\nWhile threads require external library support in most languages, Erlang provides language-level features for creating and managing processes with the aim of simplifying concurrent programming. Though all concurrency is explicit in Erlang, processes communicate using message passing instead of shared variables, which removes the need for explicit locks (a locking scheme is still used internally by the VM).\n\nInter-process communication works via a shared-nothing asynchronous message passing system: every process has a \"mailbox\", a queue of messages that have been sent by other processes and not yet consumed. A process uses the receive primitive to retrieve messages that match desired patterns. A message-handling routine tests messages in turn against each pattern, until one of them matches. When the message is consumed and removed from the mailbox the process resumes execution. A message may comprise any Erlang structure, including primitives (integers, floats, characters, atoms), tuples, lists, and functions.\n\nThe code example below shows the built-in support for distributed processes:\n\n % Create a process and invoke the function web:start_server(Port, MaxConnections)\n ServerProcess = spawn(web, start_server, [Port, MaxConnections]),\n\n % Create a remote process and invoke the function\n % web:start_server(Port, MaxConnections) on machine RemoteNode\n RemoteProcess = spawn(RemoteNode, web, start_server, [Port, MaxConnections]),\n\n % Send a message to ServerProcess (asynchronously). The message consists of a tuple\n % with the atom \"pause\" and the number \"10\".\n ServerProcess ! {pause, 10},\n\n % Receive messages sent to this process\n receive\n         a_message -> do_something;\n         {data, DataContent} -> handle(DataContent);\n         {hello, Text} -> io:format(\"Got hello message: ~s\", [Text]);\n         {goodbye, Text} -> io:format(\"Got goodbye message: ~s\", [Text])\n end.\n\nAs the example shows, processes may be created on remote nodes, and communication with them is transparent in the sense that communication with remote processes works exactly as communication with local processes.\n\nConcurrency supports the primary method of error-handling in Erlang. When a process crashes, it neatly exits and sends a message to the controlling process which can then take action, such as for instance starting a new process that takes over the old process's task.\n\nImplementation\n\nThe official reference implementation of Erlang is called BEAM. It is included in the official distribution of Erlang, which is called Erlang/OTP. BEAM loads virtual machine bytecode which is converted to threaded code at load time. It also includes a native code compiler on most platforms, developed by the High Performance Erlang Project (HiPE) at Uppsala University. Since October 2001 the HiPE system is fully integrated in Ericsson's Open Source Erlang/OTP system. It also supports interpreting, directly from source code via abstract syntax tree, via script as of R11B-5 release of Erlang.\n\nHot code loading and modules\n\nErlang supports language-level Dynamic Software Updating. To implement this, code is loaded and managed as \"module\" units; the module is a compilation unit. The system can keep two versions of a module in memory at the same time, and processes can concurrently run code from each. The versions are referred to as the \"new\" and the \"old\" version. A process will not move into the new version until it makes an external call to its module.\n\nAn example of the mechanism of hot code loading:\n\n  %% A process whose only job is to keep a counter.\n  %% First version\n  -module(counter).\n  -export([start/0, codeswitch/1]).\n\n  start() -> loop(0).\n\n  loop(Sum) ->\n    receive\n       {increment, Count} ->\n          loop(Sum+Count);\n       {counter, Pid} ->\n          Pid ! {counter, Sum},\n          loop(Sum);\n       code_switch ->\n          ?MODULE:codeswitch(Sum)\n          % Force the use of 'codeswitch/1' from the latest MODULE version\n    end.\n\n  codeswitch(Sum) -> loop(Sum).\n\nFor the second version, we add the possibility to reset the count to zero.\n\n  %% Second version\n  -module(counter).\n  -export([start/0, codeswitch/1]).\n\n  start() -> loop(0).\n\n  loop(Sum) ->\n    receive\n       {increment, Count} ->\n          loop(Sum+Count);\n       reset ->\n          loop(0);\n       {counter, Pid} ->\n          Pid ! {counter, Sum},\n          loop(Sum);\n       code_switch ->\n          ?MODULE:codeswitch(Sum)\n    end.\n\n  codeswitch(Sum) -> loop(Sum).\n\nOnly when receiving a message consisting of the atom 'code_switch' will the loop execute an external call to codeswitch/1 (?MODULE is a preprocessor macro for the current module). If there is a new version of the \"counter\" module in memory, then its codeswitch/1 function will be called. The practice of having a specific entry-point into a new version allows the programmer to transform state to what is required in the newer version. In our example we keep the state as an integer.\n\nIn practice, systems are built up using design principles from the Open Telecom Platform which leads to more code upgradable designs. Successful hot code loading is a tricky subject; Code needs to be written with care to make use of Erlang's facilities.\n\nDistribution\n\nIn 1998, Ericsson released Erlang as open source to ensure its independence from a single vendor and to increase awareness of the language. Erlang, together with libraries and the real-time distributed database Mnesia, forms the Open Telecom Platform (OTP) collection of libraries. Ericsson and a few other companies offer commercial support for Erlang.\n\nSince the open source release, Erlang has been used by several firms worldwide, including Nortel and T-Mobile. Although Erlang was designed to fill a niche and has remained an obscure language for most of its existence, its popularity is growing due to demand for concurrent services.\nErlang has found some use in fielding MMORPG servers.\n\nVariants\n\n* Elixir: a functional, concurrent, general-purpose programming language that runs on the Erlang Virtual Machine (BEAM).\n* Lisp Flavored Erlang:  a LISP based programming language that runs on the Erlang Virtual Machine (BEAM). Erlang (programming language). http://en.wikipedia.org/?curid=9646."
  }
}
