{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=9773",
  "eid" : "f209d5e0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778485822,
  "textBody" : "Extended Binary Coded Decimal Interchange Code (EBCDIC [https://web.archive.org/web/20160526172151/https://textfiles.meulie.net/bitsaved/Books/Mackenzie_CodedCharSets.pdf];) is an eight-bit character encoding used mainly on IBM mainframe and IBM midrange computer operating systems. It descended from the code used with punched cards and the corresponding six bit binary-coded decimal code used with most of IBM's computer peripherals of the late 1950s and early 1960s.  It is supported by various non-IBM platforms, such as Fujitsu-Siemens' BS2000/OSD, OS-IV, MSP, and MSP-EX, the SDS Sigma series, and Unisys VS/9 and MCP.\n\nHistory \n\nEBCDIC was devised in 1963 and 1964 by IBM and was announced with the release of the IBM System/360 line of mainframe computers. It is an eight-bit character encoding, developed separately from the 7-bit ASCII encoding scheme. It was created to extend the existing Binary-Coded Decimal (BCD) Interchange Code, or BCDIC, which itself was devised as an efficient means of encoding the two zone and number punches on punched cards into 6 bits. The distinct encoding of 's' and 'S' (using position 2 instead of 1) was maintained from punched cards where it was desirable not to have hole punches too close to each other to ensure the integrity of the physical card.\n\nWhile IBM was a chief proponent of the ASCII standardization committee,[http://worldpowersystems.com/projects/codes/X3.4-1963/page4.JPG They had 4 staff on the final 21-member ASA X3.2 sub-committee] the company did not have time to prepare ASCII peripherals (such as card punch machines) to ship with its System/360 computers, so the company settled on EBCDIC. The System/360 became wildly successful, together with clones such as RCA Spectra 70, ICL System 4, and Fujitsu FACOM, thus so did EBCDIC.\n\nAll IBM mainframe and midrange peripherals and operating systems use EBCDIC as their inherent encoding (with toleration for ASCII, for example, ISPF in z/OS can browse and edit both EBCDIC and ASCII encoded files). Software and many hardware peripherals can translate to and from encodings, and modern mainframes (such as IBM zSeries) include processor instructions, at the hardware level, to accelerate translation between character sets.\n\nThere is an EBCDIC-oriented Unicode Transformation Format called UTF-EBCDIC proposed by the Unicode consortium, designed to allow easy updating of EBCDIC software to handle Unicode, but not intended to be used in open interchange environments. Even on systems with extensive EBCDIC support, it has not been popular. For example, z/OS supports Unicode (preferring UTF-16 specifically), but z/OS only has limited support for UTF-EBCDIC.\n\nIBM AIX running on the RS/6000 and its descendants including the IBM Power Systems, Linux running on z Systems, and operating systems running on the IBM PC and its descendants use ASCII, as did AIX/370 and AIX/390 running on System/370 and System/390 mainframes.\n\nCompatibility with ASCII \n\nThe fact that all the code points were different was less of a problem for inter-operating with ASCII than the fact that sorting EBCDIC put lowercase letters before uppercase letters and letters before numbers, exactly the opposite of ASCII.\n\nSoftware portability and data exchange are hindered by EBCDIC's lack of codes for several symbols (such as the brace characters) commonly used in programming and in network communications.\n\nThe gaps between letters made simple code that worked in ASCII fail on EBCDIC. For example, \"for (c'A';c\" would set c to the 26 letters in the ASCII alphabet, but 41 characters including a number of unassigned ones in EBCDIC. Fixing this required complicating the code with function calls which was greatly resisted by programmers.\n\nAll ASCII codes stored within an eight-bit byte had nonnegative values on systems such as the PDP-11 that treated bytes as signed quantities.  Software on those platforms often took advantage of that property, causing problems when it was ported to EBCDIC-based environments where many character codes had a 1 as the \"sign\" bit.\n\nBy using all eight bits EBCDIC may have encouraged the use of the eight-bit byte by IBM, while ASCII was more likely to be adopted by systems with 36 bits (as five seven-bit ASCII characters fit into one word). As eight-bit bytes became widespread, ASCII systems sometimes used the \"unused\" bit for other purposes, thus making it more difficult to transition to larger character sets.\n\nCode page layout \n\nThe table below is based on CCSID 037, one of the code page variants of EBCDIC; it shows only the basic (English) EBCDIC characters. Characters 00–3F and FF are controls, 40 is space, 41 is no-break space (RSP: \"Required Space\"), E1 is numeric space (NSP: \"Numeric Space\"), and CA is soft hyphen. Characters are shown with their equivalent Unicode codes. Unassigned codes are typically filled with international or region-specific characters in the various EBCDIC code page variants, but the punctuation marks and other special characters, such as cent sign, are often moved around as well; only the letters and numbers and space have the same assignments in all EBCDIC code pages.\n\nIn each table cell below, the first row is an abbreviation for a control code or (for printable characters) the character itself; the second row is the Unicode code (blank for controls that don't exist in Unicode); and the third row is decimal value of the EBCDIC code.\n\nDKOI \n\nEBCDIC-based Cyrillic DKOI character sets:\n\n*DKOI CS2 (defined in CSN 36 9103)\n*DKOI K1 (defined in CSN 36 9103, ST SEV 358-88)\n*DKOI K2 (defined in CSN 36 9103, ST SEV 358-88)\n*DKOI L2 (defined in CSN 36 9103)\n\nCriticism and humor \n\nOpen-source software advocate and hacker Eric S. Raymond writes in his Jargon File that EBCDIC was almost universally loathed by early hackers and programmers. The Jargon File 4.4.7 gives the following definition:\n\nEBCDIC design was also the source of many jokes. One such joke went: \n\nReferences to the EBCDIC character set are made in the classic Infocom adventure game series Zork. In the \"Machine Room\" in Zork II, EBCDIC is used to imply an incomprehensible language:\n\nA similar description can be found in the \"Maintenance Room\" in Zork:",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "EBCDIC" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=9773" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Extended Binary Coded Decimal Interchange Code (EBCDIC [https://web.archive.org/web/20160526172151/https://textfiles.meulie.net/bitsaved/Books/Mackenzie_CodedCharSets.pdf];) is an eight-bit character encoding used mainly on IBM mainframe and IBM midrange computer operating systems. It descended from the code used with punched cards and the corresponding six bit binary-coded decimal code used with most of IBM's computer peripherals of the late 1950s and early 1960s.  It is supported by various non-IBM platforms, such as Fujitsu-Siemens' BS2000/OSD, OS-IV, MSP, and MSP-EX, the SDS Sigma series, and Unisys VS/9 and MCP.\n\nHistory \n\nEBCDIC was devised in 1963 and 1964 by IBM and was announced with the release of the IBM System/360 line of mainframe computers. It is an eight-bit character encoding, developed separately from the 7-bit ASCII encoding scheme. It was created to extend the existing Binary-Coded Decimal (BCD) Interchange Code, or BCDIC, which itself was devised as an efficient means of encoding the two zone and number punches on punched cards into 6 bits. The distinct encoding of 's' and 'S' (using position 2 instead of 1) was maintained from punched cards where it was desirable not to have hole punches too close to each other to ensure the integrity of the physical card.\n\nWhile IBM was a chief proponent of the ASCII standardization committee,[http://worldpowersystems.com/projects/codes/X3.4-1963/page4.JPG They had 4 staff on the final 21-member ASA X3.2 sub-committee] the company did not have time to prepare ASCII peripherals (such as card punch machines) to ship with its System/360 computers, so the company settled on EBCDIC. The System/360 became wildly successful, together with clones such as RCA Spectra 70, ICL System 4, and Fujitsu FACOM, thus so did EBCDIC.\n\nAll IBM mainframe and midrange peripherals and operating systems use EBCDIC as their inherent encoding (with toleration for ASCII, for example, ISPF in z/OS can browse and edit both EBCDIC and ASCII encoded files). Software and many hardware peripherals can translate to and from encodings, and modern mainframes (such as IBM zSeries) include processor instructions, at the hardware level, to accelerate translation between character sets.\n\nThere is an EBCDIC-oriented Unicode Transformation Format called UTF-EBCDIC proposed by the Unicode consortium, designed to allow easy updating of EBCDIC software to handle Unicode, but not intended to be used in open interchange environments. Even on systems with extensive EBCDIC support, it has not been popular. For example, z/OS supports Unicode (preferring UTF-16 specifically), but z/OS only has limited support for UTF-EBCDIC.\n\nIBM AIX running on the RS/6000 and its descendants including the IBM Power Systems, Linux running on z Systems, and operating systems running on the IBM PC and its descendants use ASCII, as did AIX/370 and AIX/390 running on System/370 and System/390 mainframes.\n\nCompatibility with ASCII \n\nThe fact that all the code points were different was less of a problem for inter-operating with ASCII than the fact that sorting EBCDIC put lowercase letters before uppercase letters and letters before numbers, exactly the opposite of ASCII.\n\nSoftware portability and data exchange are hindered by EBCDIC's lack of codes for several symbols (such as the brace characters) commonly used in programming and in network communications.\n\nThe gaps between letters made simple code that worked in ASCII fail on EBCDIC. For example, \"for (c'A';c\" would set c to the 26 letters in the ASCII alphabet, but 41 characters including a number of unassigned ones in EBCDIC. Fixing this required complicating the code with function calls which was greatly resisted by programmers.\n\nAll ASCII codes stored within an eight-bit byte had nonnegative values on systems such as the PDP-11 that treated bytes as signed quantities.  Software on those platforms often took advantage of that property, causing problems when it was ported to EBCDIC-based environments where many character codes had a 1 as the \"sign\" bit.\n\nBy using all eight bits EBCDIC may have encouraged the use of the eight-bit byte by IBM, while ASCII was more likely to be adopted by systems with 36 bits (as five seven-bit ASCII characters fit into one word). As eight-bit bytes became widespread, ASCII systems sometimes used the \"unused\" bit for other purposes, thus making it more difficult to transition to larger character sets.\n\nCode page layout \n\nThe table below is based on CCSID 037, one of the code page variants of EBCDIC; it shows only the basic (English) EBCDIC characters. Characters 00–3F and FF are controls, 40 is space, 41 is no-break space (RSP: \"Required Space\"), E1 is numeric space (NSP: \"Numeric Space\"), and CA is soft hyphen. Characters are shown with their equivalent Unicode codes. Unassigned codes are typically filled with international or region-specific characters in the various EBCDIC code page variants, but the punctuation marks and other special characters, such as cent sign, are often moved around as well; only the letters and numbers and space have the same assignments in all EBCDIC code pages.\n\nIn each table cell below, the first row is an abbreviation for a control code or (for printable characters) the character itself; the second row is the Unicode code (blank for controls that don't exist in Unicode); and the third row is decimal value of the EBCDIC code.\n\nDKOI \n\nEBCDIC-based Cyrillic DKOI character sets:\n\n*DKOI CS2 (defined in CSN 36 9103)\n*DKOI K1 (defined in CSN 36 9103, ST SEV 358-88)\n*DKOI K2 (defined in CSN 36 9103, ST SEV 358-88)\n*DKOI L2 (defined in CSN 36 9103)\n\nCriticism and humor \n\nOpen-source software advocate and hacker Eric S. Raymond writes in his Jargon File that EBCDIC was almost universally loathed by early hackers and programmers. The Jargon File 4.4.7 gives the following definition:\n\nEBCDIC design was also the source of many jokes. One such joke went: \n\nReferences to the EBCDIC character set are made in the classic Infocom adventure game series Zork. In the \"Machine Room\" in Zork II, EBCDIC is used to imply an incomprehensible language:\n\nA similar description can be found in the \"Maintenance Room\" in Zork:. EBCDIC. http://en.wikipedia.org/?curid=9773."
  }
}
