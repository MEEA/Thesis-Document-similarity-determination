{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=6799",
  "eid" : "dde39a10-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778452017,
  "textBody" : "COBOL (, an acronym for common business-oriented language) is a compiled English-like computer programming language designed for business use. It is imperative, procedural and, since 2002, object-oriented. COBOL is primarily used in business, finance, and administrative systems for companies and governments.  COBOL is still widely used in legacy applications deployed on mainframe computers, such as large-scale batch and transaction processing jobs. But due to its declining popularity and the retirement of experienced COBOL programmers, programs are being migrated to new platforms, rewritten in modern languages or replaced with software packages. Most programming in COBOL is now purely to maintain existing applications.\n\nCOBOL was designed in 1959 by CODASYL and was partly based on previous programming language design work by Grace Hopper, commonly referred to as \"the (grand)mother of COBOL\". It was created as part of a US Department of Defense effort to create a portable programming language for data processing. Intended as a stopgap, the Department of Defense promptly forced computer manufacturers to provide it, resulting in its widespread adoption. It was standardized in 1968 and has since been revised four times. Expansions include support for structured and object-oriented programming. The current standard is ISO/IEC 1989:2014.\n\nCOBOL has an English-like syntax, which was designed to be self-documenting and highly readable. However, it is verbose and uses over 300 reserved words. In contrast with modern, succinct syntax like , COBOL has a more English-like syntax (in this case, ).\nCOBOL code is split into four divisions (identification, environment, data and procedure) containing a rigid hierarchy of sections, paragraphs and sentences. Lacking a large standard library, the standard specifies 43 statements, 87 functions and just one class.\n\nAcademic computer scientists were generally uninterested in business applications when COBOL was created and were not involved in its design; it was (effectively) designed from the ground up as a computer language for business, with an emphasis on inputs and outputs, whose only data types were numbers and strings of text.http://cs.brown.edu/~adf/programming_languages.html\nCOBOL has been criticized throughout its life, however, for its verbosity, design process and poor support for structured programming, which resulted in monolithic and incomprehensible programs.\n\nHistory and specification\n\nBackground\n\nIn the late 1950s, computer users and manufacturers were becoming concerned about the rising cost of programming. A 1959 survey had found that in any data processing installation, the programming cost US$800,000 on average and that translating programs to run on new hardware would cost $600,000. At a time when new programming languages were proliferating at an ever-increasing rate, the same survey suggested that if a common business-oriented language were used, conversion would be far cheaper and faster.\n\nIn April 1959, Mary K. Hawes called a meeting of representatives from academia, computer users, and manufacturers at the University of Pennsylvania to organize a formal meeting on common business languages. Representatives included Grace Hopper, inventor of the English-like data processing language FLOW-MATIC, Jean Sammet and Saul Gorn.\n\nThe group asked the Department of Defense (DoD) to sponsor an effort to create a common business language. The delegation impressed Charles A. Phillips, director of the Data System Research Staff at the DoD, who thought that they \"thoroughly understood\" the DoD's problems. The DoD operated 225 computers, had a further 175 on order and had spent over $200 million on implementing programs to run on them. Portable programs would save time, reduce costs and ease modernization.\n\nPhillips agreed to sponsor the meeting and tasked the delegation with drafting the agenda.\n\nCOBOL 60\n\nOn May 28 and 29 of 1959 (exactly one year after the ZÃ¼rich ALGOL 58 meeting), a meeting was held at the Pentagon to discuss the creation of a common programming language for business. It was attended by 41 people and was chaired by Phillips. The Department of Defense was concerned about whether it could run the same data processing programs on different computers. FORTRAN, the only mainstream language at the time, lacked the features needed to write such programs.\n\nRepresentatives enthusiastically described a language that could work in a wide variety of environments, from banking and insurance to utilities and inventory control. They agreed unanimously that more people should be able to program and that the new language should not be restricted by the limitations of contemporary technology. A majority agreed that the language should make maximal use of English, be capable of change, be machine-independent and be easy to use, even at the expense of power.\n\nThe meeting resulted in the creation of a steering committee and short-, intermediate- and long-range committees. The short-range committee was given to September (three months) to produce specifications for an interim language, which would then be improved upon by the other committees. Their official mission, however, was to identify the strengths and weaknesses of existing programming languages and did not explicitly direct them to create a new language.\nThe deadline was met with disbelief by the short-range committee.\nOne member, Betty Holberton, described the three-month deadline as \"gross optimism\" and doubted that the language really would be a stopgap.\n\nThe steering committee met on June 4 and agreed to name the entire activity as the Committee on Data Systems Languages, or CODASYL, and to form an executive committee.\n\nThe short-range committee was made up of members representing six computer manufacturers and three government agencies. The six computer manufacturers were Burroughs Corporation, IBM, Minneapolis-Honeywell (Honeywell Labs), RCA, Sperry Rand, and Sylvania Electric Products. The three government agencies were the US Air Force, the Navy's David Taylor Model Basin, and the National Bureau of Standards (now the National Institute of Standards and Technology). The committee was chaired by Joseph Wegstein of the US National Bureau of Standards. Work began by investigating data description, statements, existing applications and user experiences.\n\nThe committee mainly examined the FLOW-MATIC, AIMACO and COMTRAN programming languages.\nThe FLOW-MATIC language was particularly influential because it had been implemented and because AIMACO was a derivative of it with only minor changes.\nFLOW-MATIC's inventor, Grace Hopper, also served as a technical adviser to the committee. FLOW-MATIC's major contributions to COBOL were long variable names, English words for commands and the separation of data descriptions and instructions.\n\nIBM's COMTRAN language, invented by Bob Bemer, was regarded as a competitor to FLOW-MATIC by a short-range committee made up of colleagues of Grace Hopper.\nSome of its features were not incorporated into COBOL so that it would not look like IBM had dominated the design process, and Jean Sammet said in 1981 that there had been a \"strong anti-IBM bias\" from some committee members (herself included).\nIn one case, after Roy Goldfinger, author of the COMTRAN manual and intermediate-range committee member, attended a subcommittee meeting to support his language and encourage the use of algebraic expressions, Grace Hopper sent a memo to the short-range committee reiterating Sperry Rand's efforts to create a language based on English.\nIn 1980, Grace Hopper commented that \"COBOL 60 is 95% FLOW-MATIC\" and that COMTRAN had had an \"extremely small\" influence. Furthermore, she said that she would claim that work was influenced by both FLOW-MATIC and COMTRAN only to \"keep other people happy [so they] wouldn't try to knock us out\".\nFeatures from COMTRAN incorporated into COBOL included formulas, the  clause, an improved IF statement, which obviated the need for GO TOs, and a more robust file management system.\n\nThe usefulness of the committee's work was subject of great debate. While some members thought the language had too many compromises and was the result of design by committee, others felt it was better than the three languages examined. Some felt the language was too complex; others, too simple.\nControversial features included those some considered useless or too advanced for data processing users. Such features included boolean expressions, formulas and table ' (indices). Another point of controversy was whether to make keywords context-sensitive and the effect that would have on readability. Although context-sensitive keywords were rejected, the approach was later used in PL/I and partially in COBOL from 2002. Little consideration was given to interactivity, interaction with operating systems (few existed at that time) and functions (thought of as purely mathematical and of no use in data processing).\n\nThe specifications were presented to the Executive Committee on September 4. They fell short of expectations: Joseph Wegstein noted that \"it contains rough spots and requires some additions\", and Bob Bemer later described them as a \"hodgepodge\". The subcommittee was given until December to improve it.\n\nAt a mid-September meeting, the committee discussed the new language's name. Suggestions included \"BUSY\" (Business System), \"INFOSYL\" (Information System Language) and \"COCOSYL\" (Common Computer Systems Language). The name \"COBOL\" was suggested by Bob Bemer.\n\nIn October, the intermediate-range committee received copies of the FACT language specification created by Roy Nutt. Its features impressed the committee so much that they passed a resolution to base COBOL on it.\nThis was a blow to the short-range committee, who had made good progress on the specification. Despite being technically superior, FACT had not been created with portability in mind or through manufacturer and user consensus. It also lacked a demonstrable implementation, allowing supporters of a FLOW-MATIC-based COBOL to overturn the resolution. RCA representative Howard Bromberg also blocked FACT, so that RCA's work on a COBOL implementation would not go to waste.\n\nIt soon became apparent that the committee was too large for any further progress to be made quickly. A frustrated Howard Bromberg bought a $15 tombstone with \"COBOL\" engraved on it and sent it to Charles Phillips to demonstrate his displeasure.\nA sub-committee was formed to analyze existing languages and was made up of six individuals:\n\n* William Selden and Gertrude Tierney of IBM,\n* Howard Bromberg and Howard Discount of RCA,\n* Vernon Reeves and Jean E. Sammet of Sylvania Electric Products.\n\nThe sub-committee did most of the work creating the specification, leaving the short-range committee to review and modify their work before producing the finished specification.\n\nThe specifications were approved by the Executive Committee on January 3, 1960, and sent to the government printing office, which printed these as COBOL 60. The language's stated objectives were to allow efficient, portable programs to be easily written, to allow users to move to new systems with minimal effort and cost, and to be suitable for inexperienced programmers.\nThe CODASYL Executive Committee later created the COBOL Maintenance Committee to answer questions from users and vendors and to improve and expand the specifications.\n\nDuring 1960, the list of manufacturers planning to build COBOL compilers grew. By September, five more manufacturers had joined CODASYL (Bendix, Control Data Corporation, General Electric (GE), National Cash Register and Philco), and all represented manufacturers had announced COBOL compilers. GE and IBM planned to integrate COBOL into their own languages, GECOM and COMTRAN, respectively. In contrast, International Computers and Tabulators planned to replace their language, CODEL, with COBOL.\n\nMeanwhile, RCA and Sperry Rand worked on creating COBOL compilers. The first COBOL program ran on 17 August on an RCA 501.\nOn December 6 and 7, the same COBOL program (albeit with minor changes) ran on an RCA computer and a Remington-Rand Univac computer, demonstrating that compatibility could be achieved.\n\nThe relative influences of which languages were used continues to this day in the recommended advisory printed in all COBOL reference manuals:\n\nCOBOL-61 to COBOL-65\n\nMany logical flaws were found in COBOL 60, leading GE's Charles Katz to warn that it could not be interpreted unambiguously. A reluctant short-term committee enacted a total cleanup and, by March 1963, it was reported that COBOL's syntax was as definable as ALGOL's, although semantic ambiguities remained.\n\nEarly COBOL compilers were primitive and slow. A 1962 US Navy evaluation found compilation speeds of 3â11 statements per minute. By mid-1964, they had increased to 11â1000 statements per minute. It was observed that increasing memory would drastically increase speed and that compilation costs varied wildly: costs per statement were between $0.23 and $18.91.\n\nIn late 1962, IBM announced that COBOL would be their primary development language and that development of COMTRAN would cease.\n\nThe COBOL specification was revised three times in the five years after its publication.\nCOBOL-60 was replaced in 1961 by COBOL-61. This was then replaced by the COBOL-61 Extended specifications in 1963, which introduced the sort and report writer facilities.\nThe added facilities corrected flaws identified by Honeywell in late 1959 in a letter to the short-range committee.\nCOBOL Edition 1965 brought further clarifications to the specifications and introduced facilities for handling mass storage files and tables.\n\nCOBOL-68\n\nEfforts began to standardize COBOL to overcome incompatibilities between versions. In late 1962, both ISO and the United States of America Standards Institute (now ANSI) formed groups to create standards. ANSI produced USA Standard COBOL X3.23 in August 1968, which became the cornerstone for later versions. This version was known as American National Standard (ANS) COBOL and was adopted by ISO in 1972.\n\nCOBOL-74\n\nBy 1970, COBOL had become the most widely used programming language in the world.\n\nIndependently of the ANSI committee, the CODASYL Programming Language Committee was working on improving the language. They described new versions in 1968, 1969, 1970 and 1973, including changes such as new inter-program communication, debugging and file merging facilities as well as improved string-handling and library inclusion features.\nAlthough CODASYL was independent of the ANSI committee, the CODASYL Journal of Development was used by ANSI to identify features that were popular enough to warrant implementing.\nThe Programming Language Committee also liaised with ECMA and the Japanese COBOL Standard committee.\n\nThe Programming Language Committee was not well-known, however. The vice-president, William Rinehuls, complained that two-thirds of the COBOL community did not know of the committee's existence. It was also poor, lacking the funds to make public documents, such as minutes of meetings and change proposals, freely available.\n\nIn 1974, ANSI published a revised version of (ANS) COBOL, containing new features such as file organizations, the  statement and the segmentation module.\nDeleted features included the  statement, the  statement (which was replaced by ) and the implementer-defined random access module (which was superseded by the new sequential and relative I/O modules). These made up 44 changes, which rendered existing statements incompatible with the new standard.\nThe report writer was slated to be removed from COBOL, but was reinstated before the standard was published. ISO later adopted the updated standard in 1978.\n\nCOBOL-85\n\nIn June 1978, work began on revising COBOL-74. The proposed standard (commonly called COBOL-80) differed significantly from the previous one, causing concerns about incompatibility and conversion costs. In January 1981, Joseph T. Brophy, Senior Vice-President of Travelers Insurance, threatened to sue the standard committee because it was not upwards compatible with COBOL-74. Mr. Brophy described previous conversions of their 40-million-line code base as \"non-productive\" and a \"complete waste of our programmer resources\".\nLater that year, the Data Processing Management Association (DPMA) said it was \"strongly opposed\" to the new standard, citing \"prohibitive\" conversion costs and enhancements that were \"forced on the user\".\n\nDuring the first public review period, the committee received 2,200 responses, of which 1,700 were negative form letters.\nOther responses were detailed analyses of the effect COBOL-80 would have on their systems; conversion costs were predicted to be at least 50 cents per line of code. Fewer than a dozen of the responses were in favor of the proposed standard.\n\nIn 1983, the DPMA withdrew its opposition to the standard, citing the responsiveness of the committee to public concerns. In the same year, a National Bureau of Standards study concluded that the proposed standard would present few problems. A year later, a COBOL-80 compiler was released to DEC VAX users, who noted that conversion of COBOL-74 programs posed few problems. The new EVALUATE statement and inline PERFORM were particularly well received and improved productivity, thanks to simplified control flow and debugging.\n\nThe second public review drew another 1,000 (mainly negative) responses, while the last drew just 25, by which time many concerns had been addressed.\n\nIn late 1985, ANSI published the revised standard. Sixty features were changed or deprecated and many were added, such as:\n\n* Scope terminators (END-IF, END-PERFORM, END-READ, etc.)\n* Nested subprograms\n* CONTINUE, a no-operation statement\n* EVALUATE, a switch statement\n* INITIALIZE, a statement that can set groups of data to their default values\n* Inline PERFORM loop bodies â previously, loop bodies had to be specified in a separate procedure\n* Reference modification, which allows access to substrings\n* I/O status codes.\n\nThe standard was adopted by ISO the same year. Two amendments followed in 1989 and 1993, the first introducing intrinsic functions and the other providing corrections. ISO adopted the amendments in 1991 and 1994 respectively, before subsequently taking primary ownership and development of the standard.\n\nCOBOL 2002 and object-oriented COBOL\n\nIn 1997, Gartner Group estimated that there were a total of 200 billion lines of COBOL in existence, which ran 80% of all business programs.\n\nIn the early 1990s, work began on adding object-orientation in the next full revision of COBOL. Object-oriented features were taken from C++ and Smalltalk.\nThe initial estimate was to have this revision completed by 1997, and an ISO Committee Draft (CD) was available by 1997. Some vendors (including Micro Focus, Fujitsu, and IBM) introduced object-oriented syntax based on drafts of the full revision. The final approved ISO standard was approved and published in late 2002.\n\nFujitsu/GTSoftware, Micro Focus and RainCode introduced object-oriented COBOL compilers targeting the .NET Framework.\n\nThere were many other new features, many of which had been in the CODASYL COBOL Journal of Development since 1978 and had missed the opportunity to be included in COBOL-85. These other features included:\n\n* Free-form code\n* User-defined functions\n* Recursion\n* Locale-based processing\n* Support for extended character sets such as Unicode\n* Floating-point and binary data types (until then, binary items were truncated based on their declaration's base-10 specification)\n* Portable arithmetic results\n*Bit and boolean data types\n* Pointers and syntax for getting and freeing storage\n* The  for text-based user interfaces\n* The  facility\n* Improved interoperability with other programming languages and framework environments such as .NET and Java.\n\nThree corrigenda were published for the standard: two in 2006 and one in 2009.\n\nCOBOL 2014\n\nBetween 2003 and 2009, three technical reports were produced describing object finalization, XML processing and collection classes for COBOL.\n\nCOBOL 2002 suffered from poor support: no compilers completely supported the standard. Micro Focus found that it was due to a lack of user demand for the new features and due to the abolition of the NIST test suite, which had been used to test compiler conformance. The standardization process was also found to be slow and under-resourced.\n\nCOBOL 2014 includes the following changes:\n* Portable arithmetic results have been replaced by IEEE 754 data types\n* Major features have been made optional, such as the VALIDATE facility, the report writer and the screen-handling facility.\n* Method overloading\n* Dynamic capacity tables (a feature dropped from the draft of COBOL 2002)\n\nLegacy\n\nCOBOL programs are used globally in governments and businesses and are running on diverse operating systems such as z/OS, z/VSE, VME, Unix, OpenVMS and Windows.  In 1997, the Gartner Group reported that 80% of the world's business ran on COBOL with over 200 billion lines of code and 5 billion lines more being written annually.\n\nNear the end of the 20th century, the year 2000 problem (Y2K) was the focus of significant COBOL programming effort, sometimes by the same programmers who had designed the systems decades before. The particular level of effort required to correct COBOL code has been attributed to the large amount of business-oriented COBOL, as business applications use dates heavily, and to fixed-length data fields. After the clean-up effort put into these programs for Y2K, a 2003 survey found that many remained in use.\nThe authors said that the survey data suggest \"a gradual decline in the importance of Cobol in application development over the [following] 10 years unless ... integration with other languages and technologies can be adopted\".\n\nIn 2006 and 2012, Computerworld surveys found that over 60% of organizations used COBOL (more than C++ and Visual Basic .NET) and that for half of those, COBOL was used for the majority of their internal software. 36% of managers said they planned to migrate from COBOL, and 25% said they would like to if it was cheaper. Instead, some businesses have migrated their systems from expensive mainframes to cheaper, more modern systems, while maintaining their COBOL programs.\n\nFeatures\n\nSyntax\n\nCOBOL has an English-like syntax, which is used to describe nearly everything in a program. For example, a condition can be expressed as Â  or more concisely as Â Â  or Â . More complex conditions can be \"abbreviated\" by removing repeated conditions and variables. For example, Â Â  can be shortened to . As a consequence of this English-like syntax, COBOL has over 300 keywords. Some of the keywords are simple alternative or pluralized spellings of the same word, which provides for more English-like statements and clauses; e.g., the  and  keywords can be used interchangeably, as can  and , and  and .\n\nEach COBOL program is made up of four basic lexical items: words, literals, picture character-strings (see ) and separators. Words include reserved words and user-defined identifiers. They are up to 31 characters long and may include letters, digits, hyphens and underscores. Literals include numerals (e.g. ) and strings (e.g. ). Separators include the space character and commas and semi-colons followed by a space.\n\nA COBOL program is split into four divisions: the identification division, the environment division, the data division and the procedure division. The identification division specifies the name and type of the source element and is where classes and interfaces are specified. The environment division specifies any program features that depend on the system running it, such as files and character sets. The data division is used to declare variables and parameters. The procedure division contains the program's statements. Each division is sub-divided into sections, which are made up of paragraphs.\n\nMetalanguage\n\nCOBOL's syntax is usually described with a unique metalanguage using braces, brackets, bars and underlining. The metalanguage was developed for the original COBOL specifications. Although BackusâNaur form did exist at the time, the committee had not heard of it.\n\nAs an example, consider the following description of an ADD statement:\n\n\\begin{array}{l}\n  \\underline{\\text{ADD}}\\,\n  \\begin{Bmatrix}\n    \\text{identifier-1} \\\\\n    \\text{literal-1}\n  \\end{Bmatrix}\\dots\n  \\;\\underline{\\text{TO}}\\,\\left\\{\\text{identifier-2}\\,\\left[\\,\\underline{\\text{ROUNDED}}\\,\\right]\\right\\}\\dots\n  \\\\\n\n  \\quad\n  \\left[\\left|\\begin{array}{l}\n     \\text{ON}\\,\\underline{\\text{SIZE}}\\,\\underline{\\text{ERROR}}\\,\\text{imperative-statement-1} \\\\\n     \\underline{\\text{NOT}}\\,\\text{ON}\\,\\underline{\\text{SIZE}}\\,\\underline{\\text{ERROR}}\\,\\text{imperative-statement-2} \\\\\n  \\end{array}\\right|\\right]\n  \\\\\n\n  \\quad\n  \\left[\\,\\underline{\\text{END-ADD}}\\,\\right]\n\\end{array}\n\nThis description permits the following variants:\n\nADD 1 TO x\nADD 1, a, b TO x ROUNDED, y, z ROUNDED\n\nADD a, b TO c\n    ON SIZE ERROR\n        DISPLAY \"Error\"\nEND-ADD\n\nADD a TO b\n    NOT SIZE ERROR\n        DISPLAY \"No error\"\n    ON SIZE ERROR\n        DISPLAY \"Error\"\n\nCode format\n\nCOBOL can be written in two formats: fixed (the default) or free. In fixed-format, code must be aligned to fit in certain areas (a hold-over from using punched cards). Until COBOL 2002, these were:\n\nIn COBOL 2002, Areas A and B were merged to form the program-text area, which now ends at an implementor-defined column.\n\nCOBOL 2002 also introduced free-format code. Free-format code can be placed in any column of the file, as in newer programming languages. Comments are specified using *>, which can be placed anywhere and can also be used in fixed-format source code. Continuation lines are not present, and the >>PAGE directive replaces the / indicator.\n\nIdentification division\n\nThe identification division identifies the following code entity and contains the definition of a class or interface.\n\nObject-oriented programming\n\nClasses and interfaces have been in COBOL since 2002. Classes have factory objects, containing class methods and variables, and instance objects, containing instance methods and variables. Inheritance and interfaces provide polymorphism. Support for generic programming is provided through parameterized classes, which can be instantiated to use any class or interface. Objects are stored as references which may be restricted to a certain type. There are two ways of calling a method: the  statement, which acts similarly to , or through inline method invocation, which is analogous to using functions.\n\n*> These are equivalent.\nINVOKE my-class \"foo\" RETURNING var\nMOVE my-class::\"foo\" TO var *> Inline method invocation\n\nCOBOL does not provide a way to hide methods. Class data can be hidden, however, by declaring it without a property (programming)| clause, which leaves the user with no way to access it. Method overloading was added in COBOL 2014.\n\nEnvironment division\n\nThe environment division contains the configuration section and the input-output section. The configuration section is used to specify variable features such\nas currency signs, locales and character sets. The input-output section contains file-related information.\n\nFiles\n\nCOBOL supports three file formats, or ': sequential, indexed and relative. In sequential files, records are contiguous and must be traversed sequentially, similarly to a linked list. Indexed files have one or more indexes which allow records to be randomly accessed and which can be sorted on them. Each record must have a unique key, but other, ', record keys need not be unique. Implementations of indexed files vary between vendors, although common implementations, such as CâISAM and VSAM, are based on IBM's ISAM. Relative files, like indexed files, have a unique record key, but they do not have alternate keys. A relative record's key is its ordinal position; for example, the 10th record has a key of 10. This means that creating a record with a key of 5 may require the creation of (empty) preceding records. Relative files also allow for both sequential and random access.\n\nA common non-standard extension is the ' organization, used to process text files. Records in a file are terminated by a newline and may be of varying length.\n\nData division\n\nThe data division is split into six sections which declare different items: the file section, for file records; the working-storage section, for static variables; the local-storage section, for automatic variables; the linkage section, for parameters and the return value; the report section and the screen section, for text-based user interfaces.\n\nAggregated data\n\nData items in COBOL are declared hierarchically through the use of level-numbers which indicate if a data item is part of another. An item with a higher level-number is subordinate to an item with a lower one. Top-level data items, with a level-number of 1, are called '. Items that have subordinate aggregate data are called '; those that do not are called '. Level-numbers used to describe standard data items are between 1 and 49.\n\n       01  some-record.                   *> Aggregate group record item\n           05  num            PIC 9(10).  *> Elementary item\n           05  the-date.                  *> Aggregate (sub)group record item\n               10  the-year   PIC 9(4).   *> Elementary item\n               10  the-month  PIC 99.     *> Elementary item\n               10  the-day    PIC 99.     *> Elementary item\n\nIn the above example, elementary item  and group item  are subordinate to the record , while elementary items , , and  are part of the group item .\n\nSubordinate items can be disambiguated with the  (or ) keyword. For example, consider the example code above along with the following example:\n\n       01  sale-date.\n           05  the-year       PIC 9(4).\n           05  the-month      PIC 99.\n           05  the-day        PIC 99.\n\nThe names , , and  are ambiguous by themselves, since more than one data item is defined with those names. To specify a particular data item, for instance one of the items contained within the  group, the programmer would use  (or the equivalent ). (This syntax is similar to the \"dot notation\" supported by most contemporary languages.)\n\nOther data levels\n\nA level-number of 66 is used to declare a re-grouping of previously defined items, irrespective of how those items are structured. This data level, also referred to by the associated , is rarely used and, circa 1988, was usually found in old programs. Its ability to ignore the hierarchical and logical structure data meant its use was not recommended and many installations forbade its use.\n\n       01  customer-record.\n           05  cust-key            PIC X(10).\n           05  cust-name.\n               10  cust-first-name PIC X(30).\n               10  cust-last-name  PIC X(30).\n           05  cust-dob            PIC 9(8).\n           05  cust-balance        PIC 9(7)V99.\n           \n       66  cust-personal-details   RENAMES cust-name THRU cust-dob.\n       66  cust-all-details        RENAMES cust-name THRU cust-balance.\n\nA 77 level-number indicates the item is stand-alone, and in such situations is equivalent to the level-number 01. For example, the following code declares two 77-level data items,  and , which are non-group data items that are independent of (not subordinate to) any other data items:\n\n       77  property-name      PIC X(80).\n       77  sales-region       PIC 9(5).\n\nAn 88 level-number declares a ' (a so-called 88-level) which is true when its parent data item contains one of the values specified in its  clause. For example, the following code defines two 88-level condition-name items that are true or false depending on the current character data value of the  data item. When the data item contains a value of , the condition-name  is true, whereas when it contains a value of  or , the condition-name  is true. If the data item contains some other value, both of the condition-names are false.\n\n       01  wage-type          PIC X.\n           88  wage-is-hourly VALUE \"H\".\n           88  wage-is-yearly VALUE \"S\", \"Y\".\n\nData types\n\nStandard COBOL provides the following data types:\n\nType safety is variable in COBOL. Numeric data is converted between different representations and sizes silently and alphanumeric data can be placed in any data item that can be stored as a string, including numeric and group data. In contrast, object references and pointers may only be assigned from items of the same type and their values may be restricted to a certain type.\n\nPICTURE clause\n\nA  (or ) clause is a string of characters, each of which represents a portion of the data item and what it may contain. Some picture characters specify the type of the item and how many characters or digits it occupies in memory. For example, a  indicates a decimal digit, and an  indicates that the item is signed. Other picture characters (called ' and ' characters) specify how an item should be formatted. For example, a series of  characters define character positions as well as how a leading sign character is to be positioned within the final character data; the rightmost non-numeric character will contain the item's sign, while other character positions corresponding to a  to the left of this position will contain a space. Repeated characters can be specified more concisely by specifying a number in parentheses after a picture character; for example,  is equivalent to . Picture specifications containing only digit () and sign () characters define purely ' data items, while picture specifications containing alphabetic () or alphanumeric () characters define ' data items. The presence of other formatting characters define ' or ' data items.\n\nUSAGE clause\n\nThe  clause declares the format data is stored in. Depending on the data type, it can either complement or be used instead of a  clause. While it can be used to declare pointers and object references, it is mostly geared towards specifying numeric types. These numeric formats are:\n\n* Binary, where a minimum size is either specified by the PICTURE clause or by a USAGE clause such as BINARY-LONG.\n* , where data may be stored in whatever format the implementation provides; often equivalent to Â \n* , the default format, where data is stored as a string\n* Floating-point, in either an implementation-dependent format or according to IEEE 754.\n* , where data is stored as a string using an extended character set\n* , where data is stored in the smallest possible decimal format (typically packed binary-coded decimal)\n\nReport writer\n\nThe report writer is a declarative facility for creating reports. The programmer need only specify the report layout and the data required to produce it, freeing them from having to write code to handle things like page breaks, data formatting, and headings and footings.\n\nReports are associated with report files, which are files which may only be written to through report writer statements.\n\n       FD  report-out REPORT sales-report.\n\nEach report is defined in the report section of the data division. A report is split into report groups which define the report's headings, footings and details. Reports work around hierarchical '. Control breaks occur when a key variable changes it value; for example, when creating a report detailing customers' orders, a control break could occur when the program reaches a different customer's orders. Here is an example report description for a report which gives a salesperson's sales and which warns of any invalid records:\n\n       RD  sales-report\n           PAGE LIMITS 60 LINES\n           FIRST DETAIL 3\n           CONTROLS seller-name.\n\n       01  TYPE PAGE HEADING.\n           03  COL 1                    VALUE \"Sales Report\".\n           03  COL 74                   VALUE \"Page\".\n           03  COL 79                   PIC Z9 SOURCE PAGE-COUNTER.\n\n       01  sales-on-day TYPE DETAIL, LINE + 1.\n           03  COL 3                    VALUE \"Sales on\".\n           03  COL 12                   PIC 99/99/9999 SOURCE sales-date.\n           03  COL 21                   VALUE \"were\".\n           03  COL 26                   PIC $$$$9.99 SOURCE sales-amount.\n\n       01  invalid-sales TYPE DETAIL, LINE + 1.\n           03  COL 3                    VALUE \"INVALID RECORD:\".\n           03  COL 19                   PIC X(34) SOURCE sales-record.\n\n       01  TYPE CONTROL HEADING seller-name, LINE + 2.\n           03  COL 1                    VALUE \"Seller:\".\n           03  COL 9                    PIC X(30) SOURCE seller-name.\n\nThe above report description describes the following layout:\n\nSales Report                                                             Page  1\n\nSeller: Howard Bromberg\n  Sales on 10/12/2008 were $1000.00\n  Sales on 12/12/2008 were    $0.00\n  Sales on 13/12/2008 were   $31.47\n  INVALID RECORD: Howard Bromberg             XXXXYY\n\nSeller: Howard Discount\n...\nSales Report                                                            Page 12\n\n  Sales on 08/05/2014 were  $543.98\n  INVALID RECORD: William Selden      12O52014FOOFOO\n  Sales on 30/05/2014 were    $0.00\n\nFour statements control the report writer: , which prepares the report writer for printing; , which prints a report group; , which suppresses the printing of a report group; and , which terminates report processing. For the above sales report example, the procedure division might look like this:\n\n           OPEN INPUT sales, OUTPUT report-out\n           INITIATE sales-report\n \n           PERFORM UNTIL 1 <> 1\n               READ sales\n                   AT END\n                       EXIT PERFORM\n               END-READ\n \n               VALIDATE sales-record\n               IF valid-record\n                   GENERATE sales-on-day\n               ELSE\n                   GENERATE invalid-sales\n               END-IF\n           END-PERFORM\n \n           TERMINATE sales-report\n           CLOSE sales, report-out\n           .\n\nProcedure division\n\nProcedures\n\nThe sections and paragraphs in the procedure division (collectively called procedures) can be used as labels and as simple subroutines. Unlike in other divisions, paragraphs do not need to be in sections.\nExecution goes down through the procedures of a program until it is terminated.\nTo use procedures as subroutines, the  verb is used. This transfers control to the specified range of procedures and returns only upon reaching the end.\n\nUnusual control flow can trigger ', which cause control in performed procedures to return at unexpected times to unexpected locations. Procedures can be reached in three ways: they can be called with , jumped to from a  or through execution \"falling through\" the bottom of an above paragraph. Combinations of these invoke undefined behavior, creating mines. Specifically, mines occur when execution of a range of procedures would cause control flow to go past the last statement of a range of procedures already being performed.\n\nFor example, in the code in the adjacent image, a mine is tripped at the end of  when the screen is invalid. When the screen is invalid, control jumps to the  section, which, when done, performs . This recursion triggers undefined behavior as there are now two overlapping ranges of procedures being performed. The mine is then triggered upon reaching the end of  and means control could return to one of two locations:\n\n* The first  statement\n* The  statement in , where it would then \"fall-through\" into  and return to the first  statement upon reaching the end.\n\nStatements\n\nCOBOL 2014 has 47 statements (also called '), which can be grouped into the following broad categories: control flow, I/O, data manipulation and the report writer. The report writer statements are covered in the report writer section.\n\nControl flow\n\nCOBOL's conditional statements are  and .  is a switch-like statement with the added capability of evaluating multiple values and conditions. This can be used to implement decision tables. For example, the following might be used to control a CNC lathe: \n\nEVALUATE TRUE ALSO desired-speed ALSO current-speed\n    WHEN lid-closed ALSO min-speed THRU max-speed ALSO LESS THAN desired-speed\n        PERFORM speed-up-machine\n    WHEN lid-closed ALSO min-speed THRU max-speed ALSO GREATER THAN desired-speed\n        PERFORM slow-down-machine\n    WHEN lid-open ALSO ANY ALSO NOT ZERO\n        PERFORM emergency-stop\n    WHEN OTHER\n        CONTINUE\nEND-EVALUATE\n\nThe  statement is used to define loops which are executed  a condition is true (not  true, which is more common in other languages). It is also used to call procedures or ranges of procedures (see the procedures section for more details).  and  call subprograms and methods, respectively. The name of the subprogram/method is contained in a string which may be a literal or a data item. Parameters can be passed by reference, by content (where a copy is passed by reference) or by value (but only if a prototype is available).\n unloads subprograms from memory.  causes the program to jump to a specified procedure.\n\nThe  statement is a return statement and the  statement stops the program. The  statement has six different formats: it can be used as a return statement, a break statement, a continue statement, an end marker or to leave a procedure.\n\nExceptions are raised by a  statement and caught with a handler, or ', defined in the  portion of the procedure division. Declaratives are sections beginning with a  statement which specify the errors to handle. Exceptions can be names or objects.  is used in a declarative to jump to the statement after the one that raised the exception or to a procedure outside the . Unlike other languages, uncaught exceptions may not terminate the program and the program can proceed unaffected.\n\nI/O\n\nFile I/O is handled by the self-describing , , , and  statements along with a further three: , which updates a record; , which selects subsequent records to access by finding a record with a certain key; and , which releases a lock on the last record accessed.\n\nUser interaction is done using  and .\n\nData manipulation\n\nThe following verbs manipulate data:\n* , which sets data items to their default values.\n* , which assigns values to data items.\n* , which has 15 formats: it can modify indices, assign object references and alter table capacities, among other functions.\n* , , , , and , which handle arithmetic (with  assigning the result of a formula to a variable).\n*  and , which handle dynamic memory.\n* , which validates and distributes data as specified in an item's description in the data division.\n*  and , which concatenate and split strings, respectively.\n* , which tallies or replaces instances of specified substrings within a string.\n* , which searches a table for the first entry satisfying a condition.\n\nFiles and tables are sorted using  and the  verb merges and sorts files. The  verb provides records to sort and  retrieves sorted records in order.\n\nScope termination\n\nSome statements, such as  and , may themselves contain statements. Such statements may be terminated in two ways: by a period ('), which terminates all unterminated statements contained, or by a scope terminator, which terminates the nearest matching open statement.\n\n*> Terminator period (\"implicit termination\")\nIF invalid-record\n    IF no-more-records\n        NEXT SENTENCE\n    ELSE\n        READ record-file\n            AT END SET no-more-records TO TRUE.\n\n*> Scope terminators (\"explicit termination\")\nIF invalid-record\n    IF no-more-records\n        CONTINUE\n    ELSE\n        READ record-file\n            AT END SET no-more-records TO TRUE\n        END-READ\n    END-IF\nEND-IF\n\nNested statements terminated with a period are a common source of bugs. For example, examine the following code:\n\nIF x\n    DISPLAY y.\n    DISPLAY z.\n\nHere, the intent is to display y and z if condition x is true. However, z will be displayed whatever the value of x because the IF statement is terminated by an erroneous period after .\n\nAnother bug is a result of the dangling else problem, when two IF statements can associate with an ELSE.\n\nIF x\n    IF y\n        DISPLAY a\nELSE\n    DISPLAY b.\n\nIn the above fragment, the ELSE associates with the Â Â  statement instead of the Â Â  statement, causing a bug. Prior to the introduction of explicit scope terminators, preventing it would require Â Â  to be placed after the inner IF.\n\nSelf-modifying code\n\nThe original (1959) COBOL specification supported the infamous Â Â  statement, for which many compilers generated self-modifying code. X and Y are procedure labels, and the single Â Â  statement in procedure X executed after such an  statement means Â Â  instead. Many compilers still support it,Examples of compiler support for  can be seen in the following:\n\n* \n* \n* \n* \nbut it was deemed obsolete in the COBOL 1985 standard and deleted in 2002.\n\nHello, world\n\nA \"Hello, world\" program in COBOL:\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. hello-world.\n       PROCEDURE DIVISION.\n           DISPLAY \"Hello, world!\"\n           .\n\nWhen the â now famous â \"Hello, World!\" program example in The C Programming Language was first published in 1978 a similar mainframe COBOL program sample would have been submitted through JCL, very likely using a punch card reader, and 80 column punch cards.  The listing below, with an empty DATA DIVISION, was tested using GNU/Linux and the System/370 Hercules emulator running MVS 3.8J.  The JCL, written in July 2015, is derived from the Hercules tutorials and samples hosted by Jay Moseley.  In keeping with COBOL programming of that era, HELLO, WORLD is displayed in all capital letters.\n\n//COBUCLG  JOB (001),'COBOL BASE TEST',                                 00010000\n//             CLASSA,MSGCLASS\nA,MSGLEVEL=(1,1)                        00020000\n//BASETEST EXEC COBUCLG                                                 00030000\n//COB.SYSIN DD *                                                        00040000\n 00000* VALIDATION OF BASE COBOL INSTALL                                00050000\n 01000 IDENTIFICATION DIVISION.                                         00060000\n 01100 PROGRAM-ID. 'HELLO'.                                             00070000\n 02000 ENVIRONMENT DIVISION.                                            00080000\n 02100 CONFIGURATION SECTION.                                           00090000\n 02110 SOURCE-COMPUTER.  GNULINUX.                                      00100000\n 02120 OBJECT-COMPUTER.  HERCULES.                                      00110000\n 02200 SPECIAL-NAMES.                                                   00120000\n 02210     CONSOLE IS CONSL.                                            00130000\n 03000 DATA DIVISION.                                                   00140000\n 04000 PROCEDURE DIVISION.                                              00150000\n 04100 00-MAIN.                                                         00160000\n 04110     DISPLAY 'HELLO, WORLD' UPON CONSL.                           00170000\n 04900     STOP RUN.                                                    00180000\n//LKED.SYSLIB DD DSNAMESYS1.COBLIB,DISP\nSHR                            00190000\n//            DD DSNAMESYS1.LINKLIB,DISP\nSHR                           00200000\n//GO.SYSPRINT DD SYSOUT=A                                               00210000\n//                                                                      00220000\n\nAfter submitting the JCL, the MVS console displayed:\n\n    19.52.48 JOB    3  $HASP100 COBUCLG  ON READER1     COBOL BASE TEST\n    19.52.48 JOB    3  IEF677I WARNING MESSAGE(S) FOR JOB COBUCLG  ISSUED\n    19.52.48 JOB    3  $HASP373 COBUCLG  STARTED - INIT  1 - CLASS A - SYS BSP1\n    19.52.48 JOB    3  IEC130I SYSPUNCH DD STATEMENT MISSING\n    19.52.48 JOB    3  IEC130I SYSLIB   DD STATEMENT MISSING\n    19.52.48 JOB    3  IEC130I SYSPUNCH DD STATEMENT MISSING\n    19.52.48 JOB    3  IEFACTRT - Stepname  Procstep  Program   Retcode\n    19.52.48 JOB    3  COBUCLG    BASETEST  COB       IKFCBL00  RC= 0000\n    19.52.48 JOB    3  COBUCLG    BASETEST  LKED      IEWL      RC= 0000\n    19.52.48 JOB    3  +HELLO, WORLD\n    19.52.48 JOB    3  COBUCLG    BASETEST  GO        PGM*.DD  RC\n 0000\n    19.52.48 JOB    3  $HASP395 COBUCLG  ENDED\n\nLine 10 of the console listing above is highlighted for effect, the highlighting is not part of the actual console output.\n\nThe associated compiler listing generated over four pages of technical detail and job run information, for the single line of output from the 14 lines of COBOL.\n\nCriticism and defense\n\nLack of structure\n\nIn the 1970s, adoption of the structured programming paradigm was becoming increasingly widespread. Edsger Dijkstra, a preeminent computer scientist, wrote a letter to the editor of Communications of the ACM, published 1975 entitled \"How do we tell truths that might hurt?\", in which he was critical of COBOL and several other contemporary languages; remarking that \"the use of COBOL cripples the mind\".\nIn a published dissent to Dijkstra's remarks, the computer scientist Howard E. Tompkins claimed that unstructured COBOL tended to be \"written by programmers that have never had the benefit of structured COBOL taught well\", arguing that the issue was primarily one of training.\n\nOne cause of spaghetti code was the  statement. Attempts to remove s from COBOL code, however, resulted in convoluted programs and reduced code quality. s were largely replaced by the  statement and procedures, which promoted modular programming and gave easy access to powerful looping facilities. However,  could only be used with procedures so loop bodies were not located where they were used, making programs harder to understand.\n\nCOBOL programs were infamous for being monolithic and lacking modularization.\nCOBOL code could only be modularized through procedures, which were found to be inadequate for large systems. It was impossible to restrict access to data, meaning a procedure could access and modify  data item. Furthermore, there was no way to pass parameters to a procedure, an omission Jean Sammet regarded as the committee's biggest mistake.\nAnother complication stemmed from the ability to  a specified sequence of procedures. This meant that control could jump to and return from any procedure, creating convoluted control flow and permitting a programmer to break the single-entry single-exit rule.\n\nThis situation improved as COBOL adopted more features. COBOL-74 added subprograms, giving programmers the ability to control the data each part of the program could access. COBOL-85 then added nested subprograms, allowing programmers to hide subprograms. Further control over data and code came in 2002 when object-oriented programming, user-defined functions and user-defined data types were included.\n\nNevertheless, much important legacy COBOL software uses unstructured code, which has become unmaintainable.  It can be too risky and costly to modify even a simple section of code, since it may be used from unknown places in unknown ways.\n\nCompatibility issues\n\nCOBOL was intended to be a highly portable, \"common\" language. However, by 2001, around 300 dialects had been created. One source of dialects was the standard itself: the 1974 standard was composed of one mandatory nucleus and eleven functional modules, each containing two or three levels of support. This permitted 104,976 official variants.\n\nCOBOL-85 was not fully compatible with earlier versions, and its development was controversial. Joseph T. Brophy, the CIO of Travelers Insurance, spearheaded an effort to inform COBOL users of the heavy reprogramming costs of implementing the new standard. As a result, the ANSI COBOL Committee received more than 2,200 letters from the public, mostly negative, requiring the committee to make changes.  On the other hand, conversion to COBOL-85 was thought to increase productivity in future years, thus justifying the conversion costs.\n\nVerbose syntax\n\nCOBOL syntax has often been criticized for its verbosity. Proponents say that this was intended to make the code self-documenting, easing program maintenance. COBOL was also intended to be easy for programmers to learn and use, while still being readable to non-technical staff such as managers.\nThe desire for readability led to the use of English-like syntax and structural elements, such as nouns, verbs, clauses, sentences, sections, and divisions.  Yet by 1984, maintainers of COBOL programs were struggling to deal with \"incomprehensible\" code and the main changes in COBOL-85 were there to help ease maintenance.\n\nJean Sammet, a short-range committee member, noted that \"little attempt was made to cater to the professional programmer, in fact people whose main interest is programming tend to be very unhappy with COBOL\" which she attributed to COBOL's verbose syntax.\n\nIsolation from the computer science community\n\nThe COBOL community has always been isolated from the computer science community. No academic computer scientists participated in the design of COBOL: all of those on the committee came from commerce or government.  Computer scientists at the time were more interested in fields like numerical analysis, physics and system programming than the commercial file-processing problems which COBOL development tackled. Jean Sammet attributed COBOL's unpopularity to an initial \"snob reaction\" due to its inelegance, the lack of influential computer scientists participating in the design process and a disdain for business data processing. The COBOL specification used a unique \"notation\", or metalanguage, to define its syntax rather than the new BackusâNaur form because few committee members had heard of it. This resulted in \"severe\" criticism.\n\nLater, COBOL suffered from a shortage of material covering it; it took until 1963 for introductory books to appear (with Richard D. Irwin publishing a college textbook on COBOL in 1966).https://books.bibliopolis.com/main/find/2200821/COBOL-Logic-and-Programming-third-edition-1974-McCameron-Fritz-oldcomputerbooks-com.html    By 1985, there were twice as many books on Fortran and four times as many on BASIC as on COBOL in the Library of Congress.  University professors taught more modern, state-of-the-art languages and techniques instead of COBOL which was said to have a \"trade school\" nature. Donald Nelson, chair of the CODASYL COBOL committee, said in 1984 that \"academics ... hate COBOL\" and that computer science graduates \"had 'hate COBOL' drilled into them\". A 2013 poll by Micro Focus found that 20% of university academics thought COBOL was outdated or dead and that 55% believed their students thought COBOL was outdated or dead. The same poll also found that only 25% of academics had COBOL programming on their curriculum even though 60% thought they should teach it.\nIn contrast, in 2003, COBOL featured in 80% of information systems curricula in the United States, the same proportion as C++ and Java.\n\nThere was also significant condescension towards COBOL in the business community from users of other languages, for example FORTRAN or assembler, implying that COBOL could be used only for non-challenging problems.\n\nConcerns about the design process\n\nDoubts have been raised about the competence of the standards committee. Short-term committee member Howard Bromberg said that there was \"little control\" over the development process and that it was \"plagued by discontinuity of personnel and ... a lack of talent.\" Jean Sammet and Jerome Garfunkel also noted that changes introduced in one revision of the standard would be reverted in the next, due as much to changes in who was in the standard committee as to objective evidence.\n\nCOBOL standards have repeatedly suffered from delays: COBOL-85 arrived five years later than hoped,\nCOBOL 2002 was five years late,\nand COBOL 2014 was six years late.\nTo combat delays, the standard committee allowed the creation of optional addenda which would add features more quickly than by waiting for the next standard revision. However, some committee members raised concerns about incompatibilities between implementations and frequent modifications of the standard.\n\nInfluences on other languages\n\nCOBOL's data structures influenced subsequent programming languages. Its record and file structure influenced PL/I and Pascal, and the REDEFINES clause was a predecessor to Pascal's variant records. Explicit file structure definitions preceded the development of database management systems and aggregated data was a significant advance over Fortran's arrays.\nPICTURE data declarations were incorporated into PL/I, with minor changes.\n\nCOBOL's  facility, although considered \"primitive\",\ninfluenced the development of include directives.\n\nThe focus on portability and standardization meant programs written in COBOL could be portable and facilitated the spread of the language to a wide variety of hardware platforms and operating systems.This can be seen in:\n\n* \n* \n*  Additionally, the well-defined division structure restricts the definition of external references to the Environment Division, which simplifies platform changes in particular.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "COBOL" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=6799" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "COBOL (, an acronym for common business-oriented language) is a compiled English-like computer programming language designed for business use. It is imperative, procedural and, since 2002, object-oriented. COBOL is primarily used in business, finance, and administrative systems for companies and governments.  COBOL is still widely used in legacy applications deployed on mainframe computers, such as large-scale batch and transaction processing jobs. But due to its declining popularity and the retirement of experienced COBOL programmers, programs are being migrated to new platforms, rewritten in modern languages or replaced with software packages. Most programming in COBOL is now purely to maintain existing applications.\n\nCOBOL was designed in 1959 by CODASYL and was partly based on previous programming language design work by Grace Hopper, commonly referred to as \"the (grand)mother of COBOL\". It was created as part of a US Department of Defense effort to create a portable programming language for data processing. Intended as a stopgap, the Department of Defense promptly forced computer manufacturers to provide it, resulting in its widespread adoption. It was standardized in 1968 and has since been revised four times. Expansions include support for structured and object-oriented programming. The current standard is ISO/IEC 1989:2014.\n\nCOBOL has an English-like syntax, which was designed to be self-documenting and highly readable. However, it is verbose and uses over 300 reserved words. In contrast with modern, succinct syntax like , COBOL has a more English-like syntax (in this case, ).\nCOBOL code is split into four divisions (identification, environment, data and procedure) containing a rigid hierarchy of sections, paragraphs and sentences. Lacking a large standard library, the standard specifies 43 statements, 87 functions and just one class.\n\nAcademic computer scientists were generally uninterested in business applications when COBOL was created and were not involved in its design; it was (effectively) designed from the ground up as a computer language for business, with an emphasis on inputs and outputs, whose only data types were numbers and strings of text.http://cs.brown.edu/~adf/programming_languages.html\nCOBOL has been criticized throughout its life, however, for its verbosity, design process and poor support for structured programming, which resulted in monolithic and incomprehensible programs.\n\nHistory and specification\n\nBackground\n\nIn the late 1950s, computer users and manufacturers were becoming concerned about the rising cost of programming. A 1959 survey had found that in any data processing installation, the programming cost US$800,000 on average and that translating programs to run on new hardware would cost $600,000. At a time when new programming languages were proliferating at an ever-increasing rate, the same survey suggested that if a common business-oriented language were used, conversion would be far cheaper and faster.\n\nIn April 1959, Mary K. Hawes called a meeting of representatives from academia, computer users, and manufacturers at the University of Pennsylvania to organize a formal meeting on common business languages. Representatives included Grace Hopper, inventor of the English-like data processing language FLOW-MATIC, Jean Sammet and Saul Gorn.\n\nThe group asked the Department of Defense (DoD) to sponsor an effort to create a common business language. The delegation impressed Charles A. Phillips, director of the Data System Research Staff at the DoD, who thought that they \"thoroughly understood\" the DoD's problems. The DoD operated 225 computers, had a further 175 on order and had spent over $200 million on implementing programs to run on them. Portable programs would save time, reduce costs and ease modernization.\n\nPhillips agreed to sponsor the meeting and tasked the delegation with drafting the agenda.\n\nCOBOL 60\n\nOn May 28 and 29 of 1959 (exactly one year after the ZÃ¼rich ALGOL 58 meeting), a meeting was held at the Pentagon to discuss the creation of a common programming language for business. It was attended by 41 people and was chaired by Phillips. The Department of Defense was concerned about whether it could run the same data processing programs on different computers. FORTRAN, the only mainstream language at the time, lacked the features needed to write such programs.\n\nRepresentatives enthusiastically described a language that could work in a wide variety of environments, from banking and insurance to utilities and inventory control. They agreed unanimously that more people should be able to program and that the new language should not be restricted by the limitations of contemporary technology. A majority agreed that the language should make maximal use of English, be capable of change, be machine-independent and be easy to use, even at the expense of power.\n\nThe meeting resulted in the creation of a steering committee and short-, intermediate- and long-range committees. The short-range committee was given to September (three months) to produce specifications for an interim language, which would then be improved upon by the other committees. Their official mission, however, was to identify the strengths and weaknesses of existing programming languages and did not explicitly direct them to create a new language.\nThe deadline was met with disbelief by the short-range committee.\nOne member, Betty Holberton, described the three-month deadline as \"gross optimism\" and doubted that the language really would be a stopgap.\n\nThe steering committee met on June 4 and agreed to name the entire activity as the Committee on Data Systems Languages, or CODASYL, and to form an executive committee.\n\nThe short-range committee was made up of members representing six computer manufacturers and three government agencies. The six computer manufacturers were Burroughs Corporation, IBM, Minneapolis-Honeywell (Honeywell Labs), RCA, Sperry Rand, and Sylvania Electric Products. The three government agencies were the US Air Force, the Navy's David Taylor Model Basin, and the National Bureau of Standards (now the National Institute of Standards and Technology). The committee was chaired by Joseph Wegstein of the US National Bureau of Standards. Work began by investigating data description, statements, existing applications and user experiences.\n\nThe committee mainly examined the FLOW-MATIC, AIMACO and COMTRAN programming languages.\nThe FLOW-MATIC language was particularly influential because it had been implemented and because AIMACO was a derivative of it with only minor changes.\nFLOW-MATIC's inventor, Grace Hopper, also served as a technical adviser to the committee. FLOW-MATIC's major contributions to COBOL were long variable names, English words for commands and the separation of data descriptions and instructions.\n\nIBM's COMTRAN language, invented by Bob Bemer, was regarded as a competitor to FLOW-MATIC by a short-range committee made up of colleagues of Grace Hopper.\nSome of its features were not incorporated into COBOL so that it would not look like IBM had dominated the design process, and Jean Sammet said in 1981 that there had been a \"strong anti-IBM bias\" from some committee members (herself included).\nIn one case, after Roy Goldfinger, author of the COMTRAN manual and intermediate-range committee member, attended a subcommittee meeting to support his language and encourage the use of algebraic expressions, Grace Hopper sent a memo to the short-range committee reiterating Sperry Rand's efforts to create a language based on English.\nIn 1980, Grace Hopper commented that \"COBOL 60 is 95% FLOW-MATIC\" and that COMTRAN had had an \"extremely small\" influence. Furthermore, she said that she would claim that work was influenced by both FLOW-MATIC and COMTRAN only to \"keep other people happy [so they] wouldn't try to knock us out\".\nFeatures from COMTRAN incorporated into COBOL included formulas, the  clause, an improved IF statement, which obviated the need for GO TOs, and a more robust file management system.\n\nThe usefulness of the committee's work was subject of great debate. While some members thought the language had too many compromises and was the result of design by committee, others felt it was better than the three languages examined. Some felt the language was too complex; others, too simple.\nControversial features included those some considered useless or too advanced for data processing users. Such features included boolean expressions, formulas and table ' (indices). Another point of controversy was whether to make keywords context-sensitive and the effect that would have on readability. Although context-sensitive keywords were rejected, the approach was later used in PL/I and partially in COBOL from 2002. Little consideration was given to interactivity, interaction with operating systems (few existed at that time) and functions (thought of as purely mathematical and of no use in data processing).\n\nThe specifications were presented to the Executive Committee on September 4. They fell short of expectations: Joseph Wegstein noted that \"it contains rough spots and requires some additions\", and Bob Bemer later described them as a \"hodgepodge\". The subcommittee was given until December to improve it.\n\nAt a mid-September meeting, the committee discussed the new language's name. Suggestions included \"BUSY\" (Business System), \"INFOSYL\" (Information System Language) and \"COCOSYL\" (Common Computer Systems Language). The name \"COBOL\" was suggested by Bob Bemer.\n\nIn October, the intermediate-range committee received copies of the FACT language specification created by Roy Nutt. Its features impressed the committee so much that they passed a resolution to base COBOL on it.\nThis was a blow to the short-range committee, who had made good progress on the specification. Despite being technically superior, FACT had not been created with portability in mind or through manufacturer and user consensus. It also lacked a demonstrable implementation, allowing supporters of a FLOW-MATIC-based COBOL to overturn the resolution. RCA representative Howard Bromberg also blocked FACT, so that RCA's work on a COBOL implementation would not go to waste.\n\nIt soon became apparent that the committee was too large for any further progress to be made quickly. A frustrated Howard Bromberg bought a $15 tombstone with \"COBOL\" engraved on it and sent it to Charles Phillips to demonstrate his displeasure.\nA sub-committee was formed to analyze existing languages and was made up of six individuals:\n\n* William Selden and Gertrude Tierney of IBM,\n* Howard Bromberg and Howard Discount of RCA,\n* Vernon Reeves and Jean E. Sammet of Sylvania Electric Products.\n\nThe sub-committee did most of the work creating the specification, leaving the short-range committee to review and modify their work before producing the finished specification.\n\nThe specifications were approved by the Executive Committee on January 3, 1960, and sent to the government printing office, which printed these as COBOL 60. The language's stated objectives were to allow efficient, portable programs to be easily written, to allow users to move to new systems with minimal effort and cost, and to be suitable for inexperienced programmers.\nThe CODASYL Executive Committee later created the COBOL Maintenance Committee to answer questions from users and vendors and to improve and expand the specifications.\n\nDuring 1960, the list of manufacturers planning to build COBOL compilers grew. By September, five more manufacturers had joined CODASYL (Bendix, Control Data Corporation, General Electric (GE), National Cash Register and Philco), and all represented manufacturers had announced COBOL compilers. GE and IBM planned to integrate COBOL into their own languages, GECOM and COMTRAN, respectively. In contrast, International Computers and Tabulators planned to replace their language, CODEL, with COBOL.\n\nMeanwhile, RCA and Sperry Rand worked on creating COBOL compilers. The first COBOL program ran on 17 August on an RCA 501.\nOn December 6 and 7, the same COBOL program (albeit with minor changes) ran on an RCA computer and a Remington-Rand Univac computer, demonstrating that compatibility could be achieved.\n\nThe relative influences of which languages were used continues to this day in the recommended advisory printed in all COBOL reference manuals:\n\nCOBOL-61 to COBOL-65\n\nMany logical flaws were found in COBOL 60, leading GE's Charles Katz to warn that it could not be interpreted unambiguously. A reluctant short-term committee enacted a total cleanup and, by March 1963, it was reported that COBOL's syntax was as definable as ALGOL's, although semantic ambiguities remained.\n\nEarly COBOL compilers were primitive and slow. A 1962 US Navy evaluation found compilation speeds of 3â11 statements per minute. By mid-1964, they had increased to 11â1000 statements per minute. It was observed that increasing memory would drastically increase speed and that compilation costs varied wildly: costs per statement were between $0.23 and $18.91.\n\nIn late 1962, IBM announced that COBOL would be their primary development language and that development of COMTRAN would cease.\n\nThe COBOL specification was revised three times in the five years after its publication.\nCOBOL-60 was replaced in 1961 by COBOL-61. This was then replaced by the COBOL-61 Extended specifications in 1963, which introduced the sort and report writer facilities.\nThe added facilities corrected flaws identified by Honeywell in late 1959 in a letter to the short-range committee.\nCOBOL Edition 1965 brought further clarifications to the specifications and introduced facilities for handling mass storage files and tables.\n\nCOBOL-68\n\nEfforts began to standardize COBOL to overcome incompatibilities between versions. In late 1962, both ISO and the United States of America Standards Institute (now ANSI) formed groups to create standards. ANSI produced USA Standard COBOL X3.23 in August 1968, which became the cornerstone for later versions. This version was known as American National Standard (ANS) COBOL and was adopted by ISO in 1972.\n\nCOBOL-74\n\nBy 1970, COBOL had become the most widely used programming language in the world.\n\nIndependently of the ANSI committee, the CODASYL Programming Language Committee was working on improving the language. They described new versions in 1968, 1969, 1970 and 1973, including changes such as new inter-program communication, debugging and file merging facilities as well as improved string-handling and library inclusion features.\nAlthough CODASYL was independent of the ANSI committee, the CODASYL Journal of Development was used by ANSI to identify features that were popular enough to warrant implementing.\nThe Programming Language Committee also liaised with ECMA and the Japanese COBOL Standard committee.\n\nThe Programming Language Committee was not well-known, however. The vice-president, William Rinehuls, complained that two-thirds of the COBOL community did not know of the committee's existence. It was also poor, lacking the funds to make public documents, such as minutes of meetings and change proposals, freely available.\n\nIn 1974, ANSI published a revised version of (ANS) COBOL, containing new features such as file organizations, the  statement and the segmentation module.\nDeleted features included the  statement, the  statement (which was replaced by ) and the implementer-defined random access module (which was superseded by the new sequential and relative I/O modules). These made up 44 changes, which rendered existing statements incompatible with the new standard.\nThe report writer was slated to be removed from COBOL, but was reinstated before the standard was published. ISO later adopted the updated standard in 1978.\n\nCOBOL-85\n\nIn June 1978, work began on revising COBOL-74. The proposed standard (commonly called COBOL-80) differed significantly from the previous one, causing concerns about incompatibility and conversion costs. In January 1981, Joseph T. Brophy, Senior Vice-President of Travelers Insurance, threatened to sue the standard committee because it was not upwards compatible with COBOL-74. Mr. Brophy described previous conversions of their 40-million-line code base as \"non-productive\" and a \"complete waste of our programmer resources\".\nLater that year, the Data Processing Management Association (DPMA) said it was \"strongly opposed\" to the new standard, citing \"prohibitive\" conversion costs and enhancements that were \"forced on the user\".\n\nDuring the first public review period, the committee received 2,200 responses, of which 1,700 were negative form letters.\nOther responses were detailed analyses of the effect COBOL-80 would have on their systems; conversion costs were predicted to be at least 50 cents per line of code. Fewer than a dozen of the responses were in favor of the proposed standard.\n\nIn 1983, the DPMA withdrew its opposition to the standard, citing the responsiveness of the committee to public concerns. In the same year, a National Bureau of Standards study concluded that the proposed standard would present few problems. A year later, a COBOL-80 compiler was released to DEC VAX users, who noted that conversion of COBOL-74 programs posed few problems. The new EVALUATE statement and inline PERFORM were particularly well received and improved productivity, thanks to simplified control flow and debugging.\n\nThe second public review drew another 1,000 (mainly negative) responses, while the last drew just 25, by which time many concerns had been addressed.\n\nIn late 1985, ANSI published the revised standard. Sixty features were changed or deprecated and many were added, such as:\n\n* Scope terminators (END-IF, END-PERFORM, END-READ, etc.)\n* Nested subprograms\n* CONTINUE, a no-operation statement\n* EVALUATE, a switch statement\n* INITIALIZE, a statement that can set groups of data to their default values\n* Inline PERFORM loop bodies â previously, loop bodies had to be specified in a separate procedure\n* Reference modification, which allows access to substrings\n* I/O status codes.\n\nThe standard was adopted by ISO the same year. Two amendments followed in 1989 and 1993, the first introducing intrinsic functions and the other providing corrections. ISO adopted the amendments in 1991 and 1994 respectively, before subsequently taking primary ownership and development of the standard.\n\nCOBOL 2002 and object-oriented COBOL\n\nIn 1997, Gartner Group estimated that there were a total of 200 billion lines of COBOL in existence, which ran 80% of all business programs.\n\nIn the early 1990s, work began on adding object-orientation in the next full revision of COBOL. Object-oriented features were taken from C++ and Smalltalk.\nThe initial estimate was to have this revision completed by 1997, and an ISO Committee Draft (CD) was available by 1997. Some vendors (including Micro Focus, Fujitsu, and IBM) introduced object-oriented syntax based on drafts of the full revision. The final approved ISO standard was approved and published in late 2002.\n\nFujitsu/GTSoftware, Micro Focus and RainCode introduced object-oriented COBOL compilers targeting the .NET Framework.\n\nThere were many other new features, many of which had been in the CODASYL COBOL Journal of Development since 1978 and had missed the opportunity to be included in COBOL-85. These other features included:\n\n* Free-form code\n* User-defined functions\n* Recursion\n* Locale-based processing\n* Support for extended character sets such as Unicode\n* Floating-point and binary data types (until then, binary items were truncated based on their declaration's base-10 specification)\n* Portable arithmetic results\n*Bit and boolean data types\n* Pointers and syntax for getting and freeing storage\n* The  for text-based user interfaces\n* The  facility\n* Improved interoperability with other programming languages and framework environments such as .NET and Java.\n\nThree corrigenda were published for the standard: two in 2006 and one in 2009.\n\nCOBOL 2014\n\nBetween 2003 and 2009, three technical reports were produced describing object finalization, XML processing and collection classes for COBOL.\n\nCOBOL 2002 suffered from poor support: no compilers completely supported the standard. Micro Focus found that it was due to a lack of user demand for the new features and due to the abolition of the NIST test suite, which had been used to test compiler conformance. The standardization process was also found to be slow and under-resourced.\n\nCOBOL 2014 includes the following changes:\n* Portable arithmetic results have been replaced by IEEE 754 data types\n* Major features have been made optional, such as the VALIDATE facility, the report writer and the screen-handling facility.\n* Method overloading\n* Dynamic capacity tables (a feature dropped from the draft of COBOL 2002)\n\nLegacy\n\nCOBOL programs are used globally in governments and businesses and are running on diverse operating systems such as z/OS, z/VSE, VME, Unix, OpenVMS and Windows.  In 1997, the Gartner Group reported that 80% of the world's business ran on COBOL with over 200 billion lines of code and 5 billion lines more being written annually.\n\nNear the end of the 20th century, the year 2000 problem (Y2K) was the focus of significant COBOL programming effort, sometimes by the same programmers who had designed the systems decades before. The particular level of effort required to correct COBOL code has been attributed to the large amount of business-oriented COBOL, as business applications use dates heavily, and to fixed-length data fields. After the clean-up effort put into these programs for Y2K, a 2003 survey found that many remained in use.\nThe authors said that the survey data suggest \"a gradual decline in the importance of Cobol in application development over the [following] 10 years unless ... integration with other languages and technologies can be adopted\".\n\nIn 2006 and 2012, Computerworld surveys found that over 60% of organizations used COBOL (more than C++ and Visual Basic .NET) and that for half of those, COBOL was used for the majority of their internal software. 36% of managers said they planned to migrate from COBOL, and 25% said they would like to if it was cheaper. Instead, some businesses have migrated their systems from expensive mainframes to cheaper, more modern systems, while maintaining their COBOL programs.\n\nFeatures\n\nSyntax\n\nCOBOL has an English-like syntax, which is used to describe nearly everything in a program. For example, a condition can be expressed as Â  or more concisely as Â Â  or Â . More complex conditions can be \"abbreviated\" by removing repeated conditions and variables. For example, Â Â  can be shortened to . As a consequence of this English-like syntax, COBOL has over 300 keywords. Some of the keywords are simple alternative or pluralized spellings of the same word, which provides for more English-like statements and clauses; e.g., the  and  keywords can be used interchangeably, as can  and , and  and .\n\nEach COBOL program is made up of four basic lexical items: words, literals, picture character-strings (see ) and separators. Words include reserved words and user-defined identifiers. They are up to 31 characters long and may include letters, digits, hyphens and underscores. Literals include numerals (e.g. ) and strings (e.g. ). Separators include the space character and commas and semi-colons followed by a space.\n\nA COBOL program is split into four divisions: the identification division, the environment division, the data division and the procedure division. The identification division specifies the name and type of the source element and is where classes and interfaces are specified. The environment division specifies any program features that depend on the system running it, such as files and character sets. The data division is used to declare variables and parameters. The procedure division contains the program's statements. Each division is sub-divided into sections, which are made up of paragraphs.\n\nMetalanguage\n\nCOBOL's syntax is usually described with a unique metalanguage using braces, brackets, bars and underlining. The metalanguage was developed for the original COBOL specifications. Although BackusâNaur form did exist at the time, the committee had not heard of it.\n\nAs an example, consider the following description of an ADD statement:\n\n\\begin{array}{l}\n  \\underline{\\text{ADD}}\\,\n  \\begin{Bmatrix}\n    \\text{identifier-1} \\\\\n    \\text{literal-1}\n  \\end{Bmatrix}\\dots\n  \\;\\underline{\\text{TO}}\\,\\left\\{\\text{identifier-2}\\,\\left[\\,\\underline{\\text{ROUNDED}}\\,\\right]\\right\\}\\dots\n  \\\\\n\n  \\quad\n  \\left[\\left|\\begin{array}{l}\n     \\text{ON}\\,\\underline{\\text{SIZE}}\\,\\underline{\\text{ERROR}}\\,\\text{imperative-statement-1} \\\\\n     \\underline{\\text{NOT}}\\,\\text{ON}\\,\\underline{\\text{SIZE}}\\,\\underline{\\text{ERROR}}\\,\\text{imperative-statement-2} \\\\\n  \\end{array}\\right|\\right]\n  \\\\\n\n  \\quad\n  \\left[\\,\\underline{\\text{END-ADD}}\\,\\right]\n\\end{array}\n\nThis description permits the following variants:\n\nADD 1 TO x\nADD 1, a, b TO x ROUNDED, y, z ROUNDED\n\nADD a, b TO c\n    ON SIZE ERROR\n        DISPLAY \"Error\"\nEND-ADD\n\nADD a TO b\n    NOT SIZE ERROR\n        DISPLAY \"No error\"\n    ON SIZE ERROR\n        DISPLAY \"Error\"\n\nCode format\n\nCOBOL can be written in two formats: fixed (the default) or free. In fixed-format, code must be aligned to fit in certain areas (a hold-over from using punched cards). Until COBOL 2002, these were:\n\nIn COBOL 2002, Areas A and B were merged to form the program-text area, which now ends at an implementor-defined column.\n\nCOBOL 2002 also introduced free-format code. Free-format code can be placed in any column of the file, as in newer programming languages. Comments are specified using *>, which can be placed anywhere and can also be used in fixed-format source code. Continuation lines are not present, and the >>PAGE directive replaces the / indicator.\n\nIdentification division\n\nThe identification division identifies the following code entity and contains the definition of a class or interface.\n\nObject-oriented programming\n\nClasses and interfaces have been in COBOL since 2002. Classes have factory objects, containing class methods and variables, and instance objects, containing instance methods and variables. Inheritance and interfaces provide polymorphism. Support for generic programming is provided through parameterized classes, which can be instantiated to use any class or interface. Objects are stored as references which may be restricted to a certain type. There are two ways of calling a method: the  statement, which acts similarly to , or through inline method invocation, which is analogous to using functions.\n\n*> These are equivalent.\nINVOKE my-class \"foo\" RETURNING var\nMOVE my-class::\"foo\" TO var *> Inline method invocation\n\nCOBOL does not provide a way to hide methods. Class data can be hidden, however, by declaring it without a property (programming)| clause, which leaves the user with no way to access it. Method overloading was added in COBOL 2014.\n\nEnvironment division\n\nThe environment division contains the configuration section and the input-output section. The configuration section is used to specify variable features such\nas currency signs, locales and character sets. The input-output section contains file-related information.\n\nFiles\n\nCOBOL supports three file formats, or ': sequential, indexed and relative. In sequential files, records are contiguous and must be traversed sequentially, similarly to a linked list. Indexed files have one or more indexes which allow records to be randomly accessed and which can be sorted on them. Each record must have a unique key, but other, ', record keys need not be unique. Implementations of indexed files vary between vendors, although common implementations, such as CâISAM and VSAM, are based on IBM's ISAM. Relative files, like indexed files, have a unique record key, but they do not have alternate keys. A relative record's key is its ordinal position; for example, the 10th record has a key of 10. This means that creating a record with a key of 5 may require the creation of (empty) preceding records. Relative files also allow for both sequential and random access.\n\nA common non-standard extension is the ' organization, used to process text files. Records in a file are terminated by a newline and may be of varying length.\n\nData division\n\nThe data division is split into six sections which declare different items: the file section, for file records; the working-storage section, for static variables; the local-storage section, for automatic variables; the linkage section, for parameters and the return value; the report section and the screen section, for text-based user interfaces.\n\nAggregated data\n\nData items in COBOL are declared hierarchically through the use of level-numbers which indicate if a data item is part of another. An item with a higher level-number is subordinate to an item with a lower one. Top-level data items, with a level-number of 1, are called '. Items that have subordinate aggregate data are called '; those that do not are called '. Level-numbers used to describe standard data items are between 1 and 49.\n\n       01  some-record.                   *> Aggregate group record item\n           05  num            PIC 9(10).  *> Elementary item\n           05  the-date.                  *> Aggregate (sub)group record item\n               10  the-year   PIC 9(4).   *> Elementary item\n               10  the-month  PIC 99.     *> Elementary item\n               10  the-day    PIC 99.     *> Elementary item\n\nIn the above example, elementary item  and group item  are subordinate to the record , while elementary items , , and  are part of the group item .\n\nSubordinate items can be disambiguated with the  (or ) keyword. For example, consider the example code above along with the following example:\n\n       01  sale-date.\n           05  the-year       PIC 9(4).\n           05  the-month      PIC 99.\n           05  the-day        PIC 99.\n\nThe names , , and  are ambiguous by themselves, since more than one data item is defined with those names. To specify a particular data item, for instance one of the items contained within the  group, the programmer would use  (or the equivalent ). (This syntax is similar to the \"dot notation\" supported by most contemporary languages.)\n\nOther data levels\n\nA level-number of 66 is used to declare a re-grouping of previously defined items, irrespective of how those items are structured. This data level, also referred to by the associated , is rarely used and, circa 1988, was usually found in old programs. Its ability to ignore the hierarchical and logical structure data meant its use was not recommended and many installations forbade its use.\n\n       01  customer-record.\n           05  cust-key            PIC X(10).\n           05  cust-name.\n               10  cust-first-name PIC X(30).\n               10  cust-last-name  PIC X(30).\n           05  cust-dob            PIC 9(8).\n           05  cust-balance        PIC 9(7)V99.\n           \n       66  cust-personal-details   RENAMES cust-name THRU cust-dob.\n       66  cust-all-details        RENAMES cust-name THRU cust-balance.\n\nA 77 level-number indicates the item is stand-alone, and in such situations is equivalent to the level-number 01. For example, the following code declares two 77-level data items,  and , which are non-group data items that are independent of (not subordinate to) any other data items:\n\n       77  property-name      PIC X(80).\n       77  sales-region       PIC 9(5).\n\nAn 88 level-number declares a ' (a so-called 88-level) which is true when its parent data item contains one of the values specified in its  clause. For example, the following code defines two 88-level condition-name items that are true or false depending on the current character data value of the  data item. When the data item contains a value of , the condition-name  is true, whereas when it contains a value of  or , the condition-name  is true. If the data item contains some other value, both of the condition-names are false.\n\n       01  wage-type          PIC X.\n           88  wage-is-hourly VALUE \"H\".\n           88  wage-is-yearly VALUE \"S\", \"Y\".\n\nData types\n\nStandard COBOL provides the following data types:\n\nType safety is variable in COBOL. Numeric data is converted between different representations and sizes silently and alphanumeric data can be placed in any data item that can be stored as a string, including numeric and group data. In contrast, object references and pointers may only be assigned from items of the same type and their values may be restricted to a certain type.\n\nPICTURE clause\n\nA  (or ) clause is a string of characters, each of which represents a portion of the data item and what it may contain. Some picture characters specify the type of the item and how many characters or digits it occupies in memory. For example, a  indicates a decimal digit, and an  indicates that the item is signed. Other picture characters (called ' and ' characters) specify how an item should be formatted. For example, a series of  characters define character positions as well as how a leading sign character is to be positioned within the final character data; the rightmost non-numeric character will contain the item's sign, while other character positions corresponding to a  to the left of this position will contain a space. Repeated characters can be specified more concisely by specifying a number in parentheses after a picture character; for example,  is equivalent to . Picture specifications containing only digit () and sign () characters define purely ' data items, while picture specifications containing alphabetic () or alphanumeric () characters define ' data items. The presence of other formatting characters define ' or ' data items.\n\nUSAGE clause\n\nThe  clause declares the format data is stored in. Depending on the data type, it can either complement or be used instead of a  clause. While it can be used to declare pointers and object references, it is mostly geared towards specifying numeric types. These numeric formats are:\n\n* Binary, where a minimum size is either specified by the PICTURE clause or by a USAGE clause such as BINARY-LONG.\n* , where data may be stored in whatever format the implementation provides; often equivalent to Â \n* , the default format, where data is stored as a string\n* Floating-point, in either an implementation-dependent format or according to IEEE 754.\n* , where data is stored as a string using an extended character set\n* , where data is stored in the smallest possible decimal format (typically packed binary-coded decimal)\n\nReport writer\n\nThe report writer is a declarative facility for creating reports. The programmer need only specify the report layout and the data required to produce it, freeing them from having to write code to handle things like page breaks, data formatting, and headings and footings.\n\nReports are associated with report files, which are files which may only be written to through report writer statements.\n\n       FD  report-out REPORT sales-report.\n\nEach report is defined in the report section of the data division. A report is split into report groups which define the report's headings, footings and details. Reports work around hierarchical '. Control breaks occur when a key variable changes it value; for example, when creating a report detailing customers' orders, a control break could occur when the program reaches a different customer's orders. Here is an example report description for a report which gives a salesperson's sales and which warns of any invalid records:\n\n       RD  sales-report\n           PAGE LIMITS 60 LINES\n           FIRST DETAIL 3\n           CONTROLS seller-name.\n\n       01  TYPE PAGE HEADING.\n           03  COL 1                    VALUE \"Sales Report\".\n           03  COL 74                   VALUE \"Page\".\n           03  COL 79                   PIC Z9 SOURCE PAGE-COUNTER.\n\n       01  sales-on-day TYPE DETAIL, LINE + 1.\n           03  COL 3                    VALUE \"Sales on\".\n           03  COL 12                   PIC 99/99/9999 SOURCE sales-date.\n           03  COL 21                   VALUE \"were\".\n           03  COL 26                   PIC $$$$9.99 SOURCE sales-amount.\n\n       01  invalid-sales TYPE DETAIL, LINE + 1.\n           03  COL 3                    VALUE \"INVALID RECORD:\".\n           03  COL 19                   PIC X(34) SOURCE sales-record.\n\n       01  TYPE CONTROL HEADING seller-name, LINE + 2.\n           03  COL 1                    VALUE \"Seller:\".\n           03  COL 9                    PIC X(30) SOURCE seller-name.\n\nThe above report description describes the following layout:\n\nSales Report                                                             Page  1\n\nSeller: Howard Bromberg\n  Sales on 10/12/2008 were $1000.00\n  Sales on 12/12/2008 were    $0.00\n  Sales on 13/12/2008 were   $31.47\n  INVALID RECORD: Howard Bromberg             XXXXYY\n\nSeller: Howard Discount\n...\nSales Report                                                            Page 12\n\n  Sales on 08/05/2014 were  $543.98\n  INVALID RECORD: William Selden      12O52014FOOFOO\n  Sales on 30/05/2014 were    $0.00\n\nFour statements control the report writer: , which prepares the report writer for printing; , which prints a report group; , which suppresses the printing of a report group; and , which terminates report processing. For the above sales report example, the procedure division might look like this:\n\n           OPEN INPUT sales, OUTPUT report-out\n           INITIATE sales-report\n \n           PERFORM UNTIL 1 <> 1\n               READ sales\n                   AT END\n                       EXIT PERFORM\n               END-READ\n \n               VALIDATE sales-record\n               IF valid-record\n                   GENERATE sales-on-day\n               ELSE\n                   GENERATE invalid-sales\n               END-IF\n           END-PERFORM\n \n           TERMINATE sales-report\n           CLOSE sales, report-out\n           .\n\nProcedure division\n\nProcedures\n\nThe sections and paragraphs in the procedure division (collectively called procedures) can be used as labels and as simple subroutines. Unlike in other divisions, paragraphs do not need to be in sections.\nExecution goes down through the procedures of a program until it is terminated.\nTo use procedures as subroutines, the  verb is used. This transfers control to the specified range of procedures and returns only upon reaching the end.\n\nUnusual control flow can trigger ', which cause control in performed procedures to return at unexpected times to unexpected locations. Procedures can be reached in three ways: they can be called with , jumped to from a  or through execution \"falling through\" the bottom of an above paragraph. Combinations of these invoke undefined behavior, creating mines. Specifically, mines occur when execution of a range of procedures would cause control flow to go past the last statement of a range of procedures already being performed.\n\nFor example, in the code in the adjacent image, a mine is tripped at the end of  when the screen is invalid. When the screen is invalid, control jumps to the  section, which, when done, performs . This recursion triggers undefined behavior as there are now two overlapping ranges of procedures being performed. The mine is then triggered upon reaching the end of  and means control could return to one of two locations:\n\n* The first  statement\n* The  statement in , where it would then \"fall-through\" into  and return to the first  statement upon reaching the end.\n\nStatements\n\nCOBOL 2014 has 47 statements (also called '), which can be grouped into the following broad categories: control flow, I/O, data manipulation and the report writer. The report writer statements are covered in the report writer section.\n\nControl flow\n\nCOBOL's conditional statements are  and .  is a switch-like statement with the added capability of evaluating multiple values and conditions. This can be used to implement decision tables. For example, the following might be used to control a CNC lathe: \n\nEVALUATE TRUE ALSO desired-speed ALSO current-speed\n    WHEN lid-closed ALSO min-speed THRU max-speed ALSO LESS THAN desired-speed\n        PERFORM speed-up-machine\n    WHEN lid-closed ALSO min-speed THRU max-speed ALSO GREATER THAN desired-speed\n        PERFORM slow-down-machine\n    WHEN lid-open ALSO ANY ALSO NOT ZERO\n        PERFORM emergency-stop\n    WHEN OTHER\n        CONTINUE\nEND-EVALUATE\n\nThe  statement is used to define loops which are executed  a condition is true (not  true, which is more common in other languages). It is also used to call procedures or ranges of procedures (see the procedures section for more details).  and  call subprograms and methods, respectively. The name of the subprogram/method is contained in a string which may be a literal or a data item. Parameters can be passed by reference, by content (where a copy is passed by reference) or by value (but only if a prototype is available).\n unloads subprograms from memory.  causes the program to jump to a specified procedure.\n\nThe  statement is a return statement and the  statement stops the program. The  statement has six different formats: it can be used as a return statement, a break statement, a continue statement, an end marker or to leave a procedure.\n\nExceptions are raised by a  statement and caught with a handler, or ', defined in the  portion of the procedure division. Declaratives are sections beginning with a  statement which specify the errors to handle. Exceptions can be names or objects.  is used in a declarative to jump to the statement after the one that raised the exception or to a procedure outside the . Unlike other languages, uncaught exceptions may not terminate the program and the program can proceed unaffected.\n\nI/O\n\nFile I/O is handled by the self-describing , , , and  statements along with a further three: , which updates a record; , which selects subsequent records to access by finding a record with a certain key; and , which releases a lock on the last record accessed.\n\nUser interaction is done using  and .\n\nData manipulation\n\nThe following verbs manipulate data:\n* , which sets data items to their default values.\n* , which assigns values to data items.\n* , which has 15 formats: it can modify indices, assign object references and alter table capacities, among other functions.\n* , , , , and , which handle arithmetic (with  assigning the result of a formula to a variable).\n*  and , which handle dynamic memory.\n* , which validates and distributes data as specified in an item's description in the data division.\n*  and , which concatenate and split strings, respectively.\n* , which tallies or replaces instances of specified substrings within a string.\n* , which searches a table for the first entry satisfying a condition.\n\nFiles and tables are sorted using  and the  verb merges and sorts files. The  verb provides records to sort and  retrieves sorted records in order.\n\nScope termination\n\nSome statements, such as  and , may themselves contain statements. Such statements may be terminated in two ways: by a period ('), which terminates all unterminated statements contained, or by a scope terminator, which terminates the nearest matching open statement.\n\n*> Terminator period (\"implicit termination\")\nIF invalid-record\n    IF no-more-records\n        NEXT SENTENCE\n    ELSE\n        READ record-file\n            AT END SET no-more-records TO TRUE.\n\n*> Scope terminators (\"explicit termination\")\nIF invalid-record\n    IF no-more-records\n        CONTINUE\n    ELSE\n        READ record-file\n            AT END SET no-more-records TO TRUE\n        END-READ\n    END-IF\nEND-IF\n\nNested statements terminated with a period are a common source of bugs. For example, examine the following code:\n\nIF x\n    DISPLAY y.\n    DISPLAY z.\n\nHere, the intent is to display y and z if condition x is true. However, z will be displayed whatever the value of x because the IF statement is terminated by an erroneous period after .\n\nAnother bug is a result of the dangling else problem, when two IF statements can associate with an ELSE.\n\nIF x\n    IF y\n        DISPLAY a\nELSE\n    DISPLAY b.\n\nIn the above fragment, the ELSE associates with the Â Â  statement instead of the Â Â  statement, causing a bug. Prior to the introduction of explicit scope terminators, preventing it would require Â Â  to be placed after the inner IF.\n\nSelf-modifying code\n\nThe original (1959) COBOL specification supported the infamous Â Â  statement, for which many compilers generated self-modifying code. X and Y are procedure labels, and the single Â Â  statement in procedure X executed after such an  statement means Â Â  instead. Many compilers still support it,Examples of compiler support for  can be seen in the following:\n\n* \n* \n* \n* \nbut it was deemed obsolete in the COBOL 1985 standard and deleted in 2002.\n\nHello, world\n\nA \"Hello, world\" program in COBOL:\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. hello-world.\n       PROCEDURE DIVISION.\n           DISPLAY \"Hello, world!\"\n           .\n\nWhen the â now famous â \"Hello, World!\" program example in The C Programming Language was first published in 1978 a similar mainframe COBOL program sample would have been submitted through JCL, very likely using a punch card reader, and 80 column punch cards.  The listing below, with an empty DATA DIVISION, was tested using GNU/Linux and the System/370 Hercules emulator running MVS 3.8J.  The JCL, written in July 2015, is derived from the Hercules tutorials and samples hosted by Jay Moseley.  In keeping with COBOL programming of that era, HELLO, WORLD is displayed in all capital letters.\n\n//COBUCLG  JOB (001),'COBOL BASE TEST',                                 00010000\n//             CLASSA,MSGCLASS\nA,MSGLEVEL=(1,1)                        00020000\n//BASETEST EXEC COBUCLG                                                 00030000\n//COB.SYSIN DD *                                                        00040000\n 00000* VALIDATION OF BASE COBOL INSTALL                                00050000\n 01000 IDENTIFICATION DIVISION.                                         00060000\n 01100 PROGRAM-ID. 'HELLO'.                                             00070000\n 02000 ENVIRONMENT DIVISION.                                            00080000\n 02100 CONFIGURATION SECTION.                                           00090000\n 02110 SOURCE-COMPUTER.  GNULINUX.                                      00100000\n 02120 OBJECT-COMPUTER.  HERCULES.                                      00110000\n 02200 SPECIAL-NAMES.                                                   00120000\n 02210     CONSOLE IS CONSL.                                            00130000\n 03000 DATA DIVISION.                                                   00140000\n 04000 PROCEDURE DIVISION.                                              00150000\n 04100 00-MAIN.                                                         00160000\n 04110     DISPLAY 'HELLO, WORLD' UPON CONSL.                           00170000\n 04900     STOP RUN.                                                    00180000\n//LKED.SYSLIB DD DSNAMESYS1.COBLIB,DISP\nSHR                            00190000\n//            DD DSNAMESYS1.LINKLIB,DISP\nSHR                           00200000\n//GO.SYSPRINT DD SYSOUT=A                                               00210000\n//                                                                      00220000\n\nAfter submitting the JCL, the MVS console displayed:\n\n    19.52.48 JOB    3  $HASP100 COBUCLG  ON READER1     COBOL BASE TEST\n    19.52.48 JOB    3  IEF677I WARNING MESSAGE(S) FOR JOB COBUCLG  ISSUED\n    19.52.48 JOB    3  $HASP373 COBUCLG  STARTED - INIT  1 - CLASS A - SYS BSP1\n    19.52.48 JOB    3  IEC130I SYSPUNCH DD STATEMENT MISSING\n    19.52.48 JOB    3  IEC130I SYSLIB   DD STATEMENT MISSING\n    19.52.48 JOB    3  IEC130I SYSPUNCH DD STATEMENT MISSING\n    19.52.48 JOB    3  IEFACTRT - Stepname  Procstep  Program   Retcode\n    19.52.48 JOB    3  COBUCLG    BASETEST  COB       IKFCBL00  RC= 0000\n    19.52.48 JOB    3  COBUCLG    BASETEST  LKED      IEWL      RC= 0000\n    19.52.48 JOB    3  +HELLO, WORLD\n    19.52.48 JOB    3  COBUCLG    BASETEST  GO        PGM*.DD  RC\n 0000\n    19.52.48 JOB    3  $HASP395 COBUCLG  ENDED\n\nLine 10 of the console listing above is highlighted for effect, the highlighting is not part of the actual console output.\n\nThe associated compiler listing generated over four pages of technical detail and job run information, for the single line of output from the 14 lines of COBOL.\n\nCriticism and defense\n\nLack of structure\n\nIn the 1970s, adoption of the structured programming paradigm was becoming increasingly widespread. Edsger Dijkstra, a preeminent computer scientist, wrote a letter to the editor of Communications of the ACM, published 1975 entitled \"How do we tell truths that might hurt?\", in which he was critical of COBOL and several other contemporary languages; remarking that \"the use of COBOL cripples the mind\".\nIn a published dissent to Dijkstra's remarks, the computer scientist Howard E. Tompkins claimed that unstructured COBOL tended to be \"written by programmers that have never had the benefit of structured COBOL taught well\", arguing that the issue was primarily one of training.\n\nOne cause of spaghetti code was the  statement. Attempts to remove s from COBOL code, however, resulted in convoluted programs and reduced code quality. s were largely replaced by the  statement and procedures, which promoted modular programming and gave easy access to powerful looping facilities. However,  could only be used with procedures so loop bodies were not located where they were used, making programs harder to understand.\n\nCOBOL programs were infamous for being monolithic and lacking modularization.\nCOBOL code could only be modularized through procedures, which were found to be inadequate for large systems. It was impossible to restrict access to data, meaning a procedure could access and modify  data item. Furthermore, there was no way to pass parameters to a procedure, an omission Jean Sammet regarded as the committee's biggest mistake.\nAnother complication stemmed from the ability to  a specified sequence of procedures. This meant that control could jump to and return from any procedure, creating convoluted control flow and permitting a programmer to break the single-entry single-exit rule.\n\nThis situation improved as COBOL adopted more features. COBOL-74 added subprograms, giving programmers the ability to control the data each part of the program could access. COBOL-85 then added nested subprograms, allowing programmers to hide subprograms. Further control over data and code came in 2002 when object-oriented programming, user-defined functions and user-defined data types were included.\n\nNevertheless, much important legacy COBOL software uses unstructured code, which has become unmaintainable.  It can be too risky and costly to modify even a simple section of code, since it may be used from unknown places in unknown ways.\n\nCompatibility issues\n\nCOBOL was intended to be a highly portable, \"common\" language. However, by 2001, around 300 dialects had been created. One source of dialects was the standard itself: the 1974 standard was composed of one mandatory nucleus and eleven functional modules, each containing two or three levels of support. This permitted 104,976 official variants.\n\nCOBOL-85 was not fully compatible with earlier versions, and its development was controversial. Joseph T. Brophy, the CIO of Travelers Insurance, spearheaded an effort to inform COBOL users of the heavy reprogramming costs of implementing the new standard. As a result, the ANSI COBOL Committee received more than 2,200 letters from the public, mostly negative, requiring the committee to make changes.  On the other hand, conversion to COBOL-85 was thought to increase productivity in future years, thus justifying the conversion costs.\n\nVerbose syntax\n\nCOBOL syntax has often been criticized for its verbosity. Proponents say that this was intended to make the code self-documenting, easing program maintenance. COBOL was also intended to be easy for programmers to learn and use, while still being readable to non-technical staff such as managers.\nThe desire for readability led to the use of English-like syntax and structural elements, such as nouns, verbs, clauses, sentences, sections, and divisions.  Yet by 1984, maintainers of COBOL programs were struggling to deal with \"incomprehensible\" code and the main changes in COBOL-85 were there to help ease maintenance.\n\nJean Sammet, a short-range committee member, noted that \"little attempt was made to cater to the professional programmer, in fact people whose main interest is programming tend to be very unhappy with COBOL\" which she attributed to COBOL's verbose syntax.\n\nIsolation from the computer science community\n\nThe COBOL community has always been isolated from the computer science community. No academic computer scientists participated in the design of COBOL: all of those on the committee came from commerce or government.  Computer scientists at the time were more interested in fields like numerical analysis, physics and system programming than the commercial file-processing problems which COBOL development tackled. Jean Sammet attributed COBOL's unpopularity to an initial \"snob reaction\" due to its inelegance, the lack of influential computer scientists participating in the design process and a disdain for business data processing. The COBOL specification used a unique \"notation\", or metalanguage, to define its syntax rather than the new BackusâNaur form because few committee members had heard of it. This resulted in \"severe\" criticism.\n\nLater, COBOL suffered from a shortage of material covering it; it took until 1963 for introductory books to appear (with Richard D. Irwin publishing a college textbook on COBOL in 1966).https://books.bibliopolis.com/main/find/2200821/COBOL-Logic-and-Programming-third-edition-1974-McCameron-Fritz-oldcomputerbooks-com.html    By 1985, there were twice as many books on Fortran and four times as many on BASIC as on COBOL in the Library of Congress.  University professors taught more modern, state-of-the-art languages and techniques instead of COBOL which was said to have a \"trade school\" nature. Donald Nelson, chair of the CODASYL COBOL committee, said in 1984 that \"academics ... hate COBOL\" and that computer science graduates \"had 'hate COBOL' drilled into them\". A 2013 poll by Micro Focus found that 20% of university academics thought COBOL was outdated or dead and that 55% believed their students thought COBOL was outdated or dead. The same poll also found that only 25% of academics had COBOL programming on their curriculum even though 60% thought they should teach it.\nIn contrast, in 2003, COBOL featured in 80% of information systems curricula in the United States, the same proportion as C++ and Java.\n\nThere was also significant condescension towards COBOL in the business community from users of other languages, for example FORTRAN or assembler, implying that COBOL could be used only for non-challenging problems.\n\nConcerns about the design process\n\nDoubts have been raised about the competence of the standards committee. Short-term committee member Howard Bromberg said that there was \"little control\" over the development process and that it was \"plagued by discontinuity of personnel and ... a lack of talent.\" Jean Sammet and Jerome Garfunkel also noted that changes introduced in one revision of the standard would be reverted in the next, due as much to changes in who was in the standard committee as to objective evidence.\n\nCOBOL standards have repeatedly suffered from delays: COBOL-85 arrived five years later than hoped,\nCOBOL 2002 was five years late,\nand COBOL 2014 was six years late.\nTo combat delays, the standard committee allowed the creation of optional addenda which would add features more quickly than by waiting for the next standard revision. However, some committee members raised concerns about incompatibilities between implementations and frequent modifications of the standard.\n\nInfluences on other languages\n\nCOBOL's data structures influenced subsequent programming languages. Its record and file structure influenced PL/I and Pascal, and the REDEFINES clause was a predecessor to Pascal's variant records. Explicit file structure definitions preceded the development of database management systems and aggregated data was a significant advance over Fortran's arrays.\nPICTURE data declarations were incorporated into PL/I, with minor changes.\n\nCOBOL's  facility, although considered \"primitive\",\ninfluenced the development of include directives.\n\nThe focus on portability and standardization meant programs written in COBOL could be portable and facilitated the spread of the language to a wide variety of hardware platforms and operating systems.This can be seen in:\n\n* \n* \n*  Additionally, the well-defined division structure restricts the definition of external references to the Environment Division, which simplifies platform changes in particular. COBOL. http://en.wikipedia.org/?curid=6799."
  }
}
