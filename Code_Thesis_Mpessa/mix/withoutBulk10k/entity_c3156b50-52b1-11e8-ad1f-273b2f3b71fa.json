{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=2925",
  "eid" : "c3156b50-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778407045,
  "textBody" : "In computability theory, the Ackermann function, named after Wilhelm Ackermann, is one of the simplest and earliest-discovered examples of a total computable function that is not primitive recursive. All primitive recursive functions are total and computable, but the Ackermann function illustrates that not all total computable functions are primitive recursive.\n\nAfter Ackermann's publication of his function (which had three nonnegative integer arguments), many authors modified it to suit various purposes, so that today \"the Ackermann function\" may refer to any of numerous variants of the original function. One common version, the two-argument Ackermann–Péter function, is defined as follows for nonnegative integers m and n:\n\n A(m, n) =\n\\begin{cases}\nn+1 & \\mbox{if } m = 0 \\\\\nA(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\\nA(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.\n\\end{cases}\n\nIts value grows rapidly, even for small inputs. For example, A(4,2) is an integer of 19,729 decimal digits.[http://www.kosara.net/thoughts/ackermann42.html Decimal expansion of A(4,2)] \n\nHistory\n\nIn the late 1920s, the mathematicians Gabriel Sudan and Wilhelm Ackermann, students of David Hilbert, were studying the foundations of computation. Both Sudan and Ackermann are credited with discovering total computable functions (termed simply \"recursive\" in some references) that are not primitive recursive. Sudan published the lesser-known Sudan function, then shortly afterwards and independently, in 1928, Ackermann published his function \\varphi (the Greek letter phi). Ackermann's three-argument function, \\varphi(m, n, p), is defined such that for p = 0, 1, 2, it reproduces the basic operations of addition, multiplication, and exponentiation as\n\\varphi(m, n, 0) = m+n,\n\\varphi(m, n, 1) = m\\cdot n,\n\\varphi(m, n, 2) = m^n,\nand for p > 2 it extends these basic operations in a way that can be compared to the hyperoperations:\n(Aside from its historic role as a total-computable-but-not-primitive-recursive function, Ackermann's original function is seen to extend the basic arithmetic operations beyond exponentiation, although not as seamlessly as do variants of Ackermann's function that are specifically designed for that purpose—such as Goodstein's hyperoperation sequence.)\n\nIn On the Infinite, David Hilbert hypothesized that the Ackermann function was not primitive recursive, but it was Ackermann, Hilbert’s personal secretary and former student, who actually proved the hypothesis in his paper On Hilbert’s Construction of the Real Numbers.von Heijenoort. [http://mathgate.info/cebrown/notes/vonHeijenoort.php From Frege To Gödel] , 1967.\n\nRózsa Péter and Raphael Robinson later developed a two-variable version of the Ackermann function that became preferred by many authors.\n\nDefinition and properties\n\nAckermann's original three-argument function \\varphi(m, n, p) is defined recursively as follows for nonnegative integers m, n, and p:\n\n \n\\begin{array}{lr}\n\\varphi(m, n, 0) = m + n \\\\\n\\varphi(m, 0, 1) = 0 \\\\\n\\varphi(m, 0, 2) = 1 \\\\\n\\varphi(m, 0, p) = m \\text{ for } p > 2 \\\\\n\\varphi(m, n, p) = \\varphi(m, \\varphi(m, n-1, p), p - 1) \\text{ for } n > 0 \\text{ and } p > 0.\n\\end{array}\n\nOf the various two-argument versions, the one developed by Péter and Robinson (called \"the\" Ackermann function by some authors) is defined for nonnegative integers m and n as follows:\n\n A(m, n) =\n\\begin{cases}\nn+1 & \\mbox{if } m = 0 \\\\\nA(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\\nA(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.\n\\end{cases}\n\nIt may not be immediately obvious that the evaluation of  A(m, n) always terminates. However, the recursion is bounded because in each recursive application either m decreases, or m remains the same and n decreases. Each time that n reaches zero, m decreases, so m eventually reaches zero as well. (Expressed more technically, in each case the pair (m, n) decreases in the lexicographic order on pairs, which is a well-ordering, just like the ordering of single non-negative integers; this means one cannot go down in the ordering infinitely many times in succession.) However, when m decreases there is no upper bound on how much n can increase—and it will often increase greatly.\n\nThe Péter-Ackermann function can also be expressed in terms of various other versions of the Ackermann function:\n* the indexed version of Knuth's up-arrow notation (extended to integer indices ≥ -2):\n:A(m,n)=2\\uparrow^{m-2} (n+3) - 3.\nThe part of the definition A(m, 0) A(m-1, 1) corresponds to 2\\uparrow^{m+1} 3\n2\\uparrow^m 4.\n\n* Conway chained arrow notation:\n:A(m,n)=(2\\rightarrow(n+3)\\rightarrow(m-2))-3 for m\\geq3\nhence\n:2\\rightarrow n\\rightarrow m=A(m+2,n-3)+3 for n>2.\n(n1 and n\n2 would correspond with A(m,−2)  −1 and A(m,−1) \n 1, which could logically be added.)\n\nFor small values of m like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to n (at most exponentially). For m ≥ 4, however, it grows much more quickly; even A(4, 2) is about 2, and the decimal expansion of A(4, 3) is very large by any typical measure.\n\nOne interesting aspect of the Ackermann function is that the only arithmetic operations it ever uses are addition and subtraction of 1. Its properties come solely from the power of unlimited recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see below.\n\nA single-argument version f(n) = A(n, n) that increases both m and n at the same time dwarfs every primitive recursive function, including very fast-growing functions such as the exponential function, the factorial function, multi- and superfactorial functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). It can be seen that f(n) is roughly comparable to fω(n) in the fast-growing hierarchy. This extreme growth can be exploited to show that f, which is obviously computable on a machine with infinite memory such as a Turing machine and so is a computable function, grows faster than any primitive recursive function and is therefore not primitive recursive.\n\nIn a category with exponentials, using the isomorphism ((X \\times Y) \\rightarrow Z) \\cong (X \\rightarrow (Y \\rightarrow Z)) (in computer science, this is called currying), the Ackermann function may be defined via primitive recursion over higher-order functionals as follows:\n\n\\begin{array}{lcl}\n\\operatorname{Ack}(0) & = & \\operatorname{S} \\\\\n\\operatorname{Ack}(m+1) & = & \\operatorname{Iter}(\\operatorname{Ack}(m))\n\\end{array}\n\nwhere  is the usual successor function and Iter denotes the functional power operator, defined by primitive recursion as well:\n\n\\begin{array}{lcl}\n\\operatorname{Iter}(f)(0) & = & f(1) \\\\\n\\operatorname{Iter}(f)(n+1) & = & f(\\operatorname{Iter}(f)(n)).\n\\end{array}\n\nThe function \\mathrm{Ack} defined in this way agrees with the Ackermann function A defined above: \\mathrm{Ack}(m)(n)=A(m,n).\n\nExample expansions\n\nTo see how the Ackermann function grows so quickly, it helps to expand out some simple expressions using the rules in the original definition. For example, we can fully evaluate A(1, 2) in the following way:\n\n\\begin{align}\nA(1,2) & = A(0, A(1, 1)) \\\\\n& = A(0, A(0, A(1, 0))) \\\\\n& = A(0, A(0, A(0, 1))) \\\\\n& = A(0, A(0, 2)) \\\\\n& = A(0, 3) \\\\\n& = 4.\n\\end{align}\n\nTo demonstrate how A(4, 3)'s computation results in many steps and in a large number:\n\\begin{align}\nA(4, 3) & = A(3, A(4, 2)) \\\\\n& = A(3, A(3, A(4, 1))) \\\\\n& = A(3, A(3, A(3, A(4, 0)))) \\\\\n& = A(3, A(3, A(3, A(3, 1)))) \\\\\n& = A(3, A(3, A(3, A(2, A(3, 0))))) \\\\\n& = A(3, A(3, A(3, A(2, A(2, 1))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(2, 0)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(1, 1)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(0, A(1, 0))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(0, A(0, 1))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(0, 2)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, 3))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(1, 2)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(1, 1))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(1, 0)))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(0, 1)))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(0, 2)) )) )) ) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, 3)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, 4)))))  \\\\\n& = A(3, A(3, A(3, A(2, 5)))) \\\\\n& = \\ldots \\\\\n& = A(3, A(3, A(3, 13))) \\\\\n& = \\ldots \\\\\n& = A(3, A(3, 65533)) \\\\\n& = \\ldots \\\\\n& = A(3, 2^{65536} - 3) \\\\\n& = \\ldots \\\\\n& = 2^{2^{ \\overset{65536}{} }} - 3. \\\\\n\\end{align}\n\nTable of values \n\nComputing the Ackermann function can be restated in terms of an infinite table. We place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left, then look up the required number in the previous row, at the position given by the number just taken. If there is no number to its left, simply look at the column headed \"1\" in the previous row. Here is a small upper-left portion of the table:",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Ackermann function" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=2925" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In computability theory, the Ackermann function, named after Wilhelm Ackermann, is one of the simplest and earliest-discovered examples of a total computable function that is not primitive recursive. All primitive recursive functions are total and computable, but the Ackermann function illustrates that not all total computable functions are primitive recursive.\n\nAfter Ackermann's publication of his function (which had three nonnegative integer arguments), many authors modified it to suit various purposes, so that today \"the Ackermann function\" may refer to any of numerous variants of the original function. One common version, the two-argument Ackermann–Péter function, is defined as follows for nonnegative integers m and n:\n\n A(m, n) =\n\\begin{cases}\nn+1 & \\mbox{if } m = 0 \\\\\nA(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\\nA(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.\n\\end{cases}\n\nIts value grows rapidly, even for small inputs. For example, A(4,2) is an integer of 19,729 decimal digits.[http://www.kosara.net/thoughts/ackermann42.html Decimal expansion of A(4,2)] \n\nHistory\n\nIn the late 1920s, the mathematicians Gabriel Sudan and Wilhelm Ackermann, students of David Hilbert, were studying the foundations of computation. Both Sudan and Ackermann are credited with discovering total computable functions (termed simply \"recursive\" in some references) that are not primitive recursive. Sudan published the lesser-known Sudan function, then shortly afterwards and independently, in 1928, Ackermann published his function \\varphi (the Greek letter phi). Ackermann's three-argument function, \\varphi(m, n, p), is defined such that for p = 0, 1, 2, it reproduces the basic operations of addition, multiplication, and exponentiation as\n\\varphi(m, n, 0) = m+n,\n\\varphi(m, n, 1) = m\\cdot n,\n\\varphi(m, n, 2) = m^n,\nand for p > 2 it extends these basic operations in a way that can be compared to the hyperoperations:\n(Aside from its historic role as a total-computable-but-not-primitive-recursive function, Ackermann's original function is seen to extend the basic arithmetic operations beyond exponentiation, although not as seamlessly as do variants of Ackermann's function that are specifically designed for that purpose—such as Goodstein's hyperoperation sequence.)\n\nIn On the Infinite, David Hilbert hypothesized that the Ackermann function was not primitive recursive, but it was Ackermann, Hilbert’s personal secretary and former student, who actually proved the hypothesis in his paper On Hilbert’s Construction of the Real Numbers.von Heijenoort. [http://mathgate.info/cebrown/notes/vonHeijenoort.php From Frege To Gödel] , 1967.\n\nRózsa Péter and Raphael Robinson later developed a two-variable version of the Ackermann function that became preferred by many authors.\n\nDefinition and properties\n\nAckermann's original three-argument function \\varphi(m, n, p) is defined recursively as follows for nonnegative integers m, n, and p:\n\n \n\\begin{array}{lr}\n\\varphi(m, n, 0) = m + n \\\\\n\\varphi(m, 0, 1) = 0 \\\\\n\\varphi(m, 0, 2) = 1 \\\\\n\\varphi(m, 0, p) = m \\text{ for } p > 2 \\\\\n\\varphi(m, n, p) = \\varphi(m, \\varphi(m, n-1, p), p - 1) \\text{ for } n > 0 \\text{ and } p > 0.\n\\end{array}\n\nOf the various two-argument versions, the one developed by Péter and Robinson (called \"the\" Ackermann function by some authors) is defined for nonnegative integers m and n as follows:\n\n A(m, n) =\n\\begin{cases}\nn+1 & \\mbox{if } m = 0 \\\\\nA(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\\nA(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.\n\\end{cases}\n\nIt may not be immediately obvious that the evaluation of  A(m, n) always terminates. However, the recursion is bounded because in each recursive application either m decreases, or m remains the same and n decreases. Each time that n reaches zero, m decreases, so m eventually reaches zero as well. (Expressed more technically, in each case the pair (m, n) decreases in the lexicographic order on pairs, which is a well-ordering, just like the ordering of single non-negative integers; this means one cannot go down in the ordering infinitely many times in succession.) However, when m decreases there is no upper bound on how much n can increase—and it will often increase greatly.\n\nThe Péter-Ackermann function can also be expressed in terms of various other versions of the Ackermann function:\n* the indexed version of Knuth's up-arrow notation (extended to integer indices ≥ -2):\n:A(m,n)=2\\uparrow^{m-2} (n+3) - 3.\nThe part of the definition A(m, 0) A(m-1, 1) corresponds to 2\\uparrow^{m+1} 3\n2\\uparrow^m 4.\n\n* Conway chained arrow notation:\n:A(m,n)=(2\\rightarrow(n+3)\\rightarrow(m-2))-3 for m\\geq3\nhence\n:2\\rightarrow n\\rightarrow m=A(m+2,n-3)+3 for n>2.\n(n1 and n\n2 would correspond with A(m,−2)  −1 and A(m,−1) \n 1, which could logically be added.)\n\nFor small values of m like 1, 2, or 3, the Ackermann function grows relatively slowly with respect to n (at most exponentially). For m ≥ 4, however, it grows much more quickly; even A(4, 2) is about 2, and the decimal expansion of A(4, 3) is very large by any typical measure.\n\nOne interesting aspect of the Ackermann function is that the only arithmetic operations it ever uses are addition and subtraction of 1. Its properties come solely from the power of unlimited recursion. This also implies that its running time is at least proportional to its output, and so is also extremely huge. In actuality, for most cases the running time is far larger than the output; see below.\n\nA single-argument version f(n) = A(n, n) that increases both m and n at the same time dwarfs every primitive recursive function, including very fast-growing functions such as the exponential function, the factorial function, multi- and superfactorial functions, and even functions defined using Knuth's up-arrow notation (except when the indexed up-arrow is used). It can be seen that f(n) is roughly comparable to fω(n) in the fast-growing hierarchy. This extreme growth can be exploited to show that f, which is obviously computable on a machine with infinite memory such as a Turing machine and so is a computable function, grows faster than any primitive recursive function and is therefore not primitive recursive.\n\nIn a category with exponentials, using the isomorphism ((X \\times Y) \\rightarrow Z) \\cong (X \\rightarrow (Y \\rightarrow Z)) (in computer science, this is called currying), the Ackermann function may be defined via primitive recursion over higher-order functionals as follows:\n\n\\begin{array}{lcl}\n\\operatorname{Ack}(0) & = & \\operatorname{S} \\\\\n\\operatorname{Ack}(m+1) & = & \\operatorname{Iter}(\\operatorname{Ack}(m))\n\\end{array}\n\nwhere  is the usual successor function and Iter denotes the functional power operator, defined by primitive recursion as well:\n\n\\begin{array}{lcl}\n\\operatorname{Iter}(f)(0) & = & f(1) \\\\\n\\operatorname{Iter}(f)(n+1) & = & f(\\operatorname{Iter}(f)(n)).\n\\end{array}\n\nThe function \\mathrm{Ack} defined in this way agrees with the Ackermann function A defined above: \\mathrm{Ack}(m)(n)=A(m,n).\n\nExample expansions\n\nTo see how the Ackermann function grows so quickly, it helps to expand out some simple expressions using the rules in the original definition. For example, we can fully evaluate A(1, 2) in the following way:\n\n\\begin{align}\nA(1,2) & = A(0, A(1, 1)) \\\\\n& = A(0, A(0, A(1, 0))) \\\\\n& = A(0, A(0, A(0, 1))) \\\\\n& = A(0, A(0, 2)) \\\\\n& = A(0, 3) \\\\\n& = 4.\n\\end{align}\n\nTo demonstrate how A(4, 3)'s computation results in many steps and in a large number:\n\\begin{align}\nA(4, 3) & = A(3, A(4, 2)) \\\\\n& = A(3, A(3, A(4, 1))) \\\\\n& = A(3, A(3, A(3, A(4, 0)))) \\\\\n& = A(3, A(3, A(3, A(3, 1)))) \\\\\n& = A(3, A(3, A(3, A(2, A(3, 0))))) \\\\\n& = A(3, A(3, A(3, A(2, A(2, 1))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(2, 0)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(1, 1)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(0, A(1, 0))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(0, A(0, 1))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, A(0, 2)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(1, 3))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(1, 2)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(1, 1))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(1, 0)))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(0, A(0, 1)))))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, A(0, 2)) )) )) ) \\\\\n& = A(3, A(3, A(3, A(2, A(0, A(0, 3)))))) \\\\\n& = A(3, A(3, A(3, A(2, A(0, 4)))))  \\\\\n& = A(3, A(3, A(3, A(2, 5)))) \\\\\n& = \\ldots \\\\\n& = A(3, A(3, A(3, 13))) \\\\\n& = \\ldots \\\\\n& = A(3, A(3, 65533)) \\\\\n& = \\ldots \\\\\n& = A(3, 2^{65536} - 3) \\\\\n& = \\ldots \\\\\n& = 2^{2^{ \\overset{65536}{} }} - 3. \\\\\n\\end{align}\n\nTable of values \n\nComputing the Ackermann function can be restated in terms of an infinite table. We place the natural numbers along the top row. To determine a number in the table, take the number immediately to the left, then look up the required number in the previous row, at the position given by the number just taken. If there is no number to its left, simply look at the column headed \"1\" in the previous row. Here is a small upper-left portion of the table:. Ackermann function. http://en.wikipedia.org/?curid=2925."
  }
}
