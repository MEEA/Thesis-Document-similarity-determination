{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=15062",
  "eid" : "19cea6f0-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778552543,
  "textBody" : "The Intel 8080 (\"eighty-eighty\") was the second 8-bit microprocessor designed and manufactured by Intel and was released in April 1974. Electronic News was a weekly trade newspaper. The same advertisement appeared in the May 2, 1974 issue of Electronics magazine. It is an extended and enhanced variant of the earlier 8008 design, although without binary compatibility.  The initial specified clock frequency limit was 2 MHz, and with common instructions using 4, 5, 7, 10, or 11 cycles this meant that it operated at a typical speed of a few hundred thousand instructions per second. A faster variant 8080A-1 became available later with clock frequency limit up to 3.125 MHz.\n\nThe 8080 requires two support chips to function in most applications, the i8224 clock generator/driver and the i8228 bus controller, and it is implemented in NMOS using non-saturated enhancement-mode transistors as loads,Alternatively called pull-ups. therefore demanding a +12 V and a −5 V voltage in addition to the main TTL-compatible +5 V.\n\nAlthough earlier microprocessors were used for calculators, cash registers, computer terminals, industrial robots,The 8008 (1972) was used for interpolation and control in ASEA's (now ABB) first line of general industrial robots, introduced October 1973. and other applications, the 8080 became one of the first really widespread microprocessors. Several factors contributed to its popularity: its 40-pin package made it easier to interface than the 16-pin 8008, and also made its data bus more efficient; its NMOS implementation gave it faster transistors than those of the PMOS 8008, while also simplifying interfacing by making it TTL-compatible; a wider variety of support chips was available; its instruction set was enhanced over the 8008The enhancements were largely based on customer feedback and Federico Faggin and others listening to minicomputer-oriented professionals about certain problems and lack of features in the 8008 architecture. (Source: 8008 and 8080 oral histories.); and its full 16-bit address bus (versus the 14-bit one of the 8008) enabled it to access 64KB of memory, four times more than the 8008's range of 16KB. It became the engine of the Altair 8800, and subsequent S-100 bus personal computers, until it was replaced by the Z80 in this role, and was the original target CPU for CP/M operating systems developed by Gary Kildall.\n\nThe 8080 was successful enough that compatibility at the assembly language level became a design requirement for the 8086 when design for it was started in 1976. This also means that the 8080 directly influenced the ubiquitous 32-bit and 64-bit x86 architectures of today.\n\nDescription\n\nProgramming model\n\nThe Intel 8080 is the successor to the 8008. It uses the same basic instruction set and register model as the 8008 (developed by Computer Terminal Corporation), even though it is not source-code compatible nor binary-compatible with its predecessor. Every instruction in the 8008 has an equivalent instruction in the 8080 (even though the actual opcodes differ between the two CPUs). The 8080 also adds a few 16-bit operations in its instruction set as well. Whereas the 8008 required the use of the HL register pair to indirectly access its 14-bit memory space, the 8080 added addressing modes to allow direct access to its full 16-bit memory space. In addition, the internal 7-level push-down call stack of the 8008 was replaced by a dedicated 16-bit stack-pointer (SP) register. The 8080's large 40-pin DIP packaging permits it to provide a 16-bit address bus and an 8-bit data bus, allowing easy access to 64 KB of memory.\n\nRegisters\n\nThe processor has seven 8-bit registers (A, B, C, D, E, H, and L), where A is the primary 8-bit accumulator, and the other six registers can be used as either individual 8-bit registers or as three 16-bit register pairs (BC, DE, and HL, referred to as B, D and H in Intel documents) depending on the particular instruction. Some instructions also enable the HL register pair to be used as a (limited) 16-bit accumulator, and a pseudo-register M can be used almost anywhere that any other register can be used, referring to the memory address pointed to by the HL pair. It also has a 16-bit stack pointer to memory (replacing the 8008's internal stack), and a 16-bit program counter.\n\nFlags\n\nThe processor maintains internal flag bits (a status register), which indicate the results of arithmetic and logical instructions. The flags are:\n* Sign (S), set if the result is negative.\n* Zero (Z), set if the result is zero.\n* Parity (P), set if the number of 1 bits in the result is even.\n* Carry (C), set if the last addition operation resulted in a carry or if the last subtraction operation required a borrow\n* Auxiliary carry (AC or H), used for binary-coded decimal arithmetic.\n\nThe carry bit can be set or complemented by specific instructions. Conditional-branch instructions test the various flag status bits. The flags can be copied as a group to the accumulator. The A accumulator and the flags together are called the PSW register, or program status word.\n\nCommands/instructions\n\nAs with many other 8-bit processors, all instructions are encoded in a single byte (including register numbers, but excluding immediate data), for simplicity. Some of them are followed by one or two bytes of data, which can be an immediate operand, a memory address, or a port number. Like larger processors, it has automatic CALL and RET instructions for multi-level procedure calls and returns (which can even be conditionally executed, like jumps) and instructions to save and restore any 16-bit register pair on the machine stack. There are also eight one-byte call instructions () for subroutines located at the fixed addresses 00h, 08h, 10h, ..., 38h. These were intended to be supplied by external hardware in order to invoke a corresponding interrupt service routine, but were also often employed as fast system calls. The most sophisticated command is , which is used for exchanging the register pair HL with the value stored at the address indicated by the stack pointer.\n\n8-bit instructions\n\nMost 8-bit operations can only be performed on the 8-bit accumulator (the A register). For 8-bit operations with two operands, the other operand can be either an immediate value, another 8-bit register, or a memory byte addressed by the 16-bit register pair HL. Direct copying is supported between any two 8-bit registers and between any 8-bit register and an HL-addressed memory byte. Due to the regular encoding of the  instruction (using a quarter of available opcode space), there are redundant codes to copy a register into itself (, for instance), which were of little use, except for delays. However, what would have been a copy from the HL-addressed cell into itself (i.e., ) is instead used to encode the halt (HLT (x86 instruction)|) instruction, halting execution until an external reset or interrupt occurs.\n\n16-bit operations\n\nAlthough the 8080 is generally an 8-bit processor, it also has limited abilities to perform 16-bit operations: Any of the three 16-bit register pairs (BC, DE, or HL, referred to as B, D, H in Intel documents) or SP can be loaded with an immediate 16-bit value (using ), incremented or decremented (using  and ), or added to HL (using ). The [http://www.classiccmp.org/dunfield/r/8080.txt 8080 instruction encoding]. ClassicCMP.org. Retrieved on October 23, 2011. instruction exchanges the values of the HL and DE register pairs. By adding HL to itself, it is possible to achieve the same result as a 16-bit arithmetical left shift with one instruction. The only 16-bit instructions that affect any flag are , which set the CY (carry) flag in order to allow for programmed 24-bit or 32-bit arithmetic (or larger), needed to implement floating-point arithmetics, for instance.\n\nInput/output scheme\n\nInput output port space\n\nThe 8080 supports up to 256Note: Some Intel datasheets from the 1970s advertise 512 I/O ports, because they count input and output ports separately. input/output (I/O) ports, accessed via dedicated I/O instructions taking port addresses as operands. This I/O mapping scheme was regarded as an advantage, as it freed up the processor's limited address space. Many CPU architectures instead use so-called memory-mapped I/O, in which a common address space is used for both RAM and peripheral chips. This removes the need for dedicated I/O instructions, although a drawback in such designs may be that special hardware must be used to insert wait states, as peripherals are often slower than memory. However, in some simple 8080 computers, I/O was indeed addressed as if they were memory cells, \"memory-mapped\", leaving the I/O commands unused. I/O addressing could also sometimes employ the fact that the processor would output the same 8-bit port address to both the lower and the higher address byte (i.e.  would put the address 0505h on the 16-bit address bus). Similar I/O-port schemes were used in the backward-compatible Zilog Z80 and Intel 8085, as well as the closely related x86 families of microprocessors.\n\nSeparate stack space\n\nOne of the bits in the processor state word (see below) indicates that the processor is accessing data from the stack. Using this signal, it is possible to implement a separate stack memory space. However, this feature was seldom used.\n\nThe internal state word\n\nFor more advanced systems, during one phase of its working loop, the processor set its \"internal state byte\" on the data bus. This byte contains flags that determine whether the memory or I/O port is accessed and whether it is necessary to handle an interrupt.\n\nThe interrupt system state (enabled or disabled) is also output on a separate pin. For simple systems, where the interrupts are not used, it is possible to find cases where this pin is used as an additional single-bit output port (the popular Radio-86RK computer made in the Soviet Union, for instance).\n\nExample code\n\nThe following 8080/8085 assembler source code is for a subroutine named memcpy that copies a block of data bytes of a given size from one location to another. The data block is copied one byte at a time, and the data movement and looping logic utilizes 16-bit operations.\n\nPin usage\n\nThe address bus has its own 16 pins, and the data bus has 8 pins that are usable without any multiplexing. Using the two additional pins (read and write signals), it is possible to assemble simple microprocessor devices very easily. Only the separate IO space, interrupts and DMA require additional chips to decode the processor pin signals. However, the processor load capacity is limited, and even simple computers frequently contained bus amplifiers.\n\nThe processor requires three power sources (−5, +5 and +12 V) and two non-overlapping high-amplitude synchronization signals. However, at least the late Soviet version КР580ВМ80А was able to work with a single +5 V power source, the +12 V pin being connected to +5 V and the −5 V pin to ground. The processor consumes about 1.3 W of power.\n\nThe pin-out table, from the chip's accompanying documentation, describes the pins as follows:\n\nSupport chips \n\nA key factor in the success of the 8080 was the broad range of support chips available, providing serial communications, counter/timing, input/output, direct memory access, and programmable interrupt control amongst other functions:\n* [http://www.datasheets360.com/pdf/-4828066515233335508 8238] – System controller and bus driver\n* 8251 – Communication controller\n* 8253 – Programmable interval timer\n* 8255 – Programmable peripheral interface\n* 8257 – DMA controller\n* 8259 – Programmable interrupt controller\n\nPhysical implementation\n\nThe 8080 integrated circuit uses non-saturated enhancement-load nMOS gates, demanding extra voltages (for the load-gate bias). It was manufactured in a silicon gate process using a minimal feature size of 6 µm. A single layer of metal is used to interconnect the approximately 6,000 transistors[http://museum.reichel-orbital.de/index.php?page=cpus Reichel-Orbital museum – CPU Collection]. Museum.reichel-orbital.de. Retrieved on October 23, 2011. in the design, but the higher resistance polysilicon layer, which required higher voltage for some interconnects, is implemented with transistor gates. The die size was approximately 20 mm2.\n\nThe industrial impact\n\nApplications and successors\n\nThe 8080 is used in many early microcomputers, such as the MITS Altair 8800 Computer, Processor Technology SOL-20 Terminal Computer and IMSAI 8080 Microcomputer, forming the basis for machines running the CP/M operating system (the later, almost fully compatible and more capable, Zilog Z80 processor would capitalize on this, with Z80 & CP/M becoming the dominant CPU & OS combination of the period circa 1976 to 1983 much as did the x86 & MS-DOS for the PC a decade later). Even in 1979 after introduction of the Z80 and 8085 processors, five manufacturers of the 8080 were selling an estimated 500,000 units per month at a price around $3 to $4 per unit.Sol Libes BYTE News... in BYTE, , Volume 4 No. 11, November 1979 pg. 82 The first single-board microcomputers, such as MYCRO-1 and the dyna-micro were based on the Intel 8080.  One of the early uses of the 8080 was made in the late 1970s by Cubic-Western Data of San Diego, CA in its Automated Fare Collection Systems custom designed for mass transit systems around the world.  An early industrial use of the 8080 is as the \"brain\" of the DatagraphiX Auto-COM (Computer Output Microfiche) line of products which takes large amounts of user data from reel-to-reel tape and images it onto microfiche. The Auto-COM instruments also include an entire automated film cutting, processing, washing, and drying sub-system – quite a feat, both then and in the 21st century, to all be accomplished successfully with only an 8-bit microprocessor running at a clock speed of less than 1 MHz with a 64 KB memory limit. In addition, several early arcade video games were built around the 8080 microprocessor, including Space Invaders, one of the most popular arcade games ever made.\n\nShortly after the launch of the 8080, the Motorola 6800 competing design was introduced, and after that, the MOS Technology 6502 derivative of the 6800. Zilog introduced the Z80, which has a compatible machine-language instruction set and initially used the same assembly language as the 8080, but for legal reasons, Zilog developed a syntactically-different (but code compatible) alternative assembly language for the Z80. At Intel, the 8080 was followed by the compatible and electrically more elegant 8085, and later by the assembly language compatible 16-bit 8086 and then the 8/16-bit 8088, which was selected by IBM for its new PC to be launched in 1981. Later NEC made the NEC V20 (an 8088 clone with Intel 80186 instruction set compatibility) which also supports an 8080 emulation mode. This is also supported by NEC's V30 (a similarly enhanced 8086 clone). Thus, the 8080, via its ISA, made a lasting impact on computer history.\n\nA number of processors compatible with the Intel 8080A were manufactured in the Eastern Bloc: the KR580VM80A (initially marked as KP580ИK80) in the Soviet Union, the MCY7880[http://www.cpu-world.com/CPUs/8080/Poland-MCY7880.html MCY7880—a Polish-made clone of 8080]. CPU World. Retrieved on October 23, 2011. made by Unitra CEMI in Poland, the MHB8080A[http://www.cpu-world.com/info/exUSSR-chips.html Soviet chips and their western analogs]. CPU-world. Retrieved on October 23, 2011. made by TESLA in Czechoslovakia, the 8080APC made by Tungsram / MEV in Hungary, and the MMN8080 made by Microelectronica Bucharest in Romania.\n\nAs of 2017, the 8080 is still in production at Lansdale Semiconductors.\n\nimage:AMD C8080A.jpg|AMD Am9080\nimage:Poland MCY7880 1.jpg|CEMI MCY7880 (Poland)\nimage:580IK80.jpg|Kvazar Kiev K580IK80 (Soviet Union)\nimage:Mitsubishi M5L8080AP 1.jpg|Mitsubishi Electric M5L8080\nimage:NatSem INS8080AJ 1.jpg|National Semiconductor INS8080\nimage:NEC 8080AF 1.jpg|NEC 8080\nimage:OKI MSM8080A 1.jpg|OKI MSM8080\nimage:Siemens SAB8080A 1.jpg|Siemens SAB8080\nimage:Signetics MP8080AI 1.jpg|Signetics MP8080\nimage:KL Tesla MHB8080.jpg|Tesla (Czechoslovak company) MHB8080\nimage:TI TMS8080JL 1.jpg|Texas Instruments TMS8080\n\nIndustry change\n\nThe 8080 also changed how computers were created. When the 8080 was introduced, computer systems were usually created by computer manufacturers such as Digital Equipment Corporation, Hewlett Packard, or IBM. A manufacturer would produce  the entire computer, including processor, terminals, and system software such as compilers and operating system. The 8080 was actually designed for just about any application except a complete computer system. Hewlett Packard developed the HP 2640 series of smart terminals around the 8080. The HP 2647 is a terminal which runs BASIC on the 8080. Microsoft would market as its founding product the first popular programming language for the 8080, and would later acquire DOS for the IBM PC.\n\nThe 8080 and 8085 gave rise to the 8086, which was designed as a source compatible (although not binary compatible) extension of the 8085. This design, in turn, later spawned the x86 family of chips, the basis for most CPUs in use today. Many of the 8080's core machine instructions and concepts, for example, registers named A, B, C and D, as well as many of the flags used to control conditional jumps, are still in use in the widespread x86 platform. 8080 Assembler code can still be directly translated into x86 instructions; all of its core elements are still present.\n\nPCs based upon the 8086 design and its successors evolved into workstations and servers of 16, 32 and 64 bits, with advanced memory protection, segmentation, and multiprocessing features, blurring the difference between small and large computers  (the 80286 and 80386's protected mode were important in doing so). The size of chips has grown so that the size and power of large x86 chips is not much different from high end architecture chips, and a common strategy to produce a very large computer is to network many x86 processors.\n\nHistory\n\nFederico Faggin, the originator of the 8080 architecture in early 1972, proposed it to Intel's management and pushed for its implementation. He finally got the permission to develop it six months later. Faggin hired Masatoshi Shima from Japan, who did the detailed design under his direction, using the design methodology for random logic with silicon gate that Faggin had created for the 4000 family. Stanley Mazor contributed a couple of instructions to the instruction set.\n\nPatent\n\n* \n\nCultural impact\n\n*Asteroid 8080 Intel is named as a pun and praise on the name of Intel 8080.[http://cfa-www.harvard.edu/iau/lists/MPNames.html CFA-harvard.edu]. CFA-harvard.edu. Retrieved on October 23, 2011.\n*Microsoft's published phone number, 425-882-8080, was chosen because so much early work was on this chip.\n*Many of Intel's main phone numbers also take a similar form: xxx-xxx-8080",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Intel 8080" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=15062" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "The Intel 8080 (\"eighty-eighty\") was the second 8-bit microprocessor designed and manufactured by Intel and was released in April 1974. Electronic News was a weekly trade newspaper. The same advertisement appeared in the May 2, 1974 issue of Electronics magazine. It is an extended and enhanced variant of the earlier 8008 design, although without binary compatibility.  The initial specified clock frequency limit was 2 MHz, and with common instructions using 4, 5, 7, 10, or 11 cycles this meant that it operated at a typical speed of a few hundred thousand instructions per second. A faster variant 8080A-1 became available later with clock frequency limit up to 3.125 MHz.\n\nThe 8080 requires two support chips to function in most applications, the i8224 clock generator/driver and the i8228 bus controller, and it is implemented in NMOS using non-saturated enhancement-mode transistors as loads,Alternatively called pull-ups. therefore demanding a +12 V and a −5 V voltage in addition to the main TTL-compatible +5 V.\n\nAlthough earlier microprocessors were used for calculators, cash registers, computer terminals, industrial robots,The 8008 (1972) was used for interpolation and control in ASEA's (now ABB) first line of general industrial robots, introduced October 1973. and other applications, the 8080 became one of the first really widespread microprocessors. Several factors contributed to its popularity: its 40-pin package made it easier to interface than the 16-pin 8008, and also made its data bus more efficient; its NMOS implementation gave it faster transistors than those of the PMOS 8008, while also simplifying interfacing by making it TTL-compatible; a wider variety of support chips was available; its instruction set was enhanced over the 8008The enhancements were largely based on customer feedback and Federico Faggin and others listening to minicomputer-oriented professionals about certain problems and lack of features in the 8008 architecture. (Source: 8008 and 8080 oral histories.); and its full 16-bit address bus (versus the 14-bit one of the 8008) enabled it to access 64KB of memory, four times more than the 8008's range of 16KB. It became the engine of the Altair 8800, and subsequent S-100 bus personal computers, until it was replaced by the Z80 in this role, and was the original target CPU for CP/M operating systems developed by Gary Kildall.\n\nThe 8080 was successful enough that compatibility at the assembly language level became a design requirement for the 8086 when design for it was started in 1976. This also means that the 8080 directly influenced the ubiquitous 32-bit and 64-bit x86 architectures of today.\n\nDescription\n\nProgramming model\n\nThe Intel 8080 is the successor to the 8008. It uses the same basic instruction set and register model as the 8008 (developed by Computer Terminal Corporation), even though it is not source-code compatible nor binary-compatible with its predecessor. Every instruction in the 8008 has an equivalent instruction in the 8080 (even though the actual opcodes differ between the two CPUs). The 8080 also adds a few 16-bit operations in its instruction set as well. Whereas the 8008 required the use of the HL register pair to indirectly access its 14-bit memory space, the 8080 added addressing modes to allow direct access to its full 16-bit memory space. In addition, the internal 7-level push-down call stack of the 8008 was replaced by a dedicated 16-bit stack-pointer (SP) register. The 8080's large 40-pin DIP packaging permits it to provide a 16-bit address bus and an 8-bit data bus, allowing easy access to 64 KB of memory.\n\nRegisters\n\nThe processor has seven 8-bit registers (A, B, C, D, E, H, and L), where A is the primary 8-bit accumulator, and the other six registers can be used as either individual 8-bit registers or as three 16-bit register pairs (BC, DE, and HL, referred to as B, D and H in Intel documents) depending on the particular instruction. Some instructions also enable the HL register pair to be used as a (limited) 16-bit accumulator, and a pseudo-register M can be used almost anywhere that any other register can be used, referring to the memory address pointed to by the HL pair. It also has a 16-bit stack pointer to memory (replacing the 8008's internal stack), and a 16-bit program counter.\n\nFlags\n\nThe processor maintains internal flag bits (a status register), which indicate the results of arithmetic and logical instructions. The flags are:\n* Sign (S), set if the result is negative.\n* Zero (Z), set if the result is zero.\n* Parity (P), set if the number of 1 bits in the result is even.\n* Carry (C), set if the last addition operation resulted in a carry or if the last subtraction operation required a borrow\n* Auxiliary carry (AC or H), used for binary-coded decimal arithmetic.\n\nThe carry bit can be set or complemented by specific instructions. Conditional-branch instructions test the various flag status bits. The flags can be copied as a group to the accumulator. The A accumulator and the flags together are called the PSW register, or program status word.\n\nCommands/instructions\n\nAs with many other 8-bit processors, all instructions are encoded in a single byte (including register numbers, but excluding immediate data), for simplicity. Some of them are followed by one or two bytes of data, which can be an immediate operand, a memory address, or a port number. Like larger processors, it has automatic CALL and RET instructions for multi-level procedure calls and returns (which can even be conditionally executed, like jumps) and instructions to save and restore any 16-bit register pair on the machine stack. There are also eight one-byte call instructions () for subroutines located at the fixed addresses 00h, 08h, 10h, ..., 38h. These were intended to be supplied by external hardware in order to invoke a corresponding interrupt service routine, but were also often employed as fast system calls. The most sophisticated command is , which is used for exchanging the register pair HL with the value stored at the address indicated by the stack pointer.\n\n8-bit instructions\n\nMost 8-bit operations can only be performed on the 8-bit accumulator (the A register). For 8-bit operations with two operands, the other operand can be either an immediate value, another 8-bit register, or a memory byte addressed by the 16-bit register pair HL. Direct copying is supported between any two 8-bit registers and between any 8-bit register and an HL-addressed memory byte. Due to the regular encoding of the  instruction (using a quarter of available opcode space), there are redundant codes to copy a register into itself (, for instance), which were of little use, except for delays. However, what would have been a copy from the HL-addressed cell into itself (i.e., ) is instead used to encode the halt (HLT (x86 instruction)|) instruction, halting execution until an external reset or interrupt occurs.\n\n16-bit operations\n\nAlthough the 8080 is generally an 8-bit processor, it also has limited abilities to perform 16-bit operations: Any of the three 16-bit register pairs (BC, DE, or HL, referred to as B, D, H in Intel documents) or SP can be loaded with an immediate 16-bit value (using ), incremented or decremented (using  and ), or added to HL (using ). The [http://www.classiccmp.org/dunfield/r/8080.txt 8080 instruction encoding]. ClassicCMP.org. Retrieved on October 23, 2011. instruction exchanges the values of the HL and DE register pairs. By adding HL to itself, it is possible to achieve the same result as a 16-bit arithmetical left shift with one instruction. The only 16-bit instructions that affect any flag are , which set the CY (carry) flag in order to allow for programmed 24-bit or 32-bit arithmetic (or larger), needed to implement floating-point arithmetics, for instance.\n\nInput/output scheme\n\nInput output port space\n\nThe 8080 supports up to 256Note: Some Intel datasheets from the 1970s advertise 512 I/O ports, because they count input and output ports separately. input/output (I/O) ports, accessed via dedicated I/O instructions taking port addresses as operands. This I/O mapping scheme was regarded as an advantage, as it freed up the processor's limited address space. Many CPU architectures instead use so-called memory-mapped I/O, in which a common address space is used for both RAM and peripheral chips. This removes the need for dedicated I/O instructions, although a drawback in such designs may be that special hardware must be used to insert wait states, as peripherals are often slower than memory. However, in some simple 8080 computers, I/O was indeed addressed as if they were memory cells, \"memory-mapped\", leaving the I/O commands unused. I/O addressing could also sometimes employ the fact that the processor would output the same 8-bit port address to both the lower and the higher address byte (i.e.  would put the address 0505h on the 16-bit address bus). Similar I/O-port schemes were used in the backward-compatible Zilog Z80 and Intel 8085, as well as the closely related x86 families of microprocessors.\n\nSeparate stack space\n\nOne of the bits in the processor state word (see below) indicates that the processor is accessing data from the stack. Using this signal, it is possible to implement a separate stack memory space. However, this feature was seldom used.\n\nThe internal state word\n\nFor more advanced systems, during one phase of its working loop, the processor set its \"internal state byte\" on the data bus. This byte contains flags that determine whether the memory or I/O port is accessed and whether it is necessary to handle an interrupt.\n\nThe interrupt system state (enabled or disabled) is also output on a separate pin. For simple systems, where the interrupts are not used, it is possible to find cases where this pin is used as an additional single-bit output port (the popular Radio-86RK computer made in the Soviet Union, for instance).\n\nExample code\n\nThe following 8080/8085 assembler source code is for a subroutine named memcpy that copies a block of data bytes of a given size from one location to another. The data block is copied one byte at a time, and the data movement and looping logic utilizes 16-bit operations.\n\nPin usage\n\nThe address bus has its own 16 pins, and the data bus has 8 pins that are usable without any multiplexing. Using the two additional pins (read and write signals), it is possible to assemble simple microprocessor devices very easily. Only the separate IO space, interrupts and DMA require additional chips to decode the processor pin signals. However, the processor load capacity is limited, and even simple computers frequently contained bus amplifiers.\n\nThe processor requires three power sources (−5, +5 and +12 V) and two non-overlapping high-amplitude synchronization signals. However, at least the late Soviet version КР580ВМ80А was able to work with a single +5 V power source, the +12 V pin being connected to +5 V and the −5 V pin to ground. The processor consumes about 1.3 W of power.\n\nThe pin-out table, from the chip's accompanying documentation, describes the pins as follows:\n\nSupport chips \n\nA key factor in the success of the 8080 was the broad range of support chips available, providing serial communications, counter/timing, input/output, direct memory access, and programmable interrupt control amongst other functions:\n* [http://www.datasheets360.com/pdf/-4828066515233335508 8238] – System controller and bus driver\n* 8251 – Communication controller\n* 8253 – Programmable interval timer\n* 8255 – Programmable peripheral interface\n* 8257 – DMA controller\n* 8259 – Programmable interrupt controller\n\nPhysical implementation\n\nThe 8080 integrated circuit uses non-saturated enhancement-load nMOS gates, demanding extra voltages (for the load-gate bias). It was manufactured in a silicon gate process using a minimal feature size of 6 µm. A single layer of metal is used to interconnect the approximately 6,000 transistors[http://museum.reichel-orbital.de/index.php?page=cpus Reichel-Orbital museum – CPU Collection]. Museum.reichel-orbital.de. Retrieved on October 23, 2011. in the design, but the higher resistance polysilicon layer, which required higher voltage for some interconnects, is implemented with transistor gates. The die size was approximately 20 mm2.\n\nThe industrial impact\n\nApplications and successors\n\nThe 8080 is used in many early microcomputers, such as the MITS Altair 8800 Computer, Processor Technology SOL-20 Terminal Computer and IMSAI 8080 Microcomputer, forming the basis for machines running the CP/M operating system (the later, almost fully compatible and more capable, Zilog Z80 processor would capitalize on this, with Z80 & CP/M becoming the dominant CPU & OS combination of the period circa 1976 to 1983 much as did the x86 & MS-DOS for the PC a decade later). Even in 1979 after introduction of the Z80 and 8085 processors, five manufacturers of the 8080 were selling an estimated 500,000 units per month at a price around $3 to $4 per unit.Sol Libes BYTE News... in BYTE, , Volume 4 No. 11, November 1979 pg. 82 The first single-board microcomputers, such as MYCRO-1 and the dyna-micro were based on the Intel 8080.  One of the early uses of the 8080 was made in the late 1970s by Cubic-Western Data of San Diego, CA in its Automated Fare Collection Systems custom designed for mass transit systems around the world.  An early industrial use of the 8080 is as the \"brain\" of the DatagraphiX Auto-COM (Computer Output Microfiche) line of products which takes large amounts of user data from reel-to-reel tape and images it onto microfiche. The Auto-COM instruments also include an entire automated film cutting, processing, washing, and drying sub-system – quite a feat, both then and in the 21st century, to all be accomplished successfully with only an 8-bit microprocessor running at a clock speed of less than 1 MHz with a 64 KB memory limit. In addition, several early arcade video games were built around the 8080 microprocessor, including Space Invaders, one of the most popular arcade games ever made.\n\nShortly after the launch of the 8080, the Motorola 6800 competing design was introduced, and after that, the MOS Technology 6502 derivative of the 6800. Zilog introduced the Z80, which has a compatible machine-language instruction set and initially used the same assembly language as the 8080, but for legal reasons, Zilog developed a syntactically-different (but code compatible) alternative assembly language for the Z80. At Intel, the 8080 was followed by the compatible and electrically more elegant 8085, and later by the assembly language compatible 16-bit 8086 and then the 8/16-bit 8088, which was selected by IBM for its new PC to be launched in 1981. Later NEC made the NEC V20 (an 8088 clone with Intel 80186 instruction set compatibility) which also supports an 8080 emulation mode. This is also supported by NEC's V30 (a similarly enhanced 8086 clone). Thus, the 8080, via its ISA, made a lasting impact on computer history.\n\nA number of processors compatible with the Intel 8080A were manufactured in the Eastern Bloc: the KR580VM80A (initially marked as KP580ИK80) in the Soviet Union, the MCY7880[http://www.cpu-world.com/CPUs/8080/Poland-MCY7880.html MCY7880—a Polish-made clone of 8080]. CPU World. Retrieved on October 23, 2011. made by Unitra CEMI in Poland, the MHB8080A[http://www.cpu-world.com/info/exUSSR-chips.html Soviet chips and their western analogs]. CPU-world. Retrieved on October 23, 2011. made by TESLA in Czechoslovakia, the 8080APC made by Tungsram / MEV in Hungary, and the MMN8080 made by Microelectronica Bucharest in Romania.\n\nAs of 2017, the 8080 is still in production at Lansdale Semiconductors.\n\nimage:AMD C8080A.jpg|AMD Am9080\nimage:Poland MCY7880 1.jpg|CEMI MCY7880 (Poland)\nimage:580IK80.jpg|Kvazar Kiev K580IK80 (Soviet Union)\nimage:Mitsubishi M5L8080AP 1.jpg|Mitsubishi Electric M5L8080\nimage:NatSem INS8080AJ 1.jpg|National Semiconductor INS8080\nimage:NEC 8080AF 1.jpg|NEC 8080\nimage:OKI MSM8080A 1.jpg|OKI MSM8080\nimage:Siemens SAB8080A 1.jpg|Siemens SAB8080\nimage:Signetics MP8080AI 1.jpg|Signetics MP8080\nimage:KL Tesla MHB8080.jpg|Tesla (Czechoslovak company) MHB8080\nimage:TI TMS8080JL 1.jpg|Texas Instruments TMS8080\n\nIndustry change\n\nThe 8080 also changed how computers were created. When the 8080 was introduced, computer systems were usually created by computer manufacturers such as Digital Equipment Corporation, Hewlett Packard, or IBM. A manufacturer would produce  the entire computer, including processor, terminals, and system software such as compilers and operating system. The 8080 was actually designed for just about any application except a complete computer system. Hewlett Packard developed the HP 2640 series of smart terminals around the 8080. The HP 2647 is a terminal which runs BASIC on the 8080. Microsoft would market as its founding product the first popular programming language for the 8080, and would later acquire DOS for the IBM PC.\n\nThe 8080 and 8085 gave rise to the 8086, which was designed as a source compatible (although not binary compatible) extension of the 8085. This design, in turn, later spawned the x86 family of chips, the basis for most CPUs in use today. Many of the 8080's core machine instructions and concepts, for example, registers named A, B, C and D, as well as many of the flags used to control conditional jumps, are still in use in the widespread x86 platform. 8080 Assembler code can still be directly translated into x86 instructions; all of its core elements are still present.\n\nPCs based upon the 8086 design and its successors evolved into workstations and servers of 16, 32 and 64 bits, with advanced memory protection, segmentation, and multiprocessing features, blurring the difference between small and large computers  (the 80286 and 80386's protected mode were important in doing so). The size of chips has grown so that the size and power of large x86 chips is not much different from high end architecture chips, and a common strategy to produce a very large computer is to network many x86 processors.\n\nHistory\n\nFederico Faggin, the originator of the 8080 architecture in early 1972, proposed it to Intel's management and pushed for its implementation. He finally got the permission to develop it six months later. Faggin hired Masatoshi Shima from Japan, who did the detailed design under his direction, using the design methodology for random logic with silicon gate that Faggin had created for the 4000 family. Stanley Mazor contributed a couple of instructions to the instruction set.\n\nPatent\n\n* \n\nCultural impact\n\n*Asteroid 8080 Intel is named as a pun and praise on the name of Intel 8080.[http://cfa-www.harvard.edu/iau/lists/MPNames.html CFA-harvard.edu]. CFA-harvard.edu. Retrieved on October 23, 2011.\n*Microsoft's published phone number, 425-882-8080, was chosen because so much early work was on this chip.\n*Many of Intel's main phone numbers also take a similar form: xxx-xxx-8080. Intel 8080. http://en.wikipedia.org/?curid=15062."
  }
}
