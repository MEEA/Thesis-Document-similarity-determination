{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=4547",
  "eid" : "cec81bf0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778426671,
  "textBody" : "Bash is a Unix shell and command language written by Brian Fox for the GNU Project as a free software replacement for the Bourne shell.\n\n  First released in 1989,\n\n it has been distributed widely as the default login shell for most Linux distributions and Apple's macOS (formerly ). A version is also available for Windows 10.\n\nBash is a command processor that typically runs in a text window, where the user types commands that cause actions. Bash can also read and execute commands from a file, called a shell script.  Like all Unix shells, it supports  filename globbing (wildcard matching), piping, here documents, command substitution, variables, and control structures for condition-testing and iteration. The keywords, syntax and other basic features of the language are all copied from sh.  Other features, e.g., history, are copied from csh and ksh.  Bash is a POSIX-compliant shell, but with a number of extensions.\n\nThe shell's name is an acronym for Bourne-again shell, a pun on the name of the Bourne shell that it replaces[http://www.ddj.com/cpp/184404693 C Programming] by Al Stevens, Dr. Dobb's Journal, July 1, 2001\nand on the term \"born again\" that denotes spiritual rebirth in Christian Evangelicalism.\n\nA security hole in Bash dating from version 1.03 (August 1989), dubbed Shellshock, was discovered in early September 2014 and quickly led to a range of attacks across the Internet. Patches to fix the bugs were made available soon after the bugs were identified, but not all computers have been updated.\n\nHistory\n \nBrian Fox began coding Bash on January 10, 1988\n\n after Richard Stallman became dissatisfied with the lack of progress being made by a prior developer.  Stallman and the Free Software Foundation (FSF) considered a free shell that could run existing shell scripts so strategic to a completely free system built from BSD and GNU code that this was one of the few projects they funded themselves, with Fox undertaking the work as an employee of FSF.\n\n Fox released Bash as a beta, version .99, on June 8, 1989 and remained the primary maintainer until sometime between mid-1992\n\n and mid-1994, when he was laid off from FSF\n\n and his responsibility was transitioned to another early contributor, Chet Ramey.\n\nSince then, Bash has become by far the most popular shell among users of Linux, becoming the default interactive shell on that operating system's various distributions (although Almquist shell may be the default scripting shell) and on Apple's macOS.\n\n Bash has also been ported to Microsoft Windows and distributed with Cygwin and MinGW, to DOS by the DJGPP project, to Novell NetWare and to Android via various terminal emulation applications.\n\nIn September 2014, Stéphane Chazelas, a Unix/Linux, network and telecom specialist working in the UK,https://www.linkedin.com/pub/st%C3%A9phane-chazelas/7/2a2/834 discovered a security bug in the program. The bug, first disclosed on September 24, was named Shellshock and assigned the numbers [http://cve.mitre.org/cgi-bin/cvename.cgi?nameCVE-2014-6271 CVE-2014-6271], CVE-2014-6277 and [http://cve.mitre.org/cgi-bin/cvename.cgi?name\nCVE-2014-7169 CVE-2014-7169]. The bug was regarded as severe, since CGI scripts using Bash could be vulnerable, enabling arbitrary code execution.  The bug was related to how Bash passes function definitions to subshells through environment variables.\n\nFeatures\n\nThe Bash command syntax is a superset of the Bourne shell command syntax. Bash can execute the vast majority of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc.  Bash command syntax includes ideas drawn from the Korn shell (ksh) and the C shell (csh) such as command line editing, command history, the directory stack, the $RANDOM and $PPID variables, and POSIX command substitution syntax $(…).\n\nWhen a user presses the tab key within an interactive command-shell, Bash automatically uses command line completion to match partly typed program names, filenames and variable names.  The Bash command-line completion system is very flexible and customizable, and is often packaged with functions that complete arguments and filenames for specific programs and tasks.\n\nBash's syntax has many extensions lacking in the Bourne shell. Bash can perform integer calculations (\"arithmetic evaluation\") without spawning external processes. It uses the ((…)) command and the $((…)) variable syntax for this purpose. Its syntax simplifies I/O redirection. For example, it can redirect standard output (stdout) and standard error (stderr) at the same time using the &> operator. This is simpler to type than the Bourne shell equivalent 'command > file 2>&1'.  Bash supports process substitution using the  and >(command)syntax, which substitutes the output of (or input to) a command where a filename is normally used.  (This is implemented through /proc/fd/ unnamed pipes on systems that support that, or via temporary named pipes where necessary).\n\nWhen using the 'function' keyword, Bash function declarations are not compatible with Bourne/Korn/POSIX scripts (the Korn shell has the same problem when using 'function'), but Bash accepts the same function declaration syntax as the Bourne and Korn shells, and is POSIX-conformant. Because of these and other differences, Bash shell scripts are rarely runnable under the Bourne or Korn shell interpreters unless deliberately written with that compatibility in mind, which is becoming less common as Linux becomes more widespread. But in POSIX mode, Bash conforms with POSIX more closely.\n\nBash supports here documents. Since version 2.05b Bash can redirect standard input (stdin) from a \"here string\" using the  operator.\n\nBash 3.0 supports in-process regular expression matching using a syntax reminiscent of Perl.The syntax matches that shown on the [http://www.tin.org/bin/man.cgi?section7&topic\nregex regex(7)] man page.\n\nBash 4.0 introduced support for associative arrays.\"The shell provides associative array variables, with the appropriate support to create, delete, assign values to, and expand them.\" http://tiswww.case.edu/php/chet/bash/NEWS Associative arrays allow a fake support for multi-dimensional (indexed) arrays, in a similar way to AWK:\n\n$ declare -a aa        # declare an associative array 'aa' faking a bi-dimensional indexed array\n$ i1; j\n2             # initialize some indices\n$ aa[$i,$j]=5          # associate value \"5\" to key \"$i,$j\" (i.e. \"1,2\")\n$ echo ${aa[$i,$j]}    # print the stored value at key \"$i,$j\"\n5\n\nBrace expansion\n\nBrace expansion, also called alternation, is a feature copied from the C shell. It generates a set of alternative combinations. Generated results need not exist as files. The results of each expanded string are not sorted and left to right order is preserved:\n\n$ echo a{p,c,d,b}e\nape ace ade abe\n$ echo {a,b,c}{d,e,f}\nad ae af bd be bf cd ce cf\n\nUsers should not use brace expansions in portable shell scripts, because the Bourne shell does not produce the same output.\n\n$ # A traditional shell does not produce the same output\n$ /bin/sh -c 'echo a{p,c,d,b}e'\na{p,c,d,b}e\n\nWhen brace expansion is combined with wildcards, the braces are expanded first, and then the resulting wildcards are substituted normally.  Hence, a listing of JPEG and PNG images in the current directory could be obtained using:\n\nls *.{jpg,jpeg,png}    # expands to *.jpg *.jpeg *.png - after which,\n                       # the wildcards are processed\necho *.{png,jp{e,}g}   # echo just show the expansions -\n                       # and braces in braces are possible.\n\nIn addition to alternation, brace expansion can be used for sequential ranges between two integers or characters separated by double dots. Newer versions of Bash allow a third integer to specify the increment.\n\n$ echo {1..10}\n1 2 3 4 5 6 7 8 9 10\n$ echo file{1..4}.txt\nfile1.txt file2.txt file3.txt file4.txt\n$ echo {a..e}\na b c d e\n$ echo {1..10..3}\n1 4 7 10\n$ echo {a..j..3}\na d g j\n\nWhen brace expansion is combined with variable expansion the variable expansion is performed after the brace expansion, which in some cases may necessitate the use of the eval built-in, thus:\n\n$ start1; end\n10\n$ echo {$start..$end}  # fails to expand due to the evaluation order\n{1..10}\n$ eval echo {$start..$end} # variable expansion occurs then resulting string is evaluated\n1 2 3 4 5 6 7 8 9 10\n\nStartup scripts\n\nWhen Bash starts, it executes the commands in a variety of dot files.  Though similar to Bash shell script commands, which have execute permission enabled and an interpreter directive like #!/bin/bash, the initialization files used by Bash require neither.\n\nExecution order of startup files\n\nWhen started as an interactive login shell\n\nBash reads and executes /etc/profile (if it exists). (Often this file calls /etc/bash.bashrc.)\n\nAfter reading that file, it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile in that order, and reads and executes the first one that exists and is readable.\n\nWhen a login shell exits\n\nBash reads and executes ~/.bash_logout (if it exists).\n\nWhen started as an interactive shell (but not a login shell)\n\nBash reads and executes /etc/bash.bashrc and then ~/.bashrc (if it exists). This may be inhibited by using the --norc option. The --rcfile file option forces Bash to read and execute commands from file instead of ~/.bashrc.\n\nComparison with the Bourne shell and csh startup sequences\n\nElements of Bash derive from the Bourne shell and csh. These allow limited startup file sharing with the Bourne shell and provide some startup features familiar to csh users.\n\nSetting inheritable environment variables\n\nThe Bourne shell uses the ~/.profile at login to set environment variables that subprocesses then inherit. Bash can use the ~/.profile in a compatible way, by executing it explicitly from the Bash-specific ~/.bash_profile or ~/.bash_login with the line below.  Bash-specific syntax can be kept out of the ~/.profile to keep the latter compatible with the Bourne shell.\n. ~/.profile\n\nAliases and Functions\n\nThese two facilities, aliases from csh and the more general functions that largely supersede them from Bourne shell, were not typically inheritable from the login shell, and had to be redefined in each subshell spawned from the login shell.  Although there is an ENV environment variable that could be applied to the problem, both csh and Bash support per-subshell startup files that address it directly.  In Bash, the ~/.bashrc is called for interactive subshells.  If user-defined functions from the ~/.bashrc are desired in the login shell as well, the ~/.bash_login can include the line below after any setting up of environment variables:\n. ~/.bashrc\n\nCommands performed only at login and logout\n\nThe csh supports a ~/.login file for purposes of tasks performed only during initial login, such as displaying system load, disk status, whether email has come in, logging the login time, etc.  The Bourne shell can emulate this in the ~/.profile, but doesn't predefine a file name.  To achieve similar semantics to the csh model, the ~/.bash_profile can contain the line below, after the environment setup and function setup:\n. ~/.bash_login\nLikewise, the csh has a ~/.logout file run only when the login shell exits.  The Bash equivalent is ~/.bash_logout, and requires no special setup.  In the Bourne shell, the trap built-in can be used to achieve a similar effect.\n\nLegacy-compatible Bash startup example\n\nThe skeleton ~/.bash_profile below is compatible with the Bourne shell and gives semantics similar to csh for the ~/.bashrc and ~/.bash_login.  The [ -r filename ] are tests to see if the filename exists and is readable, simply skipping the part after the && if it's not.\n\n[ -r ~/.profile ] && . ~/.profile             # set up environment, once, Bourne-sh syntax only\nif [ -n \"$PS1\" ] ; then                       # are we interactive?\n   [ -r ~/.bashrc     ] && . ~/.bashrc        # tty/prompt/function setup for interactive shells\n   [ -r ~/.bash_login ] && . ~/.bash_login    # any at-login tasks for login shell only\nfi                                            # End of \"if\" block\n\nOperating system issues in Bash startup\n\nSome versions of Unix and Linux contain Bash system startup scripts, generally under the /etc directories. Bash calls these as part of its standard initialization, but other startup files can read them in a different order than the documented Bash startup sequence.  The default content of the root user's files may also have issues, as well as the skeleton files the system provides to new user accounts upon setup.  The startup scripts that launch the X window system may also do surprising things with the user's Bash startup scripts in an attempt to set up user-environment variables before launching the window manager. These issues can often be addressed using a ~/.xsession or ~/.xprofile file to read the ~/.profile — which provides the environment variables that Bash shell windows spawned from the window manager need, such as xterm or Gnome Terminal.\n\nPortability\n\nInvoking Bash with the --posix option or stating set -o posix in a script causes Bash to conform very closely to the POSIX 1003.2 standard.\nBash shell scripts intended for portability should at least take into account the Bourne shell it intends to replace. Bash has certain features that the traditional Bourne shell lacks. They include:\n\n* Certain extended invocation options\n* Command substitution using $( ) notation (this feature is part of the POSIX 1003.2 standard though)\n* Brace expansion\n* Certain array operations, and associative arrays\n* The double brackets extended test construct\n* The double-parentheses arithmetic-evaluation construct\n* Certain string-manipulation operations\n* Process substitution\n* A Regular Expression matching operator\n* Bash-specific builtins\n* Coprocesses\n\nA \"bashism\" is a portion of bash code that does not run properly on other Unix shells.\n\nKeyboard shortcuts\n\nBash uses readline to provide keyboard shortcuts for command line editing using the default (Emacs) key bindings. Vi-bindings can be enabled by running set -o vi.\n\nProcess management\n\nThe Bash shell has two modes of execution for commands:  batch, and concurrent mode.\n\nTo execute commands in batch (i.e., in sequence) they must be separated by the character \";\", or on separate lines:\n\ncommand1; command2\n\nin this example, when command1 is finished, command2 is executed.\n\nTo have a concurrent execution of command1 and command2, they must be executed in the Bash shell in the following way:\n\ncommand1 & command2\n\nIn this case command1 is executed in the background (symbol &), returning immediately control to the shell that executes command2 in the foreground.\n\nBesides foreground and background, a process can be stopped. This is achieved by typing  while the process is running in the foreground. A list of all processes, both in the background and stopped, can be achieved by running jobs:\n\n$ jobs\n[1]-  Running                  command1 &\n[2]+  Stopped                  command2\n\nIn the output, the number in brackets refers to the job id. The plus sign signifies the default process for bg and fg. The text \"Running\" and \"Stopped\" refer to the Process state. The last string is the command that started the process. \n\nThe state of a process can be changed using various commands. The fg command brings a process to the foreground, while the bg sets a stopped process running in the background. bg and fg can take a job id as their first argument, to specify the process to act on. Without one, they use the default process, identified by a plus sign in the output of jobs. The kill command can be used to end a process prematurely, by sending it a signal. The job id must be specified after a percent sign:\n\nkill -s SIGKILL %1 \n\nConditional execution\n\nBash supplies \"conditional execution\" command separators that make execution of a command contingent on the exit code set by a precedent command. For example:\n\ncd \"$SOMEWHERE\" && ./do_something || echo \"An error occurred\" >&2\n\nWhere ./do_something is only executed if the cd (change directory) command was \"successful\" (returned an exit status of zero) and the echo command would only be executed if either the cd or the ./do_something command return an \"error\" (non-zero exit status).\n\nFor all commands the exit status is stored in the special variable $?.  Bash also supports  and  forms of conditional command evaluation.\n\nBug reporting\n\nAn external command called bashbug reports Bash shell bugs. When the command is invoked, it brings up the user's default editor with a form to fill in. The form is mailed to the Bash maintainers (or optionally to other email addresses).\n[http://linux.die.net/man/1/bashbug bashbug(1)], die.net\n\n[https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man1/bashbug.1.html \"Linux / Unix Command: bashbug\"], apple.com",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Bash (Unix shell)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=4547" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Bash is a Unix shell and command language written by Brian Fox for the GNU Project as a free software replacement for the Bourne shell.\n\n  First released in 1989,\n\n it has been distributed widely as the default login shell for most Linux distributions and Apple's macOS (formerly ). A version is also available for Windows 10.\n\nBash is a command processor that typically runs in a text window, where the user types commands that cause actions. Bash can also read and execute commands from a file, called a shell script.  Like all Unix shells, it supports  filename globbing (wildcard matching), piping, here documents, command substitution, variables, and control structures for condition-testing and iteration. The keywords, syntax and other basic features of the language are all copied from sh.  Other features, e.g., history, are copied from csh and ksh.  Bash is a POSIX-compliant shell, but with a number of extensions.\n\nThe shell's name is an acronym for Bourne-again shell, a pun on the name of the Bourne shell that it replaces[http://www.ddj.com/cpp/184404693 C Programming] by Al Stevens, Dr. Dobb's Journal, July 1, 2001\nand on the term \"born again\" that denotes spiritual rebirth in Christian Evangelicalism.\n\nA security hole in Bash dating from version 1.03 (August 1989), dubbed Shellshock, was discovered in early September 2014 and quickly led to a range of attacks across the Internet. Patches to fix the bugs were made available soon after the bugs were identified, but not all computers have been updated.\n\nHistory\n \nBrian Fox began coding Bash on January 10, 1988\n\n after Richard Stallman became dissatisfied with the lack of progress being made by a prior developer.  Stallman and the Free Software Foundation (FSF) considered a free shell that could run existing shell scripts so strategic to a completely free system built from BSD and GNU code that this was one of the few projects they funded themselves, with Fox undertaking the work as an employee of FSF.\n\n Fox released Bash as a beta, version .99, on June 8, 1989 and remained the primary maintainer until sometime between mid-1992\n\n and mid-1994, when he was laid off from FSF\n\n and his responsibility was transitioned to another early contributor, Chet Ramey.\n\nSince then, Bash has become by far the most popular shell among users of Linux, becoming the default interactive shell on that operating system's various distributions (although Almquist shell may be the default scripting shell) and on Apple's macOS.\n\n Bash has also been ported to Microsoft Windows and distributed with Cygwin and MinGW, to DOS by the DJGPP project, to Novell NetWare and to Android via various terminal emulation applications.\n\nIn September 2014, Stéphane Chazelas, a Unix/Linux, network and telecom specialist working in the UK,https://www.linkedin.com/pub/st%C3%A9phane-chazelas/7/2a2/834 discovered a security bug in the program. The bug, first disclosed on September 24, was named Shellshock and assigned the numbers [http://cve.mitre.org/cgi-bin/cvename.cgi?nameCVE-2014-6271 CVE-2014-6271], CVE-2014-6277 and [http://cve.mitre.org/cgi-bin/cvename.cgi?name\nCVE-2014-7169 CVE-2014-7169]. The bug was regarded as severe, since CGI scripts using Bash could be vulnerable, enabling arbitrary code execution.  The bug was related to how Bash passes function definitions to subshells through environment variables.\n\nFeatures\n\nThe Bash command syntax is a superset of the Bourne shell command syntax. Bash can execute the vast majority of Bourne shell scripts without modification, with the exception of Bourne shell scripts stumbling into fringe syntax behavior interpreted differently in Bash or attempting to run a system command matching a newer Bash builtin, etc.  Bash command syntax includes ideas drawn from the Korn shell (ksh) and the C shell (csh) such as command line editing, command history, the directory stack, the $RANDOM and $PPID variables, and POSIX command substitution syntax $(…).\n\nWhen a user presses the tab key within an interactive command-shell, Bash automatically uses command line completion to match partly typed program names, filenames and variable names.  The Bash command-line completion system is very flexible and customizable, and is often packaged with functions that complete arguments and filenames for specific programs and tasks.\n\nBash's syntax has many extensions lacking in the Bourne shell. Bash can perform integer calculations (\"arithmetic evaluation\") without spawning external processes. It uses the ((…)) command and the $((…)) variable syntax for this purpose. Its syntax simplifies I/O redirection. For example, it can redirect standard output (stdout) and standard error (stderr) at the same time using the &> operator. This is simpler to type than the Bourne shell equivalent 'command > file 2>&1'.  Bash supports process substitution using the  and >(command)syntax, which substitutes the output of (or input to) a command where a filename is normally used.  (This is implemented through /proc/fd/ unnamed pipes on systems that support that, or via temporary named pipes where necessary).\n\nWhen using the 'function' keyword, Bash function declarations are not compatible with Bourne/Korn/POSIX scripts (the Korn shell has the same problem when using 'function'), but Bash accepts the same function declaration syntax as the Bourne and Korn shells, and is POSIX-conformant. Because of these and other differences, Bash shell scripts are rarely runnable under the Bourne or Korn shell interpreters unless deliberately written with that compatibility in mind, which is becoming less common as Linux becomes more widespread. But in POSIX mode, Bash conforms with POSIX more closely.\n\nBash supports here documents. Since version 2.05b Bash can redirect standard input (stdin) from a \"here string\" using the  operator.\n\nBash 3.0 supports in-process regular expression matching using a syntax reminiscent of Perl.The syntax matches that shown on the [http://www.tin.org/bin/man.cgi?section7&topic\nregex regex(7)] man page.\n\nBash 4.0 introduced support for associative arrays.\"The shell provides associative array variables, with the appropriate support to create, delete, assign values to, and expand them.\" http://tiswww.case.edu/php/chet/bash/NEWS Associative arrays allow a fake support for multi-dimensional (indexed) arrays, in a similar way to AWK:\n\n$ declare -a aa        # declare an associative array 'aa' faking a bi-dimensional indexed array\n$ i1; j\n2             # initialize some indices\n$ aa[$i,$j]=5          # associate value \"5\" to key \"$i,$j\" (i.e. \"1,2\")\n$ echo ${aa[$i,$j]}    # print the stored value at key \"$i,$j\"\n5\n\nBrace expansion\n\nBrace expansion, also called alternation, is a feature copied from the C shell. It generates a set of alternative combinations. Generated results need not exist as files. The results of each expanded string are not sorted and left to right order is preserved:\n\n$ echo a{p,c,d,b}e\nape ace ade abe\n$ echo {a,b,c}{d,e,f}\nad ae af bd be bf cd ce cf\n\nUsers should not use brace expansions in portable shell scripts, because the Bourne shell does not produce the same output.\n\n$ # A traditional shell does not produce the same output\n$ /bin/sh -c 'echo a{p,c,d,b}e'\na{p,c,d,b}e\n\nWhen brace expansion is combined with wildcards, the braces are expanded first, and then the resulting wildcards are substituted normally.  Hence, a listing of JPEG and PNG images in the current directory could be obtained using:\n\nls *.{jpg,jpeg,png}    # expands to *.jpg *.jpeg *.png - after which,\n                       # the wildcards are processed\necho *.{png,jp{e,}g}   # echo just show the expansions -\n                       # and braces in braces are possible.\n\nIn addition to alternation, brace expansion can be used for sequential ranges between two integers or characters separated by double dots. Newer versions of Bash allow a third integer to specify the increment.\n\n$ echo {1..10}\n1 2 3 4 5 6 7 8 9 10\n$ echo file{1..4}.txt\nfile1.txt file2.txt file3.txt file4.txt\n$ echo {a..e}\na b c d e\n$ echo {1..10..3}\n1 4 7 10\n$ echo {a..j..3}\na d g j\n\nWhen brace expansion is combined with variable expansion the variable expansion is performed after the brace expansion, which in some cases may necessitate the use of the eval built-in, thus:\n\n$ start1; end\n10\n$ echo {$start..$end}  # fails to expand due to the evaluation order\n{1..10}\n$ eval echo {$start..$end} # variable expansion occurs then resulting string is evaluated\n1 2 3 4 5 6 7 8 9 10\n\nStartup scripts\n\nWhen Bash starts, it executes the commands in a variety of dot files.  Though similar to Bash shell script commands, which have execute permission enabled and an interpreter directive like #!/bin/bash, the initialization files used by Bash require neither.\n\nExecution order of startup files\n\nWhen started as an interactive login shell\n\nBash reads and executes /etc/profile (if it exists). (Often this file calls /etc/bash.bashrc.)\n\nAfter reading that file, it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile in that order, and reads and executes the first one that exists and is readable.\n\nWhen a login shell exits\n\nBash reads and executes ~/.bash_logout (if it exists).\n\nWhen started as an interactive shell (but not a login shell)\n\nBash reads and executes /etc/bash.bashrc and then ~/.bashrc (if it exists). This may be inhibited by using the --norc option. The --rcfile file option forces Bash to read and execute commands from file instead of ~/.bashrc.\n\nComparison with the Bourne shell and csh startup sequences\n\nElements of Bash derive from the Bourne shell and csh. These allow limited startup file sharing with the Bourne shell and provide some startup features familiar to csh users.\n\nSetting inheritable environment variables\n\nThe Bourne shell uses the ~/.profile at login to set environment variables that subprocesses then inherit. Bash can use the ~/.profile in a compatible way, by executing it explicitly from the Bash-specific ~/.bash_profile or ~/.bash_login with the line below.  Bash-specific syntax can be kept out of the ~/.profile to keep the latter compatible with the Bourne shell.\n. ~/.profile\n\nAliases and Functions\n\nThese two facilities, aliases from csh and the more general functions that largely supersede them from Bourne shell, were not typically inheritable from the login shell, and had to be redefined in each subshell spawned from the login shell.  Although there is an ENV environment variable that could be applied to the problem, both csh and Bash support per-subshell startup files that address it directly.  In Bash, the ~/.bashrc is called for interactive subshells.  If user-defined functions from the ~/.bashrc are desired in the login shell as well, the ~/.bash_login can include the line below after any setting up of environment variables:\n. ~/.bashrc\n\nCommands performed only at login and logout\n\nThe csh supports a ~/.login file for purposes of tasks performed only during initial login, such as displaying system load, disk status, whether email has come in, logging the login time, etc.  The Bourne shell can emulate this in the ~/.profile, but doesn't predefine a file name.  To achieve similar semantics to the csh model, the ~/.bash_profile can contain the line below, after the environment setup and function setup:\n. ~/.bash_login\nLikewise, the csh has a ~/.logout file run only when the login shell exits.  The Bash equivalent is ~/.bash_logout, and requires no special setup.  In the Bourne shell, the trap built-in can be used to achieve a similar effect.\n\nLegacy-compatible Bash startup example\n\nThe skeleton ~/.bash_profile below is compatible with the Bourne shell and gives semantics similar to csh for the ~/.bashrc and ~/.bash_login.  The [ -r filename ] are tests to see if the filename exists and is readable, simply skipping the part after the && if it's not.\n\n[ -r ~/.profile ] && . ~/.profile             # set up environment, once, Bourne-sh syntax only\nif [ -n \"$PS1\" ] ; then                       # are we interactive?\n   [ -r ~/.bashrc     ] && . ~/.bashrc        # tty/prompt/function setup for interactive shells\n   [ -r ~/.bash_login ] && . ~/.bash_login    # any at-login tasks for login shell only\nfi                                            # End of \"if\" block\n\nOperating system issues in Bash startup\n\nSome versions of Unix and Linux contain Bash system startup scripts, generally under the /etc directories. Bash calls these as part of its standard initialization, but other startup files can read them in a different order than the documented Bash startup sequence.  The default content of the root user's files may also have issues, as well as the skeleton files the system provides to new user accounts upon setup.  The startup scripts that launch the X window system may also do surprising things with the user's Bash startup scripts in an attempt to set up user-environment variables before launching the window manager. These issues can often be addressed using a ~/.xsession or ~/.xprofile file to read the ~/.profile — which provides the environment variables that Bash shell windows spawned from the window manager need, such as xterm or Gnome Terminal.\n\nPortability\n\nInvoking Bash with the --posix option or stating set -o posix in a script causes Bash to conform very closely to the POSIX 1003.2 standard.\nBash shell scripts intended for portability should at least take into account the Bourne shell it intends to replace. Bash has certain features that the traditional Bourne shell lacks. They include:\n\n* Certain extended invocation options\n* Command substitution using $( ) notation (this feature is part of the POSIX 1003.2 standard though)\n* Brace expansion\n* Certain array operations, and associative arrays\n* The double brackets extended test construct\n* The double-parentheses arithmetic-evaluation construct\n* Certain string-manipulation operations\n* Process substitution\n* A Regular Expression matching operator\n* Bash-specific builtins\n* Coprocesses\n\nA \"bashism\" is a portion of bash code that does not run properly on other Unix shells.\n\nKeyboard shortcuts\n\nBash uses readline to provide keyboard shortcuts for command line editing using the default (Emacs) key bindings. Vi-bindings can be enabled by running set -o vi.\n\nProcess management\n\nThe Bash shell has two modes of execution for commands:  batch, and concurrent mode.\n\nTo execute commands in batch (i.e., in sequence) they must be separated by the character \";\", or on separate lines:\n\ncommand1; command2\n\nin this example, when command1 is finished, command2 is executed.\n\nTo have a concurrent execution of command1 and command2, they must be executed in the Bash shell in the following way:\n\ncommand1 & command2\n\nIn this case command1 is executed in the background (symbol &), returning immediately control to the shell that executes command2 in the foreground.\n\nBesides foreground and background, a process can be stopped. This is achieved by typing  while the process is running in the foreground. A list of all processes, both in the background and stopped, can be achieved by running jobs:\n\n$ jobs\n[1]-  Running                  command1 &\n[2]+  Stopped                  command2\n\nIn the output, the number in brackets refers to the job id. The plus sign signifies the default process for bg and fg. The text \"Running\" and \"Stopped\" refer to the Process state. The last string is the command that started the process. \n\nThe state of a process can be changed using various commands. The fg command brings a process to the foreground, while the bg sets a stopped process running in the background. bg and fg can take a job id as their first argument, to specify the process to act on. Without one, they use the default process, identified by a plus sign in the output of jobs. The kill command can be used to end a process prematurely, by sending it a signal. The job id must be specified after a percent sign:\n\nkill -s SIGKILL %1 \n\nConditional execution\n\nBash supplies \"conditional execution\" command separators that make execution of a command contingent on the exit code set by a precedent command. For example:\n\ncd \"$SOMEWHERE\" && ./do_something || echo \"An error occurred\" >&2\n\nWhere ./do_something is only executed if the cd (change directory) command was \"successful\" (returned an exit status of zero) and the echo command would only be executed if either the cd or the ./do_something command return an \"error\" (non-zero exit status).\n\nFor all commands the exit status is stored in the special variable $?.  Bash also supports  and  forms of conditional command evaluation.\n\nBug reporting\n\nAn external command called bashbug reports Bash shell bugs. When the command is invoked, it brings up the user's default editor with a form to fill in. The form is mailed to the Bash maintainers (or optionally to other email addresses).\n[http://linux.die.net/man/1/bashbug bashbug(1)], die.net\n\n[https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man1/bashbug.1.html \"Linux / Unix Command: bashbug\"], apple.com. Bash (Unix shell). http://en.wikipedia.org/?curid=4547."
  }
}
