{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=20340",
  "eid" : "418212e0-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778619150,
  "textBody" : "Mary was a programming language designed and implemented by RUNIT at Trondheim, Norway in the 1970s. It borrowed many features from ALGOL 68 but was designed for machine-oriented programming.\n\nAn unusual feature of its syntax was that expressions were constructed using the conventional infix operators, but all of them had the same precedence and evaluation went from left to right unless there were brackets. Assignment had the destination on the right and assignment was considered just another operator.\n\nSimilar to C, several language features appear to have existed to allow programmers to produce reasonably well optimised code, despite a quite primitive code generator in the compiler. These included operators similar to the += et alter  in C and explicit register declarations for variables.\n\nNotable features:\n* \"Dataflow syntax\" - values flow from left to right, including assignment.\n* Most constructs could be used in expressions (blocks, IF, CASE, etc.).\n* Text-based recursive macros.\n* Overloaded user-defined operators, not constrained to predefined identifiers as in C++.\n* Automatic building and dereferencing of pointers from type context.\n* Scalar range types.\n* Array and set enumeration in loop iterators.\n* Dynamic array descriptors (ROW).\n\nA book describing Mary was printed in 1974 (Fourth and last edition in 1979): Mary Textbook by Reidar Conradi & Per Holager.\n\nCompilers were made for Kongsberg Våpenfabrikk's SM-4  and Norsk Data Nord-10/ND-100 mini-computers. The original Mary compiler was written in NU ALGOL, ran on the Univac-1100 series and was used to bootstrap a native compiler for ND-100/SINTRAN-III. RUNIT implemented a CHILL compiler written in Mary which ran on ND-100 and had Intel 8086 and 80286 targets. When this compiler was ported to the VAX platform, a common backend for Mary and CHILL was implemented. Later, backends for i386 and SPARC were available. Since the Mary compiler was implemented in Mary, it was possible to run the compiler on all these platforms.\n\nMary is no longer maintained.\n\nExample \n\n BEGIN\n    INT i := 10;          %% Variable with initial value.\n    REF INT ri := i;      %% Pointer initialized to point to i.\n    INT j := 11;\n    j :- REF INT =: ri;   %% Type conversion and assignment\n                          %% ri now points to j.\n    i =: (ri :- VAL REF INT);     \n                          %% Assignment and type conversion\n                          %% ri points to j so j is changed.\n    IF j > 10             %% Conditional statement with result\n    THEN                  %% used inside an arithmetic expression.\n       1\n    ELSE\n       2\n    FI + j =: j;\n END",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Mary (programming language)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=20340" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Mary was a programming language designed and implemented by RUNIT at Trondheim, Norway in the 1970s. It borrowed many features from ALGOL 68 but was designed for machine-oriented programming.\n\nAn unusual feature of its syntax was that expressions were constructed using the conventional infix operators, but all of them had the same precedence and evaluation went from left to right unless there were brackets. Assignment had the destination on the right and assignment was considered just another operator.\n\nSimilar to C, several language features appear to have existed to allow programmers to produce reasonably well optimised code, despite a quite primitive code generator in the compiler. These included operators similar to the += et alter  in C and explicit register declarations for variables.\n\nNotable features:\n* \"Dataflow syntax\" - values flow from left to right, including assignment.\n* Most constructs could be used in expressions (blocks, IF, CASE, etc.).\n* Text-based recursive macros.\n* Overloaded user-defined operators, not constrained to predefined identifiers as in C++.\n* Automatic building and dereferencing of pointers from type context.\n* Scalar range types.\n* Array and set enumeration in loop iterators.\n* Dynamic array descriptors (ROW).\n\nA book describing Mary was printed in 1974 (Fourth and last edition in 1979): Mary Textbook by Reidar Conradi & Per Holager.\n\nCompilers were made for Kongsberg Våpenfabrikk's SM-4  and Norsk Data Nord-10/ND-100 mini-computers. The original Mary compiler was written in NU ALGOL, ran on the Univac-1100 series and was used to bootstrap a native compiler for ND-100/SINTRAN-III. RUNIT implemented a CHILL compiler written in Mary which ran on ND-100 and had Intel 8086 and 80286 targets. When this compiler was ported to the VAX platform, a common backend for Mary and CHILL was implemented. Later, backends for i386 and SPARC were available. Since the Mary compiler was implemented in Mary, it was possible to run the compiler on all these platforms.\n\nMary is no longer maintained.\n\nExample \n\n BEGIN\n    INT i := 10;          %% Variable with initial value.\n    REF INT ri := i;      %% Pointer initialized to point to i.\n    INT j := 11;\n    j :- REF INT =: ri;   %% Type conversion and assignment\n                          %% ri now points to j.\n    i =: (ri :- VAL REF INT);     \n                          %% Assignment and type conversion\n                          %% ri points to j so j is changed.\n    IF j > 10             %% Conditional statement with result\n    THEN                  %% used inside an arithmetic expression.\n       1\n    ELSE\n       2\n    FI + j =: j;\n END. Mary (programming language). http://en.wikipedia.org/?curid=20340."
  }
}
