{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=20087",
  "eid" : "3fc372f0-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778616223,
  "textBody" : "In mathematics, modular arithmetic is a system of arithmetic for integers, where numbers \"wrap around\" upon reaching a certain value—the modulus (plural moduli).  The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801.\n\nA familiar use of modular arithmetic is in the 12-hour clock, in which the day is divided into two 12-hour periods. If the time is 7:00 now, then 8 hours later it will be 3:00. Usual addition would suggest that the later time should be , but this is not the answer because clock time \"wraps around\" every 12 hours. Because the hour number starts over after it reaches 12, this is arithmetic modulo 12. According to the definition below, 12 is congruent not only to 12 itself, but also to 0, so the time called \"12:00\" could also be called \"0:00\", since 12 is congruent to 0 modulo 12.\n\nDefinition of congruence relation\n\nModular arithmetic can be handled mathematically by introducing a congruence relation on the integers that is compatible with the operations on integers: addition, subtraction, and multiplication. For a positive integer , two numbers  and  are said to be ', if their difference  is an integer multiple of  (that is, if there is an integer  such that ). This congruence relation is typically considered when  and  are integers, and is denoted \na \\equiv b \\pmod n.\n(some authors use  instead of ; in this case, if the parentheses are omitted, this generally means that \"mod\" denotes the modulo operation, that is, that ).\n\nThe number  is called the ' of the congruence. \n\nThe congruence relation may be rewritten as\na = kn + b,\nexplicitly showing its relationship with Euclidean division. However,  need not be the remainder of the division of  by  More precisely, what the statement  asserts is that   and  have the same remainder when divided by . That is,\na = pn + r,\nb = qn + r,\nwhere  is the common remainder. Subtracting these two expressions, we recover the previous relation:\na - b = kn,\nby setting \n\nExamples\n\nFor example,\n\n38 \\equiv 14 \\pmod {12}\\,\n\nbecause , which is a multiple of 12, or, equivalently, because both 38 and 14 have the same remainder 2 when divided by 12.\n\nThe same rule holds for negative values:\n\n \\begin{align}\n-8 &\\equiv 7 \\pmod 5\\\\\n2 &\\equiv -3 \\pmod 5\\\\\n -3 &\\equiv -8 \\pmod 5.\n\\end{align}\n\nA remark on the notation: Because it is common to consider several congruence relations for different moduli at the same time, the modulus is incorporated in the notation. In spite of the ternary notation, the congruence relation for a given modulus is binary. This would have been clearer if the notation  had been used, instead of the common traditional notation.\n\nProperties \n\nThe congruence relation satisfies all the conditions of an equivalence relation:\n* Reflexivity:  \n* Symmetry:  if and only if \n* Transitivity: If  and , then \n\nIf  and  or if  then:\n*  for any integer  (compatibility with translation)\n*  for any integer  (compatibility with scaling)\n*  (compatibility with addition)\n*   (compatibility with subtraction)\n*   (compatibility with multiplication)\n*  for any non-negative integer  (compatibility with exponentiation)\n* , for any polynomial  with integer coefficients (compatibility with polynomial evaluation)\n\nIf , then it is false, in general, that . However, one has:\n* If  where φ is Euler's totient function, then  provided  is coprime with \n\nFor cancellation of common terms, we have the following rules:\n\n* If  for any integer , then \n* If  and  is coprime with , then \n\nThe modular multiplicative inverse is defined by the following rules:\n \n* Existence: there exists an integer denoted  such that  if and only if  is coprime with . This integer  is called a modular multiplicative inverse of  modulo .\n* If  and  exists, then  (compatibility with multiplicative inverse, and, if , uniqueness modulo )\n* If  and  is coprime to , the solution to this linear congruence is given by  \n\nIn particular, if  is a prime number then  is coprime with  for every  such that . Thus, a multiplicative inverse exists for all  that are not congruent to zero modulo .\n\nSome of the more advanced properties of congruence relations are the following:\n* Fermat's little theorem: If  is prime, then  for \n* Euler's theorem: If  and  are coprime, then , where φ is Euler's totient function\n* A simple consequence of Fermat's little theorem is that if  is prime, then  is the multiplicative inverse of . More generally, from Euler's theorem, if  and  are coprime, then . \n* Another simple consequence is that if  where φ is Euler's totient function, then  provided  is coprime with \n* Wilson's theorem:  is prime if and only if  \n* Chinese remainder theorem: If  and  such that  and  are coprime, then  where  is the inverse of  modulo  and  is the inverse of  modulo \n* Lagrange's theorem: The congruence , where  is prime, and  is a polynomial with integer coefficients such that , has at most  roots.\n* Primitive root modulo n: A number  is a primitive root modulo  if, for every integer   coprime to , there is an integer  such that . A primitive root modulo  exists if and only if  is equal to  or , where  is an odd prime number. If a primitive root modulo  exists, then there are exactly  such primitive roots, where  is the Euler's totient function.\n* Quadratic residue:  An integer  is a quadratic residue modulo , if there exists an integer  such that . Euler's criterion asserts that, if  is an odd prime, then  is a quadratic residue modulo  if and only if \n:a^{\\frac{p-1}{2}} \\equiv 1 \\pmod p.\n\nCongruence classes \n\nLike any congruence relation, congruence modulo  is an equivalence relation, and the equivalence class of the integer , denoted by , is the set . This set, consisting of the integers congruent to  modulo , is called the congruence class or residue class or simply residue of the integer , modulo . When the modulus  is known from the context, that residue may also be denoted .\n\nResidue systems\n\nEach residue class modulo  may be represented by any one of its members, although we usually represent each residue class by the smallest nonnegative integer which belongs to that class (since this is the proper remainder which results from division).  Any two members of different residue classes modulo  are incongruent modulo .  Furthermore, every integer belongs to one and only one residue class modulo .\n\nThe set of integers  is called the least residue system modulo .  Any set of  integers, no two of which are congruent modulo , is called a complete residue system modulo .\n\nIt is clear that the least residue system is a complete residue system, and that a complete residue system is simply a set containing precisely one representative of each residue class modulo .  The least residue system modulo 4 is {0, 1, 2, 3}.  Some other complete residue systems modulo 4 are:\n\n*{1, 2, 3, 4}\n*{13, 14, 15, 16}\n*{−2, −1, 0, 1}\n*{−13, 4, 17, 18}\n*{−5, 0, 6, 21}\n*{27, 32, 37, 42}\n\nSome sets which are not complete residue systems modulo 4 are:\n\n*{−5, 0, 6, 22}  since 6 is congruent to 22 modulo 4.\n*{5, 15}  since a complete residue system modulo 4 must have exactly 4 incongruent residue classes. \n\nReduced residue systems\n\nAny set of  integers that are relatively prime to  and that are mutually incongruent modulo , where  denotes Euler's totient function, is called a reduced residue system modulo .  The example above, {5,15} is an example of a reduced residue system modulo 4.\n\nIntegers modulo n\n\nThe set of all congruence classes of the integers for a modulus  is called the ring of integers modulo ,It is a ring, as shown below. and is denoted \\mathbb{Z}/n\\mathbb{Z}, \\mathbb{Z}/n, or \\mathbb{Z}_n. The notation \\mathbb{Z}_n is, however, not recommended because it can be confused with the set of -adic integers. The set is defined as follows.\n\n\\mathbb{Z}/n\\mathbb{Z} = \\left\\{ \\overline{a}_n | a \\in \\mathbb{Z}\\right\\}. \n\nWhen , \\mathbb{Z}/n\\mathbb{Z} has  elements, and can be written as:\n\n\\mathbb{Z}/n\\mathbb{Z} = \\left\\{ \\overline{0}_n, \\overline{1}_n, \\overline{2}_n,\\ldots, \\overline{n-1}_n \\right\\}.\n\nWhen , \\mathbb{Z}/n\\mathbb{Z} does not have zero elements; rather, it is isomorphic to \\mathbb{Z}, since .\n\nWe can define addition, subtraction, and multiplication on \\mathbb{Z}/n\\mathbb{Z} by the following rules:\n\n* \\overline{a}_n + \\overline{b}_n = \\overline{(a + b)}_n\n* \\overline{a}_n - \\overline{b}_n = \\overline{(a - b)}_n\n* \\overline{a}_n \\overline{b}_n = \\overline{(ab)}_n.\n\nThe verification that this is a proper definition uses the properties given before.\n\nIn this way, \\mathbb{Z}/n\\mathbb{Z} becomes a commutative ring.  For example, in the ring \\mathbb{Z}/24\\mathbb{Z}, we have\n\\overline{12}_{24} + \\overline{21}_{24} = \\overline{9}_{24}\nas in the arithmetic for the 24-hour clock.\n\nThe notation \\mathbb{Z}/n\\mathbb{Z} is used, because it is the quotient ring of \\mathbb{Z} by the ideal n\\mathbb{Z} containing all integers divisible by , where 0\\mathbb{Z} is the singleton set . Thus \\mathbb{Z}/n\\mathbb{Z} is a field when n\\mathbb{Z} is a maximal ideal, that is, when  is prime.\n\nIn terms of groups, the residue class  is the coset of  in the quotient group \\mathbb{Z}/n\\mathbb{Z}, a cyclic group.Sengadir T., \n\nThe set \\mathbb{Z}/n\\mathbb{Z} has a number of important mathematical properties that are foundational to various branches of mathematics.\n\nRather than excluding the special case , it is more useful to include \\mathbb{Z}/0\\mathbb{Z} (which, as mentioned before, is isomorphic to the ring \\mathbb{Z} of integers), for example, when discussing the characteristic of a ring.\n\nThe ring of integers modulo  is a finite field if and only if  is prime (that is, if  is prime, every nonzero element of the ring has a multiplicative inverse). If  is a non-prime prime power, there exists a unique (up to isomorphism) finite field  with  elements, which must not be confused with the ring of integers modulo , although they have the same number of elements.\n\nApplications\n\nModular arithmetic is referenced in number theory, group theory, ring theory, knot theory, abstract algebra, computer algebra, cryptography, computer science, chemistry and the visual and musical arts.\n\nIt is one of the foundations of number theory, touching on almost every aspect of its study, and provides key examples for group theory, ring theory and abstract algebra.\n\nModular arithmetic is often used to calculate checksums that are used within identifiers. International Standard Book Number (ISBN) uses modulo 11 (if issued before 1 January, 2007) or modulo 10 (if issued on or after 1 January, 2007) arithmetic for error detection. Likewise, International Bank Account Numbers (IBANs), for example, make use of modulo 97 arithmetic to trap user input errors in bank account numbers. In chemistry, the last digit of the CAS registry number (a number which is unique for each chemical compound) is a check digit, which is calculated by taking the last digit of the first two parts of the CAS registry number times 1, the previous digit times 2, the previous digit times 3 etc., adding all these up and computing the sum modulo 10.\n\nIn cryptography, modular arithmetic directly underpins public key systems such as RSA and Diffie–Hellman, and provides finite fields which underlie elliptic curves, and is used in a variety of symmetric key algorithms including Advanced Encryption Standard (AES), International Data Encryption Algorithm (IDEA), and RC4. RSA and Diffie–Hellman use modular exponentiation.\n\nIn computer algebra, modular arithmetic is commonly used to limit the size of integer coefficients in intermediate calculations and data. It is used in polynomial factorization, a problem for which all known efficient algorithms use modular arithmetic. It is used by the most efficient implementations of polynomial greatest common divisor, exact linear algebra and Gröbner basis algorithms over the integers and the rational numbers.\n\nIn computer science, modular arithmetic is often applied in bitwise operations and other operations involving fixed-width, cyclic data structures. The modulo operation, as implemented in many programming languages and calculators, is an application of modular arithmetic that is often used in this context. XOR is the sum of 2 bits, modulo 2.\n\nIn music, arithmetic modulo 12 is used in the consideration of the system of twelve-tone equal temperament, where octave and enharmonic equivalency occurs (that is, pitches in a 1∶2 or 2∶1 ratio are equivalent, and C-sharp is considered the same as D-flat).\n\nThe method of casting out nines offers a quick check of decimal arithmetic computations performed by hand. It is based on modular arithmetic modulo 9, and specifically on the crucial property that 10 ≡ 1 (mod 9).\n\nArithmetic modulo 7 is used in algorithms that determine the day of the week for a given date. In particular, Zeller's congruence and the Doomsday algorithm make heavy use of modulo-7 arithmetic.\n\nMore generally, modular arithmetic also has application in disciplines such as law (see for example, apportionment), economics, (see for example, game theory) and other areas of the  social sciences, where proportional division and allocation of resources plays a central part of the analysis.\n\nComputational complexity\n\nSince modular arithmetic has such a wide range of applications, it is important to know how hard it is to solve a system of congruences. A linear system of congruences can be solved in polynomial time with a form of Gaussian elimination, for details see linear congruence theorem.  Algorithms, such as Montgomery reduction, also exist to allow simple arithmetic operations, such as multiplication and exponentiation modulo , to be performed efficiently on large numbers.\n\nSome operations, like finding a discrete logarithm or a quadratic congruence appear to be as hard as integer factorization and thus are a starting point for cryptographic algorithms and encryption. These problems might be NP-intermediate.\n\nSolving a system of non-linear modular arithmetic equations is NP-complete.\n\nExample implementations\n\nBelow are three reasonably fast C functions, two for performing modular multiplication and one for modular exponentiation on unsigned integers not larger than 63 bits, without overflow of the transient operations.\n\nAn algorithmic way to compute a \\cdot b \\pmod m:\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t m)\n{\n   uint64_t d 0, mp2 \n m >> 1;\n   int i;\n   if (a >m) a %\n m;\n   if (b >m) b %\n m;\n   for (i = 0; i  mp2) ? (d  m) d -= m;\n       a \n\nOn computer architectures where an extended precision format with at least 64 bits of mantissa is available (such as the long double type of most x86 C compilers), the following routine is faster than any algorithmic solution, by employing the trick that, by hardware, floating-point multiplication results in the most significant bits of the product kept, while integer multiplication results in the least significant bits kept:\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t m)\n{\n   long double x;\n   uint64_t c;\n   int64_t r;\n   if (a >m) a %\n m;\n   if (b >m) b %\n m;\n   x = a;\n   c = x * b / m;\n   r = (int64_t)(a * b - c * m) % (int64_t)m;\n   return r \n\nBelow is C functions for performing modular exponentiation, that uses  function implemented above.\n\nAn algorithmic way to compute a^b \\pmod m:\n\nuint64_t pow_mod(uint64_t a, uint64_t b, uint64_t m)\n{\n    uint64_t r = 1;\n    while (b > 0) {\n        if(b % 2 \n 1)\n            r = mul_mod(r, a, m);\n        b = b >> 1;\n        a = mul_mod(a, a, m);\n    }\n    return r;\n}\n\nHowever, for all above routines to work,  must not exceed 63 bits.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Modular arithmetic" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=20087" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In mathematics, modular arithmetic is a system of arithmetic for integers, where numbers \"wrap around\" upon reaching a certain value—the modulus (plural moduli).  The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801.\n\nA familiar use of modular arithmetic is in the 12-hour clock, in which the day is divided into two 12-hour periods. If the time is 7:00 now, then 8 hours later it will be 3:00. Usual addition would suggest that the later time should be , but this is not the answer because clock time \"wraps around\" every 12 hours. Because the hour number starts over after it reaches 12, this is arithmetic modulo 12. According to the definition below, 12 is congruent not only to 12 itself, but also to 0, so the time called \"12:00\" could also be called \"0:00\", since 12 is congruent to 0 modulo 12.\n\nDefinition of congruence relation\n\nModular arithmetic can be handled mathematically by introducing a congruence relation on the integers that is compatible with the operations on integers: addition, subtraction, and multiplication. For a positive integer , two numbers  and  are said to be ', if their difference  is an integer multiple of  (that is, if there is an integer  such that ). This congruence relation is typically considered when  and  are integers, and is denoted \na \\equiv b \\pmod n.\n(some authors use  instead of ; in this case, if the parentheses are omitted, this generally means that \"mod\" denotes the modulo operation, that is, that ).\n\nThe number  is called the ' of the congruence. \n\nThe congruence relation may be rewritten as\na = kn + b,\nexplicitly showing its relationship with Euclidean division. However,  need not be the remainder of the division of  by  More precisely, what the statement  asserts is that   and  have the same remainder when divided by . That is,\na = pn + r,\nb = qn + r,\nwhere  is the common remainder. Subtracting these two expressions, we recover the previous relation:\na - b = kn,\nby setting \n\nExamples\n\nFor example,\n\n38 \\equiv 14 \\pmod {12}\\,\n\nbecause , which is a multiple of 12, or, equivalently, because both 38 and 14 have the same remainder 2 when divided by 12.\n\nThe same rule holds for negative values:\n\n \\begin{align}\n-8 &\\equiv 7 \\pmod 5\\\\\n2 &\\equiv -3 \\pmod 5\\\\\n -3 &\\equiv -8 \\pmod 5.\n\\end{align}\n\nA remark on the notation: Because it is common to consider several congruence relations for different moduli at the same time, the modulus is incorporated in the notation. In spite of the ternary notation, the congruence relation for a given modulus is binary. This would have been clearer if the notation  had been used, instead of the common traditional notation.\n\nProperties \n\nThe congruence relation satisfies all the conditions of an equivalence relation:\n* Reflexivity:  \n* Symmetry:  if and only if \n* Transitivity: If  and , then \n\nIf  and  or if  then:\n*  for any integer  (compatibility with translation)\n*  for any integer  (compatibility with scaling)\n*  (compatibility with addition)\n*   (compatibility with subtraction)\n*   (compatibility with multiplication)\n*  for any non-negative integer  (compatibility with exponentiation)\n* , for any polynomial  with integer coefficients (compatibility with polynomial evaluation)\n\nIf , then it is false, in general, that . However, one has:\n* If  where φ is Euler's totient function, then  provided  is coprime with \n\nFor cancellation of common terms, we have the following rules:\n\n* If  for any integer , then \n* If  and  is coprime with , then \n\nThe modular multiplicative inverse is defined by the following rules:\n \n* Existence: there exists an integer denoted  such that  if and only if  is coprime with . This integer  is called a modular multiplicative inverse of  modulo .\n* If  and  exists, then  (compatibility with multiplicative inverse, and, if , uniqueness modulo )\n* If  and  is coprime to , the solution to this linear congruence is given by  \n\nIn particular, if  is a prime number then  is coprime with  for every  such that . Thus, a multiplicative inverse exists for all  that are not congruent to zero modulo .\n\nSome of the more advanced properties of congruence relations are the following:\n* Fermat's little theorem: If  is prime, then  for \n* Euler's theorem: If  and  are coprime, then , where φ is Euler's totient function\n* A simple consequence of Fermat's little theorem is that if  is prime, then  is the multiplicative inverse of . More generally, from Euler's theorem, if  and  are coprime, then . \n* Another simple consequence is that if  where φ is Euler's totient function, then  provided  is coprime with \n* Wilson's theorem:  is prime if and only if  \n* Chinese remainder theorem: If  and  such that  and  are coprime, then  where  is the inverse of  modulo  and  is the inverse of  modulo \n* Lagrange's theorem: The congruence , where  is prime, and  is a polynomial with integer coefficients such that , has at most  roots.\n* Primitive root modulo n: A number  is a primitive root modulo  if, for every integer   coprime to , there is an integer  such that . A primitive root modulo  exists if and only if  is equal to  or , where  is an odd prime number. If a primitive root modulo  exists, then there are exactly  such primitive roots, where  is the Euler's totient function.\n* Quadratic residue:  An integer  is a quadratic residue modulo , if there exists an integer  such that . Euler's criterion asserts that, if  is an odd prime, then  is a quadratic residue modulo  if and only if \n:a^{\\frac{p-1}{2}} \\equiv 1 \\pmod p.\n\nCongruence classes \n\nLike any congruence relation, congruence modulo  is an equivalence relation, and the equivalence class of the integer , denoted by , is the set . This set, consisting of the integers congruent to  modulo , is called the congruence class or residue class or simply residue of the integer , modulo . When the modulus  is known from the context, that residue may also be denoted .\n\nResidue systems\n\nEach residue class modulo  may be represented by any one of its members, although we usually represent each residue class by the smallest nonnegative integer which belongs to that class (since this is the proper remainder which results from division).  Any two members of different residue classes modulo  are incongruent modulo .  Furthermore, every integer belongs to one and only one residue class modulo .\n\nThe set of integers  is called the least residue system modulo .  Any set of  integers, no two of which are congruent modulo , is called a complete residue system modulo .\n\nIt is clear that the least residue system is a complete residue system, and that a complete residue system is simply a set containing precisely one representative of each residue class modulo .  The least residue system modulo 4 is {0, 1, 2, 3}.  Some other complete residue systems modulo 4 are:\n\n*{1, 2, 3, 4}\n*{13, 14, 15, 16}\n*{−2, −1, 0, 1}\n*{−13, 4, 17, 18}\n*{−5, 0, 6, 21}\n*{27, 32, 37, 42}\n\nSome sets which are not complete residue systems modulo 4 are:\n\n*{−5, 0, 6, 22}  since 6 is congruent to 22 modulo 4.\n*{5, 15}  since a complete residue system modulo 4 must have exactly 4 incongruent residue classes. \n\nReduced residue systems\n\nAny set of  integers that are relatively prime to  and that are mutually incongruent modulo , where  denotes Euler's totient function, is called a reduced residue system modulo .  The example above, {5,15} is an example of a reduced residue system modulo 4.\n\nIntegers modulo n\n\nThe set of all congruence classes of the integers for a modulus  is called the ring of integers modulo ,It is a ring, as shown below. and is denoted \\mathbb{Z}/n\\mathbb{Z}, \\mathbb{Z}/n, or \\mathbb{Z}_n. The notation \\mathbb{Z}_n is, however, not recommended because it can be confused with the set of -adic integers. The set is defined as follows.\n\n\\mathbb{Z}/n\\mathbb{Z} = \\left\\{ \\overline{a}_n | a \\in \\mathbb{Z}\\right\\}. \n\nWhen , \\mathbb{Z}/n\\mathbb{Z} has  elements, and can be written as:\n\n\\mathbb{Z}/n\\mathbb{Z} = \\left\\{ \\overline{0}_n, \\overline{1}_n, \\overline{2}_n,\\ldots, \\overline{n-1}_n \\right\\}.\n\nWhen , \\mathbb{Z}/n\\mathbb{Z} does not have zero elements; rather, it is isomorphic to \\mathbb{Z}, since .\n\nWe can define addition, subtraction, and multiplication on \\mathbb{Z}/n\\mathbb{Z} by the following rules:\n\n* \\overline{a}_n + \\overline{b}_n = \\overline{(a + b)}_n\n* \\overline{a}_n - \\overline{b}_n = \\overline{(a - b)}_n\n* \\overline{a}_n \\overline{b}_n = \\overline{(ab)}_n.\n\nThe verification that this is a proper definition uses the properties given before.\n\nIn this way, \\mathbb{Z}/n\\mathbb{Z} becomes a commutative ring.  For example, in the ring \\mathbb{Z}/24\\mathbb{Z}, we have\n\\overline{12}_{24} + \\overline{21}_{24} = \\overline{9}_{24}\nas in the arithmetic for the 24-hour clock.\n\nThe notation \\mathbb{Z}/n\\mathbb{Z} is used, because it is the quotient ring of \\mathbb{Z} by the ideal n\\mathbb{Z} containing all integers divisible by , where 0\\mathbb{Z} is the singleton set . Thus \\mathbb{Z}/n\\mathbb{Z} is a field when n\\mathbb{Z} is a maximal ideal, that is, when  is prime.\n\nIn terms of groups, the residue class  is the coset of  in the quotient group \\mathbb{Z}/n\\mathbb{Z}, a cyclic group.Sengadir T., \n\nThe set \\mathbb{Z}/n\\mathbb{Z} has a number of important mathematical properties that are foundational to various branches of mathematics.\n\nRather than excluding the special case , it is more useful to include \\mathbb{Z}/0\\mathbb{Z} (which, as mentioned before, is isomorphic to the ring \\mathbb{Z} of integers), for example, when discussing the characteristic of a ring.\n\nThe ring of integers modulo  is a finite field if and only if  is prime (that is, if  is prime, every nonzero element of the ring has a multiplicative inverse). If  is a non-prime prime power, there exists a unique (up to isomorphism) finite field  with  elements, which must not be confused with the ring of integers modulo , although they have the same number of elements.\n\nApplications\n\nModular arithmetic is referenced in number theory, group theory, ring theory, knot theory, abstract algebra, computer algebra, cryptography, computer science, chemistry and the visual and musical arts.\n\nIt is one of the foundations of number theory, touching on almost every aspect of its study, and provides key examples for group theory, ring theory and abstract algebra.\n\nModular arithmetic is often used to calculate checksums that are used within identifiers. International Standard Book Number (ISBN) uses modulo 11 (if issued before 1 January, 2007) or modulo 10 (if issued on or after 1 January, 2007) arithmetic for error detection. Likewise, International Bank Account Numbers (IBANs), for example, make use of modulo 97 arithmetic to trap user input errors in bank account numbers. In chemistry, the last digit of the CAS registry number (a number which is unique for each chemical compound) is a check digit, which is calculated by taking the last digit of the first two parts of the CAS registry number times 1, the previous digit times 2, the previous digit times 3 etc., adding all these up and computing the sum modulo 10.\n\nIn cryptography, modular arithmetic directly underpins public key systems such as RSA and Diffie–Hellman, and provides finite fields which underlie elliptic curves, and is used in a variety of symmetric key algorithms including Advanced Encryption Standard (AES), International Data Encryption Algorithm (IDEA), and RC4. RSA and Diffie–Hellman use modular exponentiation.\n\nIn computer algebra, modular arithmetic is commonly used to limit the size of integer coefficients in intermediate calculations and data. It is used in polynomial factorization, a problem for which all known efficient algorithms use modular arithmetic. It is used by the most efficient implementations of polynomial greatest common divisor, exact linear algebra and Gröbner basis algorithms over the integers and the rational numbers.\n\nIn computer science, modular arithmetic is often applied in bitwise operations and other operations involving fixed-width, cyclic data structures. The modulo operation, as implemented in many programming languages and calculators, is an application of modular arithmetic that is often used in this context. XOR is the sum of 2 bits, modulo 2.\n\nIn music, arithmetic modulo 12 is used in the consideration of the system of twelve-tone equal temperament, where octave and enharmonic equivalency occurs (that is, pitches in a 1∶2 or 2∶1 ratio are equivalent, and C-sharp is considered the same as D-flat).\n\nThe method of casting out nines offers a quick check of decimal arithmetic computations performed by hand. It is based on modular arithmetic modulo 9, and specifically on the crucial property that 10 ≡ 1 (mod 9).\n\nArithmetic modulo 7 is used in algorithms that determine the day of the week for a given date. In particular, Zeller's congruence and the Doomsday algorithm make heavy use of modulo-7 arithmetic.\n\nMore generally, modular arithmetic also has application in disciplines such as law (see for example, apportionment), economics, (see for example, game theory) and other areas of the  social sciences, where proportional division and allocation of resources plays a central part of the analysis.\n\nComputational complexity\n\nSince modular arithmetic has such a wide range of applications, it is important to know how hard it is to solve a system of congruences. A linear system of congruences can be solved in polynomial time with a form of Gaussian elimination, for details see linear congruence theorem.  Algorithms, such as Montgomery reduction, also exist to allow simple arithmetic operations, such as multiplication and exponentiation modulo , to be performed efficiently on large numbers.\n\nSome operations, like finding a discrete logarithm or a quadratic congruence appear to be as hard as integer factorization and thus are a starting point for cryptographic algorithms and encryption. These problems might be NP-intermediate.\n\nSolving a system of non-linear modular arithmetic equations is NP-complete.\n\nExample implementations\n\nBelow are three reasonably fast C functions, two for performing modular multiplication and one for modular exponentiation on unsigned integers not larger than 63 bits, without overflow of the transient operations.\n\nAn algorithmic way to compute a \\cdot b \\pmod m:\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t m)\n{\n   uint64_t d 0, mp2 \n m >> 1;\n   int i;\n   if (a >m) a %\n m;\n   if (b >m) b %\n m;\n   for (i = 0; i  mp2) ? (d  m) d -= m;\n       a \n\nOn computer architectures where an extended precision format with at least 64 bits of mantissa is available (such as the long double type of most x86 C compilers), the following routine is faster than any algorithmic solution, by employing the trick that, by hardware, floating-point multiplication results in the most significant bits of the product kept, while integer multiplication results in the least significant bits kept:\n\nuint64_t mul_mod(uint64_t a, uint64_t b, uint64_t m)\n{\n   long double x;\n   uint64_t c;\n   int64_t r;\n   if (a >m) a %\n m;\n   if (b >m) b %\n m;\n   x = a;\n   c = x * b / m;\n   r = (int64_t)(a * b - c * m) % (int64_t)m;\n   return r \n\nBelow is C functions for performing modular exponentiation, that uses  function implemented above.\n\nAn algorithmic way to compute a^b \\pmod m:\n\nuint64_t pow_mod(uint64_t a, uint64_t b, uint64_t m)\n{\n    uint64_t r = 1;\n    while (b > 0) {\n        if(b % 2 \n 1)\n            r = mul_mod(r, a, m);\n        b = b >> 1;\n        a = mul_mod(a, a, m);\n    }\n    return r;\n}\n\nHowever, for all above routines to work,  must not exceed 63 bits. Modular arithmetic. http://en.wikipedia.org/?curid=20087."
  }
}
