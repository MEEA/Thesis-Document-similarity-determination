{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=16947",
  "eid" : "29c9afa0-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778579354,
  "textBody" : "Kerberos is a computer network authentication protocol that works on the basis of tickets to allow nodes communicating over a non-secure network to prove their identity to one another in a secure manner.   The protocol was named after the character Kerberos (or Cerberus) from  Greek mythology, the ferocious three-headed guard dog of Hades. Its designers aimed it primarily at a client–server model and it provides mutual authentication—both the user and the server verify each other's identity. Kerberos protocol messages are protected against eavesdropping and replay attacks.\n\nKerberos builds on symmetric key cryptography and requires a trusted third party, and optionally may use public-key cryptography during certain phases of authentication.RFC 4556, abstract Kerberos uses UDP port 88 by default.\n\nHistory and development\n\nMassachusetts Institute of Technology (MIT) developed Kerberos to protect network services provided by Project Athena.  The protocol is based on the earlier Needham–Schroeder symmetric key protocol. Several versions of the protocol exist; versions 1–3 occurred only internally at MIT.\n\nKerberos version 4 was primarily designed by Steve Miller and Clifford Neuman.  Published in the late 1980s, version 4 was also targeted at Project Athena.  \n\nNeuman and Kohl published version 5 in 1993 with the intention of overcoming existing limitations and security problems.  Version 5 appeared as RFC 1510, and was made obsolete by RFC 4120 in 2005. \n\nAuthorities in the United States classified Kerberos as \"Auxiliary Military Equipment\" on the US Munitions List and banned its export because it used the Data Encryption Standard (DES) encryption algorithm (with 56-bit keys). A non-US Kerberos 4 implementation, KTH-KRB developed at the Royal Institute of Technology in Sweden, made the system available outside the US before the US changed its cryptography export regulations (circa 2000). The Swedish implementation was based on a limited version called eBones. eBones was based on the exported MIT Bones release (stripped of both the encryption functions and the calls to them) based on version Kerberos 4 patch-level 9.\n\nIn 2005, the Internet Engineering Task Force (IETF) Kerberos working group updated specifications. Updates included:\n* Encryption and Checksum Specifications (RFC 3961).\n* Advanced Encryption Standard (AES) Encryption for Kerberos 5 (RFC 3962).\n* A new edition of the Kerberos V5 specification \"The Kerberos Network Authentication Service (V5)\" (RFC 4120). This version obsoletes RFC 1510, clarifies aspects of the protocol and intended use in a more detailed and clearer explanation.\n* A new edition of the Generic Security Services Application Program Interface (GSS-API) specification \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2.\" (RFC 4121).\n\nMIT makes an implementation of Kerberos freely available, under copyright permissions similar to those used for BSD. In 2007, MIT formed the Kerberos Consortium to foster continued development. Founding sponsors include vendors such as Oracle, Apple Inc., Google, Microsoft, Centrify Corporation and TeamF1 Inc., and academic institutions such as the Royal Institute of Technology in Sweden, Stanford University, MIT, and vendors such as CyberSafe offering commercially supported versions.\n\nMicrosoft Windows\n\nWindows 2000 and later uses Kerberos as its default authentication method.  Some Microsoft additions to the Kerberos suite of protocols are documented in RFC 3244 \"Microsoft Windows 2000 Kerberos Change Password and Set Password Protocols\". RFC 4757 documents Microsoft's use of the RC4 cipher.  While Microsoft uses the Kerberos protocol, it does not use the MIT software.\n\nKerberos is used as preferred authentication method:\nIn general, joining a client to a Windows domain means enabling Kerberos as default protocol for authentications from that client to services in the Windows domain and all domains with trust relationships to that domain. \n\nIn contrast, when either client or server or both are not joined to a domain (or not part of the same trusted domain environment), Windows will instead use NTLM for authentication between client and server. \n\nIntranet web applications can enforce Kerberos as an authentication method for domain joined clients by using APIs provided under SSPI.\n\nUNIX and Unix-like operating systems\n\nMany UNIX and UNIX-like operating systems, including FreeBSD, Apple's Mac OS X, Red Hat Enterprise Linux, Oracle's Solaris, IBM's AIX and Z/OS, HP's HP-UX and OpenVMS and others, include software for Kerberos authentication of users or services. Embedded implementation of the Kerberos V authentication protocol for client agents and network services running on embedded platforms is also available from companies.\n\nProtocol\n\nDescription\n\nThe client authenticates itself to the Authentication Server (AS) which forwards the username to a key distribution center (KDC). The KDC issues a ticket-granting ticket (TGT), which is time stamped and encrypts it using the ticket-granting service's (TGS) secret key and returns the encrypted result to the user's workstation.  This is done infrequently, typically at user logon; the TGT expires at some point although it may be transparently renewed by the user's session manager while they are logged in.\n\nWhen the client needs to communicate with another node (\"principal\" in Kerberos parlance) to some service on that node the client sends the TGT to the TGS, which usually shares the same host as the KDC. Service must be registered at TGT with a Service Principal Name (SPN). The client uses the SPN to request access to this service. After verifying that the TGT is valid and that the user is permitted to access the requested service, the TGS issues ticket and session keys to the client. The client then sends the ticket to the service server (SS) along with its service request.\n\nThe protocol is described in detail below.\n\nUser Client-based Logon\n\n# A user enters a username and password on the client machine(s).  Other credential mechanisms like pkinit (RFC 4556) allow for the use of public keys in place of a password.\n# The client transforms the password into the key of a symmetric cipher.  This either uses the built-in key scheduling, or a one-way hash, depending on the cipher-suite used.\n\nClient Authentication\n\n# The client sends a cleartext message of the user ID to the AS (Authentication Server) requesting services on behalf of the user. (Note: Neither the secret key nor the password is sent to the AS.)\n# The AS checks to see if the client is in its database. If it is, the AS generates the secret key by hashing the password of the user found at the database (e.g., Active Directory in Windows Server) and sends back the following two messages to the client:\n#* Message A: Client/TGS Session Key encrypted using the secret key of the client/user.\n#* Message B: Ticket-Granting-Ticket (TGT, which includes the client ID, client network address, ticket validity period, and the client/TGS session key) encrypted using the secret key of the TGS.\n# Once the client receives messages A and B, it attempts to decrypt message A with the secret key generated from the password entered by the user.  If the user entered password does not match the password in the AS database, the client's secret key will be different and thus unable to decrypt message A.  With a valid password and secret key the client decrypts message A to obtain the Client/TGS Session Key. This session key is used for further communications with the TGS. (Note: The client cannot decrypt Message B, as it is encrypted using TGS's secret key.)  At this point, the client has enough information to authenticate itself to the TGS.\n\nClient Service Authorization\n\n# When requesting services, the client sends the following messages to the TGS:\n#* Message C: Composed of the TGT from message B and the ID of the requested service.\n#* Message D: Authenticator (which is composed of the client ID and the timestamp), encrypted using the Client/TGS Session Key.\n# Upon receiving messages C and D, the TGS retrieves message B out of message C. It decrypts message B using the TGS secret key. This gives it the \"client/TGS session key\". Using this key, the TGS decrypts message D (Authenticator) and compare client ID from message C and D, if they match server sends the following two messages to the client:\n#* Message E: Client-to-server ticket (which includes the client ID, client network address, validity period and Client/Server Session Key) encrypted using the service's secret key.\n#* Message F: Client/Server Session Key encrypted with the Client/TGS Session Key.\n\nClient Service Request\n\n# Upon receiving messages E and F from TGS, the client has enough information to authenticate itself to the Service Server (SS).  The client connects to the SS and sends the following two messages:\n#* Message E from the previous step (the client-to-server ticket, encrypted using service's secret key).\n#* Message G: a new Authenticator, which includes the client ID, timestamp and is encrypted using Client/Server Session Key.\n# The SS decrypts the ticket (message E) using its own secret key to retrieve the Client/Server Session Key. Using the sessions key, SS decrypts the Authenticator and compare client ID from message E and G, if they match server sends the following message to the client to confirm its true identity and willingness to serve the client:\n#* Message H: the timestamp found in client's Authenticator (plus 1 in version 4, but not necessary in version 5), encrypted using the Client/Server Session Key.\n# The client decrypts the confirmation (message H) using the Client/Server Session Key and checks whether the timestamp is correct. If so, then the client can trust the server and can start issuing service requests to the server.\n# The server provides the requested services to the client.\n\nDrawbacks and limitations\n\n* Single point of failure: It requires continuous availability of a central server. When the Kerberos server is down, new users cannot log in. This can be mitigated by using multiple Kerberos servers and fallback authentication mechanisms.\n* Kerberos has strict time requirements, which means the clocks of the involved hosts must be synchronized within configured limits. The tickets have a time availability period and if the host clock is not synchronized with the Kerberos server clock, the authentication will fail. The default configuration [http://web.mit.edu/Kerberos/krb5-1.5/krb5-1.5.4/doc/krb5-admin/Clock-Skew.html per MIT] requires that clock times be no more than five minutes apart.  In practice Network Time Protocol daemons are usually used to keep the host clocks synchronized. Note that some servers (Microsoft's implementation being one of them) may return a KRB_AP_ERR_SKEW result containing the encrypted server time in case both clocks have an offset greater than the configured maximum value. In that case, the client could retry by calculating the time using the provided server time to find the offset. This behavior is documented in RFC 4430.\n* The administration protocol is not standardized and differs between server implementations.  Password changes are described in RFC 3244.\n* In case of symmetric cryptography adoption (Kerberos can work using symmetric or asymmetric (public-key) cryptography), since all authentications are controlled by a centralized key distribution center (KDC), compromise of this authentication infrastructure will allow an attacker to impersonate any user.\n* Each network service which requires a different host name will need its own set of Kerberos keys. This complicates virtual hosting and clusters.\n* Kerberos requires user accounts, user clients and the services on the server to all have a trusted relationship to the Kerberos token server (All must be in the same Kerberos domain or in domains that have a trust relationship between each other). Kerberos cannot be used in scenarios where users want to connect to services from unknown/untrusted clients as in a typical Internet or cloud computer scenario, where the authentication provider typically does not have knowledge about the users client system.\n* The required client trust makes creating staged environments (e.g., separate domains for test environment, pre-production environment and production environment) difficult: Either domain trust relationships need to be created that prevent a strict separation of environment domains or additional user clients need to be provided for each environment.\n\nVulnerabilities\n\nThe Data Encryption Standard (DES) cipher can be used in combination with Kerberos, but is no longer an Internet standard because it is weak.  Security vulnerabilities exist in many legacy products that implement Kerberos because they have not been updated to use newer ciphers like AES instead of DES.\n\nIn November 2014, Microsoft released a patch (MS14-068) to rectify an exploitable vulnerability in Windows implementation of the Kerberos Key Distribution Center (KDC). The vulnerability purportedly allows users to \"elevate\" (and abuse) their privileges, up to Domain level.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Kerberos (protocol)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=16947" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Kerberos is a computer network authentication protocol that works on the basis of tickets to allow nodes communicating over a non-secure network to prove their identity to one another in a secure manner.   The protocol was named after the character Kerberos (or Cerberus) from  Greek mythology, the ferocious three-headed guard dog of Hades. Its designers aimed it primarily at a client–server model and it provides mutual authentication—both the user and the server verify each other's identity. Kerberos protocol messages are protected against eavesdropping and replay attacks.\n\nKerberos builds on symmetric key cryptography and requires a trusted third party, and optionally may use public-key cryptography during certain phases of authentication.RFC 4556, abstract Kerberos uses UDP port 88 by default.\n\nHistory and development\n\nMassachusetts Institute of Technology (MIT) developed Kerberos to protect network services provided by Project Athena.  The protocol is based on the earlier Needham–Schroeder symmetric key protocol. Several versions of the protocol exist; versions 1–3 occurred only internally at MIT.\n\nKerberos version 4 was primarily designed by Steve Miller and Clifford Neuman.  Published in the late 1980s, version 4 was also targeted at Project Athena.  \n\nNeuman and Kohl published version 5 in 1993 with the intention of overcoming existing limitations and security problems.  Version 5 appeared as RFC 1510, and was made obsolete by RFC 4120 in 2005. \n\nAuthorities in the United States classified Kerberos as \"Auxiliary Military Equipment\" on the US Munitions List and banned its export because it used the Data Encryption Standard (DES) encryption algorithm (with 56-bit keys). A non-US Kerberos 4 implementation, KTH-KRB developed at the Royal Institute of Technology in Sweden, made the system available outside the US before the US changed its cryptography export regulations (circa 2000). The Swedish implementation was based on a limited version called eBones. eBones was based on the exported MIT Bones release (stripped of both the encryption functions and the calls to them) based on version Kerberos 4 patch-level 9.\n\nIn 2005, the Internet Engineering Task Force (IETF) Kerberos working group updated specifications. Updates included:\n* Encryption and Checksum Specifications (RFC 3961).\n* Advanced Encryption Standard (AES) Encryption for Kerberos 5 (RFC 3962).\n* A new edition of the Kerberos V5 specification \"The Kerberos Network Authentication Service (V5)\" (RFC 4120). This version obsoletes RFC 1510, clarifies aspects of the protocol and intended use in a more detailed and clearer explanation.\n* A new edition of the Generic Security Services Application Program Interface (GSS-API) specification \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2.\" (RFC 4121).\n\nMIT makes an implementation of Kerberos freely available, under copyright permissions similar to those used for BSD. In 2007, MIT formed the Kerberos Consortium to foster continued development. Founding sponsors include vendors such as Oracle, Apple Inc., Google, Microsoft, Centrify Corporation and TeamF1 Inc., and academic institutions such as the Royal Institute of Technology in Sweden, Stanford University, MIT, and vendors such as CyberSafe offering commercially supported versions.\n\nMicrosoft Windows\n\nWindows 2000 and later uses Kerberos as its default authentication method.  Some Microsoft additions to the Kerberos suite of protocols are documented in RFC 3244 \"Microsoft Windows 2000 Kerberos Change Password and Set Password Protocols\". RFC 4757 documents Microsoft's use of the RC4 cipher.  While Microsoft uses the Kerberos protocol, it does not use the MIT software.\n\nKerberos is used as preferred authentication method:\nIn general, joining a client to a Windows domain means enabling Kerberos as default protocol for authentications from that client to services in the Windows domain and all domains with trust relationships to that domain. \n\nIn contrast, when either client or server or both are not joined to a domain (or not part of the same trusted domain environment), Windows will instead use NTLM for authentication between client and server. \n\nIntranet web applications can enforce Kerberos as an authentication method for domain joined clients by using APIs provided under SSPI.\n\nUNIX and Unix-like operating systems\n\nMany UNIX and UNIX-like operating systems, including FreeBSD, Apple's Mac OS X, Red Hat Enterprise Linux, Oracle's Solaris, IBM's AIX and Z/OS, HP's HP-UX and OpenVMS and others, include software for Kerberos authentication of users or services. Embedded implementation of the Kerberos V authentication protocol for client agents and network services running on embedded platforms is also available from companies.\n\nProtocol\n\nDescription\n\nThe client authenticates itself to the Authentication Server (AS) which forwards the username to a key distribution center (KDC). The KDC issues a ticket-granting ticket (TGT), which is time stamped and encrypts it using the ticket-granting service's (TGS) secret key and returns the encrypted result to the user's workstation.  This is done infrequently, typically at user logon; the TGT expires at some point although it may be transparently renewed by the user's session manager while they are logged in.\n\nWhen the client needs to communicate with another node (\"principal\" in Kerberos parlance) to some service on that node the client sends the TGT to the TGS, which usually shares the same host as the KDC. Service must be registered at TGT with a Service Principal Name (SPN). The client uses the SPN to request access to this service. After verifying that the TGT is valid and that the user is permitted to access the requested service, the TGS issues ticket and session keys to the client. The client then sends the ticket to the service server (SS) along with its service request.\n\nThe protocol is described in detail below.\n\nUser Client-based Logon\n\n# A user enters a username and password on the client machine(s).  Other credential mechanisms like pkinit (RFC 4556) allow for the use of public keys in place of a password.\n# The client transforms the password into the key of a symmetric cipher.  This either uses the built-in key scheduling, or a one-way hash, depending on the cipher-suite used.\n\nClient Authentication\n\n# The client sends a cleartext message of the user ID to the AS (Authentication Server) requesting services on behalf of the user. (Note: Neither the secret key nor the password is sent to the AS.)\n# The AS checks to see if the client is in its database. If it is, the AS generates the secret key by hashing the password of the user found at the database (e.g., Active Directory in Windows Server) and sends back the following two messages to the client:\n#* Message A: Client/TGS Session Key encrypted using the secret key of the client/user.\n#* Message B: Ticket-Granting-Ticket (TGT, which includes the client ID, client network address, ticket validity period, and the client/TGS session key) encrypted using the secret key of the TGS.\n# Once the client receives messages A and B, it attempts to decrypt message A with the secret key generated from the password entered by the user.  If the user entered password does not match the password in the AS database, the client's secret key will be different and thus unable to decrypt message A.  With a valid password and secret key the client decrypts message A to obtain the Client/TGS Session Key. This session key is used for further communications with the TGS. (Note: The client cannot decrypt Message B, as it is encrypted using TGS's secret key.)  At this point, the client has enough information to authenticate itself to the TGS.\n\nClient Service Authorization\n\n# When requesting services, the client sends the following messages to the TGS:\n#* Message C: Composed of the TGT from message B and the ID of the requested service.\n#* Message D: Authenticator (which is composed of the client ID and the timestamp), encrypted using the Client/TGS Session Key.\n# Upon receiving messages C and D, the TGS retrieves message B out of message C. It decrypts message B using the TGS secret key. This gives it the \"client/TGS session key\". Using this key, the TGS decrypts message D (Authenticator) and compare client ID from message C and D, if they match server sends the following two messages to the client:\n#* Message E: Client-to-server ticket (which includes the client ID, client network address, validity period and Client/Server Session Key) encrypted using the service's secret key.\n#* Message F: Client/Server Session Key encrypted with the Client/TGS Session Key.\n\nClient Service Request\n\n# Upon receiving messages E and F from TGS, the client has enough information to authenticate itself to the Service Server (SS).  The client connects to the SS and sends the following two messages:\n#* Message E from the previous step (the client-to-server ticket, encrypted using service's secret key).\n#* Message G: a new Authenticator, which includes the client ID, timestamp and is encrypted using Client/Server Session Key.\n# The SS decrypts the ticket (message E) using its own secret key to retrieve the Client/Server Session Key. Using the sessions key, SS decrypts the Authenticator and compare client ID from message E and G, if they match server sends the following message to the client to confirm its true identity and willingness to serve the client:\n#* Message H: the timestamp found in client's Authenticator (plus 1 in version 4, but not necessary in version 5), encrypted using the Client/Server Session Key.\n# The client decrypts the confirmation (message H) using the Client/Server Session Key and checks whether the timestamp is correct. If so, then the client can trust the server and can start issuing service requests to the server.\n# The server provides the requested services to the client.\n\nDrawbacks and limitations\n\n* Single point of failure: It requires continuous availability of a central server. When the Kerberos server is down, new users cannot log in. This can be mitigated by using multiple Kerberos servers and fallback authentication mechanisms.\n* Kerberos has strict time requirements, which means the clocks of the involved hosts must be synchronized within configured limits. The tickets have a time availability period and if the host clock is not synchronized with the Kerberos server clock, the authentication will fail. The default configuration [http://web.mit.edu/Kerberos/krb5-1.5/krb5-1.5.4/doc/krb5-admin/Clock-Skew.html per MIT] requires that clock times be no more than five minutes apart.  In practice Network Time Protocol daemons are usually used to keep the host clocks synchronized. Note that some servers (Microsoft's implementation being one of them) may return a KRB_AP_ERR_SKEW result containing the encrypted server time in case both clocks have an offset greater than the configured maximum value. In that case, the client could retry by calculating the time using the provided server time to find the offset. This behavior is documented in RFC 4430.\n* The administration protocol is not standardized and differs between server implementations.  Password changes are described in RFC 3244.\n* In case of symmetric cryptography adoption (Kerberos can work using symmetric or asymmetric (public-key) cryptography), since all authentications are controlled by a centralized key distribution center (KDC), compromise of this authentication infrastructure will allow an attacker to impersonate any user.\n* Each network service which requires a different host name will need its own set of Kerberos keys. This complicates virtual hosting and clusters.\n* Kerberos requires user accounts, user clients and the services on the server to all have a trusted relationship to the Kerberos token server (All must be in the same Kerberos domain or in domains that have a trust relationship between each other). Kerberos cannot be used in scenarios where users want to connect to services from unknown/untrusted clients as in a typical Internet or cloud computer scenario, where the authentication provider typically does not have knowledge about the users client system.\n* The required client trust makes creating staged environments (e.g., separate domains for test environment, pre-production environment and production environment) difficult: Either domain trust relationships need to be created that prevent a strict separation of environment domains or additional user clients need to be provided for each environment.\n\nVulnerabilities\n\nThe Data Encryption Standard (DES) cipher can be used in combination with Kerberos, but is no longer an Internet standard because it is weak.  Security vulnerabilities exist in many legacy products that implement Kerberos because they have not been updated to use newer ciphers like AES instead of DES.\n\nIn November 2014, Microsoft released a patch (MS14-068) to rectify an exploitable vulnerability in Windows implementation of the Kerberos Key Distribution Center (KDC). The vulnerability purportedly allows users to \"elevate\" (and abuse) their privileges, up to Domain level. Kerberos (protocol). http://en.wikipedia.org/?curid=16947."
  }
}
