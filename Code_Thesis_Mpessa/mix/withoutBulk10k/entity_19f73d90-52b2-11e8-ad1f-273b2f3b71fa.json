{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=15089",
  "eid" : "19f73d90-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778552809,
  "textBody" : "An interpreted language is a type of programming language for which most of its implementations execute instructions directly and freely, without previously compiling a program into machine-language instructions. The interpreter executes the program directly, translating each statement into a sequence of one or more subroutines already compiled into machine code.\n\nThe terms interpreted language and compiled language are not well defined because, in theory, any programming language can be either interpreted or compiled. In modern programming language implementation it is increasingly popular for a platform to provide both options.\n\nInterpreted languages can also be contrasted with machine languages. Functionally, both execution and interpretation mean the same thing — fetching the next instruction/statement from the program and executing it. Although interpreted byte code is additionally identical to machine code in form and has an assembler representation, the term \"interpreted\" is practically reserved for \"software processed\" languages (by virtual machine or emulator) on top of the native (i.e. hardware) processor.\n\nIn principle, programs in many languages may be compiled or interpreted, emulated or executed natively, so this designation is applied solely based on common implementation practice, rather than representing an essential property of a language.\n\nMany languages have been implemented using both compilers and interpreters, including BASIC, C, Lisp, Pascal, and Python. Java and C# are compiled into bytecode, the virtual machine-friendly interpreted language. Lisp implementations can freely mix interpreted and compiled code.\n\nHistorical background\n\nIn the early days of computing, language design was heavily influenced by the decision to use compiling or interpreting as a mode of execution. For example, Smalltalk (1980), which was designed to be interpreted at run-time, allows generic objects to dynamically interact with each other.\n\nInitially, interpreted languages were compiled line-by-line; that is, each line was compiled as it was about to be executed, and if a loop or subroutine caused certain lines to be executed multiple times, they would be recompiled every time. This has become much less common. Most so-called interpreted languages use an intermediate representation, which combines compiling and interpreting.\n\nExamples include: \n* JavaScript\n* Python\n* Ruby (similarly, it uses an abstract syntax tree as intermediate representation)\n* Forth\n\nThe intermediate representation can be compiled once and for all (as in Java), each time before execution (as in Perl or Ruby), or each time a change in the source is detected before execution (as in Python).\n\nAdvantages\n\nInterpreting a language gives implementations some additional flexibility over compiled implementations.  Features that are often easier to implement in interpreters than in compilers include:\n* platform independence (Java's byte code, for example)\n* reflection and reflective use of the evaluator (e.g. a first-order eval function)\n* dynamic typing\n* smaller executable program size (since implementations have flexibility to choose the instruction code)\n* dynamic scoping\n\nFurthermore, source code can be read and copied, giving users more freedom.\n\nDisadvantages\n\nDisadvantages of interpreted languages are:\n* Without static type-checking, which is usually performed by a compiler, programs can be less reliable, because type checking eliminates a class of programming errors.\n* Interpreters can be susceptible to Code injection attacks.\n* Slower execution compared to direct native machine code execution on the host CPU. A technique used to improve performance is just-in-time compilation which converts frequently executed sequences of interpreted instruction to host machine code. JIT is most often combined with compilation to byte-code as in Java.\n* Source code can be read and copied (e.g. JavaScript in web pages), or more easily reverse engineered through reflection in applications where intellectual property has a commercial advantage. In some cases, obfuscation is used as a partial defense against this.\n\nList of frequently used interpreted languages\n\n*APL A vector oriented language using an unusual character set\n**J An APL variant in which tacit definition provides some of the benefits of compiling\n*BASIC (although the original version, Dartmouth BASIC, was compiled, as are many modern BASICs)\n**thinBasic\n*Equation manipulation and solving systems\n**GNU Octave\n**Interactive Data Language (IDL)\n\n**TK Solver\n**Mathematica\n**MATLAB\n*Euphoria Interpreted or compiled.\n*Game Maker Language\n*JavaScript\n*Forth\n*Lava\n*Lisp\n**Logo\n**Scheme\n*Madness Script\n*MUMPS\n*Perl\n*PHP\n*PostScript]\n*Python\n*REXX\n*Seed7\n*Smalltalk\n**Bistro\n**Dolphin Smalltalk\n**F-Script\n**Little Smalltalk\n**Squeak\n**VisualAge\n**VisualWorks\n*Spreadsheets\n**Excel\n*S\n**R\n*Tcl\n**XOTcl\n*VBScript\n*PowerShell\n*[http://xmlmosaic.codeplex.com XMLmosaic] An xml contained C# like programming language interpreted by a console application written in Visual Basic .NET\n\nLanguages usually compiled to a bytecode\n\nMany languages are first compiled to bytecode. Ѕometimes, bytecode can also be compiled to a native binary using an AOT compiler or executed natively, by hardware processor.\n*AppleScript\n*Erlang (compiled into Erlang bytecode and interpreted by the BEAM VM)\n** Elixir (runs on the Erlang VM)\n*Java (is compiled into Java bytecode to be interpreted by JVM)\n**Clojure\n**Groovy\n**ColdFusion\n**Scala\n*.NET Framework languages (translated to bytecode, called CIL). \n**C++/CLI\n**C#\n**Visual Basic .NET\n**F#\n*Lisp\n*Lua\n*Pike\n*Ruby\n*Squeak Smalltalk\n*Visual FoxPro",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Interpreted language" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=15089" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "An interpreted language is a type of programming language for which most of its implementations execute instructions directly and freely, without previously compiling a program into machine-language instructions. The interpreter executes the program directly, translating each statement into a sequence of one or more subroutines already compiled into machine code.\n\nThe terms interpreted language and compiled language are not well defined because, in theory, any programming language can be either interpreted or compiled. In modern programming language implementation it is increasingly popular for a platform to provide both options.\n\nInterpreted languages can also be contrasted with machine languages. Functionally, both execution and interpretation mean the same thing — fetching the next instruction/statement from the program and executing it. Although interpreted byte code is additionally identical to machine code in form and has an assembler representation, the term \"interpreted\" is practically reserved for \"software processed\" languages (by virtual machine or emulator) on top of the native (i.e. hardware) processor.\n\nIn principle, programs in many languages may be compiled or interpreted, emulated or executed natively, so this designation is applied solely based on common implementation practice, rather than representing an essential property of a language.\n\nMany languages have been implemented using both compilers and interpreters, including BASIC, C, Lisp, Pascal, and Python. Java and C# are compiled into bytecode, the virtual machine-friendly interpreted language. Lisp implementations can freely mix interpreted and compiled code.\n\nHistorical background\n\nIn the early days of computing, language design was heavily influenced by the decision to use compiling or interpreting as a mode of execution. For example, Smalltalk (1980), which was designed to be interpreted at run-time, allows generic objects to dynamically interact with each other.\n\nInitially, interpreted languages were compiled line-by-line; that is, each line was compiled as it was about to be executed, and if a loop or subroutine caused certain lines to be executed multiple times, they would be recompiled every time. This has become much less common. Most so-called interpreted languages use an intermediate representation, which combines compiling and interpreting.\n\nExamples include: \n* JavaScript\n* Python\n* Ruby (similarly, it uses an abstract syntax tree as intermediate representation)\n* Forth\n\nThe intermediate representation can be compiled once and for all (as in Java), each time before execution (as in Perl or Ruby), or each time a change in the source is detected before execution (as in Python).\n\nAdvantages\n\nInterpreting a language gives implementations some additional flexibility over compiled implementations.  Features that are often easier to implement in interpreters than in compilers include:\n* platform independence (Java's byte code, for example)\n* reflection and reflective use of the evaluator (e.g. a first-order eval function)\n* dynamic typing\n* smaller executable program size (since implementations have flexibility to choose the instruction code)\n* dynamic scoping\n\nFurthermore, source code can be read and copied, giving users more freedom.\n\nDisadvantages\n\nDisadvantages of interpreted languages are:\n* Without static type-checking, which is usually performed by a compiler, programs can be less reliable, because type checking eliminates a class of programming errors.\n* Interpreters can be susceptible to Code injection attacks.\n* Slower execution compared to direct native machine code execution on the host CPU. A technique used to improve performance is just-in-time compilation which converts frequently executed sequences of interpreted instruction to host machine code. JIT is most often combined with compilation to byte-code as in Java.\n* Source code can be read and copied (e.g. JavaScript in web pages), or more easily reverse engineered through reflection in applications where intellectual property has a commercial advantage. In some cases, obfuscation is used as a partial defense against this.\n\nList of frequently used interpreted languages\n\n*APL A vector oriented language using an unusual character set\n**J An APL variant in which tacit definition provides some of the benefits of compiling\n*BASIC (although the original version, Dartmouth BASIC, was compiled, as are many modern BASICs)\n**thinBasic\n*Equation manipulation and solving systems\n**GNU Octave\n**Interactive Data Language (IDL)\n\n**TK Solver\n**Mathematica\n**MATLAB\n*Euphoria Interpreted or compiled.\n*Game Maker Language\n*JavaScript\n*Forth\n*Lava\n*Lisp\n**Logo\n**Scheme\n*Madness Script\n*MUMPS\n*Perl\n*PHP\n*PostScript]\n*Python\n*REXX\n*Seed7\n*Smalltalk\n**Bistro\n**Dolphin Smalltalk\n**F-Script\n**Little Smalltalk\n**Squeak\n**VisualAge\n**VisualWorks\n*Spreadsheets\n**Excel\n*S\n**R\n*Tcl\n**XOTcl\n*VBScript\n*PowerShell\n*[http://xmlmosaic.codeplex.com XMLmosaic] An xml contained C# like programming language interpreted by a console application written in Visual Basic .NET\n\nLanguages usually compiled to a bytecode\n\nMany languages are first compiled to bytecode. Ѕometimes, bytecode can also be compiled to a native binary using an AOT compiler or executed natively, by hardware processor.\n*AppleScript\n*Erlang (compiled into Erlang bytecode and interpreted by the BEAM VM)\n** Elixir (runs on the Erlang VM)\n*Java (is compiled into Java bytecode to be interpreted by JVM)\n**Clojure\n**Groovy\n**ColdFusion\n**Scala\n*.NET Framework languages (translated to bytecode, called CIL). \n**C++/CLI\n**C#\n**Visual Basic .NET\n**F#\n*Lisp\n*Lua\n*Pike\n*Ruby\n*Squeak Smalltalk\n*Visual FoxPro. Interpreted language. http://en.wikipedia.org/?curid=15089."
  }
}
