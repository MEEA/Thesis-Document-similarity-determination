{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=18136",
  "eid" : "311e5d50-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778591653,
  "textBody" : "Literate programming is a programming paradigm introduced by Donald Knuth in which a program is given as an explanation of the program logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which a compilable source code can be generated.\n\nThe literate programming paradigm, as conceived by Knuth, represents a move away from writing programs in the manner and order imposed by the computer, and instead enables programmers to develop programs in the order demanded by the logic and flow of their thoughts.\"I had the feeling that top-down and bottom-up were opposing methodologies: one more suitable for program exposition and the other more suitable for program creation. But after gaining experience with WEB, I have come to realize that there is no need to choose once and for all between top-down and bottom-up, because a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most important thing about a program is its structural relationships. A complex piece of software consists of simple parts and simple relations between those parts; the programmer's task is to state those parts and those relationships, in whatever order is best for human comprehension not in some rigidly determined order like top-down or bottom-up.\" — Donald E. Knuth, Literate Programming Literate programs are written as an uninterrupted exposition of logic in an ordinary human language, much like the text of an essay, in which macros are included to hide abstractions and traditional source code.\n\nLiterate programming (LP) tools are used to obtain two representations from a literate source file: one suitable for further compilation or execution by a computer, the \"tangled\" code, and another for viewing as formatted documentation, which is said to be \"woven\" from the literate source.If one remembers that the first version of the tool was called WEB, the amusing literary reference hidden by Knuth in these names becomes obvious: \"Oh, what a tangled web we weave when first we practise to deceive\" – Sir Walter Scott, in Canto VI, Stanza 17 of Marmion (1808) an epic poem about the Battle of Flodden in 1513. – the actual citation appeared as an epigraph in a May 1986 article by Jon Bentley and Donald Knuth in one of the classical Programming Pearls columns in Communications of the ACM, vol 29 num 5 on p.365 While the first generation of literate programming tools were computer language-specific, the later ones are language-agnostic and exist above the programming languages.\n\nHistory and philosophy \n\nLiterate programming was first introduced by Donald E. Knuth. The main intention behind this approach was to treat program as a literature understandable to human beings. This approach was implemented at Stanford university as a part of research on algorithms and digital typography. This implementation was further called as “WEB” by Donald Knuth since he believed that it was one of the few three-letter words of English that hadn’t already been applied to computer. However, it correctly resembles the complicated nature of software delicately pieced together from simple materials.\n\nConcept \n\nLiterate programming is writing out the program logic in a human language with included (separated by a primitive markup) code snippets and macros. Macros in a literate source file are simply title-like or explanatory phrases in a human language that describe human abstractions created while solving the programming problem, and hiding chunks of code or lower-level macros. These macros are similar to the algorithms in pseudocode typically used in teaching computer science. These arbitrary explanatory phrases become precise new operators, created on the fly by the programmer, forming a meta-language on top of the underlying programming language.\n\nA preprocessor is used to substitute arbitrary hierarchies, or rather \"interconnected 'webs' of macros\", to produce the compilable source code with one command (\"tangle\"), and documentation with another (\"weave\"). The preprocessor also provides an ability to write out the content of the macros and to add to already created macros in any place in the text of the literate program source file, thereby disposing of the need to keep in mind the restrictions imposed by traditional programming languages or to interrupt the flow of thought.\n\nAdvantages \n\nAccording to Knuth,\nliterate programming provides higher-quality programs, since it forces programmers to explicitly state the thoughts behind the program, making poorly thought-out design decisions more obvious. Knuth also claims that literate programming provides a first-rate documentation system, which is not an add-on, but is grown naturally in the process of exposition of one's thoughts during a program's creation. The resulting documentation allows the author to restart his own thought processes at any later time, and allows other programmers to understand the construction of the program more easily. This differs from traditional documentation, in which a programmer is presented with source code that follows a compiler-imposed order, and must decipher the thought process behind the program from the code and its associated comments. The meta-language capabilities of literate programming are also claimed to facilitate thinking, giving a higher \"bird's eye view\" of the code and increasing the number of concepts the mind can successfully retain and process. Applicability of the concept to programming on a large scale, that of commercial-grade programs, is proven by an edition of TeX code as a literate program.\n\nContrast with documentation generation \n\nLiterate programming is very often misunderstood to refer only to formatted documentation produced from a common file with both source code and comments – which is properly called documentation generation – or to voluminous commentaries included with code. This is backwards: well-documented code or documentation extracted from code follows the structure of the code, with documentation embedded in the code; in literate programming code is embedded in documentation, with the code following the structure of the documentation.\n\nThis misconception has led to claims that comment-extraction tools, such as the Perl Plain Old Documentation or Java Javadoc systems, are \"literate programming tools\". However, because these tools do not implement the \"web of abstract concepts\" hiding behind the system of natural-language macros, or provide an ability to change the order of the source code from a machine-imposed sequence to one convenient to the human mind, they cannot properly be called literate programming tools in the sense intended by Knuth.\n\nWorkflow \n\nImplementing literate programming consists of two steps:\n\n# Weaving: Generating comprehensive document about program and its maintenance.\n# Tangling: Generating machine executable code\n\nWeaving and Tangling are done on the same source so that they are consistent with each other.\n\nExample \n\nA classic example of literate programming is the literate implementation of the standard Unix wc word counting program. Knuth presented a CWEB version of this example in Chapter 12 of his Literate Programming book. The same example was later rewritten for the noweb literate programming tool. This example provides a good illustration of the basic elements of literate programming.\n\nCreation of macros \n\nThe following snippet of the wc literate program shows how arbitrary descriptive phrases in a natural language are used in a literate program to create macros, which act as new \"operators\" in the literate programming language, and hide chunks of code or other macros. The mark-up notation consists of double angle brackets (\">\") that indicate macros, the \"@\" symbol which indicates the end of the code section in a noweb file. The \">\" symbol stands for the \"root\", topmost node the literate programming tool will start expanding the web of macros from. Actually, writing out the expanded source code can be done from any section or subsection (i.e. a piece of code designated as \">\n\", with the equal sign), so one literate program file can contain several files with machine source code.\n\nThe purpose of wc is to count lines, words, and/or characters in a list of files. The\nnumber of lines in a file is ......../more explanations/\n\nHere, then, is an overview of the file wc.c that is defined by the noweb program wc.nw:\n    >=\n    >\n    >\n    >\n    >\n    >\n    @\n\nWe must include the standard I/O definitions, since we want to send formatted output\nto stdout and stderr.\n    >=\n    #include \n    @\n\nThe unraveling of the chunks can be done in any place in the literate program text file, not necessarily in the order they are sequenced in the enclosing chunk, but as is demanded by the logic reflected in the explanatory text that envelops the whole program.\n\nProgram as a web—macros are not just section names \n\nMacros are not the same as \"section names\" in standard documentation. Literate programming macros can hide any chunk of code behind themselves, and be used inside any low-level machine language operators, often inside logical operators such as \"if\", \"while\" or \"case\". This is illustrated by the following snippet of the wc literate program.\n\nThe present chunk, which does the counting, was actually one of\nthe simplest to write. We look at each character and change state if it begins or ends\na word.\n\n    >=\n    while (1) {\n      >\n      c = *ptr++;\n      if (c > ' ' && c \n\nIn fact, macros can stand for any arbitrary chunk of code or other macros, and are thus more general than top-down or bottom-up \"chunking\", or than subsectioning. Knuth says that when he realized this, he began to think of a program as a web of various parts.\n\nOrder of human logic, not that of the compiler \n\nIn a noweb literate program besides the free order of their exposition, the chunks behind macros, once introduced with \">\", can be grown later in any place in the file by simply writing \">\n\" and adding more content to it, as the following snippet illustrates (\"plus\" is added by the document formatter for readability, and is not in the code).\n\n The grand totals must be initialized to zero at the beginning of the program.\nIf we made these variables local to main, we would have to do this  initialization\nexplicitly; however, C globals are automatically zeroed. (Or rather,``statically\nzeroed. (Get it?)\n\n    >+=\n    long tot_word_count, tot_line_count,\n         tot_char_count;\n      /* total number of words, lines, chars */\n    @\n\nRecord of the train of thought \n\nThe documentation for a literate program is produced as part of writing the program. Instead of comments provided as side notes to source code a literate program contains the explanation of concepts on each level, with lower level concepts deferred to their appropriate place, which allows for  better communication of thought. The snippets of the literate wc above show how an explanation of the program and its source code are interwoven. Such exposition of ideas creates the flow of thought that is like a literary work. Knuth wrote a \"novel\" which explains the code of the interactive fiction game Colossal Cave Adventure.The game, also known as ADVENT, was originally written by Crowther in about 700 lines of FORTRAN code; Knuth recast it into the WEB idiom. It is available at [http://www.literateprogramming.com/cweb_download.html literateprogramming.com] or on [http://sunburn.stanford.edu/~knuth/programs.html Knuth's website] .\n\nTools \n\nThe first published literate programming environment was WEB, introduced by Donald Knuth in 1981 for his TeX typesetting system; it uses Pascal as its underlying programming language and TeX for typesetting of the documentation. The complete commented TeX source code was published in Knuth's TeX: The program, volume B of his 5-volume Computers and Typesetting. Knuth had privately used a literate programming system called DOC as early as 1979. He was inspired by the ideas of Pierre-Arnoul de Marneffe. The free CWEB, written by Knuth and Silvio Levy, is WEB adapted for C and  C++, runs on most operating systems and can produce TeX and PDF documentation.\n\nThere are various other implementations of the literate programming concept:\n\n* Axiom, which is evolved from scratchpad, a computer algebra system developed by IBM. It is now being developed by Tim Daly, one of the developer of scratchpad, Axiom is totally written as a literate program. \n* noweb is independent of the programming language of the source code. It is well known for its simplicity, given the need of using only two text markup conventions and two tool invocations, and it allows for text formatting in HTML rather than going through the TeX system.\n* Literate is a \"modern literate programming system.\" Like noweb, it works with any programming language, but it produces pretty-printed and syntax-highlighted HTML, and it tries to retain all the advantages of CWEB, including output formatted like CWEB. Other notable advantages compared with older tools include being based on Markdown and generating well-formatted \"tangled\" code. https://github.com/zyedidia/Literate.\n* FunnelWeb is another LP tool that can produce HTML documentation output. It has more complicated markup (with \"@\" escaping any FunnelWeb command), but has many more flexible options. Like noweb, it is independent of the programming language of the source code. http://www.ross.net/funnelweb/\n* Nuweb can translate a single LP source into any number of code files in any mix of languages together with documentation in LaTeX. It does it in a single invocation; it does not have separate weave and tangle commands. It does not have the extensibility of noweb, but it can use the listings package of LaTeX to provide pretty-printing and the hyperref package to provide hyperlinks in  PDF output. It also has extensive indexing and cross-referencing facilities including cross-references from the generated code back to the documentation, both as automatically generated comments and as strings that the code can use to report its behaviour. Vimes is a type-checker for Z notation which shows the use of nuweb in a practical application. Around 15,000 lines of nuweb source are translated into nearly 15,000 lines of C/C++ code and over 460 pages of documentation. http://nuweb.sourceforge.net/\n* Molly is an LP tool written in Perl, which aims to modernize and scale it with \"folding HTML\" and \"virtual views\" on code. It uses \"noweb\" markup for the literate source files. https://github.com/unixtechie/Literate-Molly.\n* Codnar is an inverse literate programming tool available as a Ruby Gem. Instead of the machine-readable source code being extracted out of the literate documentation sources, the literate documentation is extracted out of the normal machine-readable source code files. This allows these source code files to be edited and maintained as usual. The approach is similar to that used by popular API documentation tools, such as JavaDoc. Such tools, however, generate API reference documentation, while Codnar generates a linear narrative describing the code, similar to that created by classical LP tools. Codnar can co-exist with API documentation tools, allowing both a reference manual and a linear narrative to be generated from the same set of source code files. https://github.com/orenbenkiki/codnar\n* The Leo text editor is an outlining editor which supports optional noweb and CWEB markup. The author of Leo mixes two different approaches: first, Leo is an outlining editor, which helps with management of large texts; second, Leo incorporates some of the ideas of literate programming, which in its pure form (i.e., the way it is used by Knuth Web tool or tools like \"noweb\") is possible only with some degree of inventiveness and the use of the editor in a way not exactly envisioned by its author (in modified @root nodes). However, this and other extensions (@file nodes) make outline programming and text management successful and easy and in some ways similar to literate programming.\n* The Haskell programming language has native support for semi-literate programming. The compiler/interpreter supports two file name extensions: .hs and .lhs; the latter stands for literate Haskell. \nThe literate scripts can be full LaTeX source text, at the same time it can be compiled, with no changes, because the interpreter only compile the text in a code environment, for example\n\n% here text describing the function:\n\\begin{code}\nfact 0 = 1\nfact (n+1) = (n+1) * fact n\n\\end{code}\nhere more text\n\nThe code can be also marked in the Richard Bird style, starting each line with a greater than symbol and a space, preceding and ending the piece of code with blank lines.\n* The LaTeX listings package provides a lstlisting environment which can be used to embellish the source code. It can be used to define a code environment to use within Haskell to print the symbols something like:\n\n\\newenvironment{code}{\\lstlistings[language=Haskell]}{\\endlstlistings}\n\n\\begin{code}\ncomp :: (beta -> gamma) -> (alpha -> beta) -> (alpha -> gamma)\n(g `comp` f) x = g(f x)\n\\end{code}\n\ncan be configured to yield something like this:\n:\n\\begin{align}\n&comp :: (\\beta \\to \\gamma) \\to (\\alpha \\to \\beta) \\to (\\alpha \\to \\gamma)\\\\\n&(g \\operatorname{comp} f) x = g(f x)\n\\end{align}\n\nAlthough the package does not provide means to organize chunks of code, one can split the LaTeX source code in different files. See [http://mirrors.ctan.org/macros/latex/contrib/listings/listings.pdf listings manual] for an overview.\n* The Web 68 Literate Programming system uses Algol 68 as the underlying programming language, although there is nothing in the pre-processor 'tang' to force the use of that language.\n* Emacs org-mode for literate programming through Babel,http://orgmode.org/worg/org-contrib/babel/intro.html which allows embedding blocks of source code from multiple programming languageshttp://orgmode.org/worg/org-contrib/babel/languages.html#langs within a single text document. Blocks of code can share data with each other, display images inline, or be parsed into pure source code using the noweb reference syntax.http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming\n* CoffeeScript supports a \"literate\" mode, which enables programs to be compiled from a source document written in Markdown with indented blocks of code.\n* Wolfram Language, formerly known as Mathematica, is written in notebooks which combine text with code.[https://books.google.com/books?idJTYPKxug49IC&pg\nPA157&lpgPA157&dq\n%22Stephen+Wolfram%22+%22Literate+programming%22&sourcebl&ots\nC7RhOB4uR5&sig_i5FMOR-d_BVsiwk7BD-C2Hye-8&hl\nen&saX&ved\n0CB0Q6AEwAGoVChMIhomzxbqGyQIVBcRjCh02pge6#vonepage&q\n%22Stephen%20Wolfram%22%20%22Literate%20programming%22&f=false Milestones in Computer Science and Information Technology] by Edwin D. Reilly, p. 157.\n* Swift (programming language), created by Apple Inc. can be edited in [https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AboutPlaygrounds.html Playgrounds] which provide an interactive programming environment that evaluates each statement and displays live results as the code is edited.  Playgrounds also allow the user to add Markup language along with the code that provide headers, inline formatting and images.\n* Jupyter Notebook, formerly IPython Notebook - works in the format of notebooks, which combine headings, text (including LaTeX), plots, etc. with the written code.\n* Julia (programming language) supports the iJulia mode of development which was inspired by iPython.\n* Agda (programming language) supports a limited form of literate programming out of the box.\n* [http://witheve.com Eve programming language] programs are primarily prose. Eve combines variants of Datalog and Markdown with a live graphical development environment.\n* Similar to Jupyter Notebooks, [http://rmarkdown.rstudio.com/r_notebooks.html R Notebooks] are a method of literate programming that allows for direct interaction with R (only) while producing a reproducible document with publication-quality output.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Literate programming" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=18136" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Literate programming is a programming paradigm introduced by Donald Knuth in which a program is given as an explanation of the program logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which a compilable source code can be generated.\n\nThe literate programming paradigm, as conceived by Knuth, represents a move away from writing programs in the manner and order imposed by the computer, and instead enables programmers to develop programs in the order demanded by the logic and flow of their thoughts.\"I had the feeling that top-down and bottom-up were opposing methodologies: one more suitable for program exposition and the other more suitable for program creation. But after gaining experience with WEB, I have come to realize that there is no need to choose once and for all between top-down and bottom-up, because a program is best thought of as a web instead of a tree. A hierarchical structure is present, but the most important thing about a program is its structural relationships. A complex piece of software consists of simple parts and simple relations between those parts; the programmer's task is to state those parts and those relationships, in whatever order is best for human comprehension not in some rigidly determined order like top-down or bottom-up.\" — Donald E. Knuth, Literate Programming Literate programs are written as an uninterrupted exposition of logic in an ordinary human language, much like the text of an essay, in which macros are included to hide abstractions and traditional source code.\n\nLiterate programming (LP) tools are used to obtain two representations from a literate source file: one suitable for further compilation or execution by a computer, the \"tangled\" code, and another for viewing as formatted documentation, which is said to be \"woven\" from the literate source.If one remembers that the first version of the tool was called WEB, the amusing literary reference hidden by Knuth in these names becomes obvious: \"Oh, what a tangled web we weave when first we practise to deceive\" – Sir Walter Scott, in Canto VI, Stanza 17 of Marmion (1808) an epic poem about the Battle of Flodden in 1513. – the actual citation appeared as an epigraph in a May 1986 article by Jon Bentley and Donald Knuth in one of the classical Programming Pearls columns in Communications of the ACM, vol 29 num 5 on p.365 While the first generation of literate programming tools were computer language-specific, the later ones are language-agnostic and exist above the programming languages.\n\nHistory and philosophy \n\nLiterate programming was first introduced by Donald E. Knuth. The main intention behind this approach was to treat program as a literature understandable to human beings. This approach was implemented at Stanford university as a part of research on algorithms and digital typography. This implementation was further called as “WEB” by Donald Knuth since he believed that it was one of the few three-letter words of English that hadn’t already been applied to computer. However, it correctly resembles the complicated nature of software delicately pieced together from simple materials.\n\nConcept \n\nLiterate programming is writing out the program logic in a human language with included (separated by a primitive markup) code snippets and macros. Macros in a literate source file are simply title-like or explanatory phrases in a human language that describe human abstractions created while solving the programming problem, and hiding chunks of code or lower-level macros. These macros are similar to the algorithms in pseudocode typically used in teaching computer science. These arbitrary explanatory phrases become precise new operators, created on the fly by the programmer, forming a meta-language on top of the underlying programming language.\n\nA preprocessor is used to substitute arbitrary hierarchies, or rather \"interconnected 'webs' of macros\", to produce the compilable source code with one command (\"tangle\"), and documentation with another (\"weave\"). The preprocessor also provides an ability to write out the content of the macros and to add to already created macros in any place in the text of the literate program source file, thereby disposing of the need to keep in mind the restrictions imposed by traditional programming languages or to interrupt the flow of thought.\n\nAdvantages \n\nAccording to Knuth,\nliterate programming provides higher-quality programs, since it forces programmers to explicitly state the thoughts behind the program, making poorly thought-out design decisions more obvious. Knuth also claims that literate programming provides a first-rate documentation system, which is not an add-on, but is grown naturally in the process of exposition of one's thoughts during a program's creation. The resulting documentation allows the author to restart his own thought processes at any later time, and allows other programmers to understand the construction of the program more easily. This differs from traditional documentation, in which a programmer is presented with source code that follows a compiler-imposed order, and must decipher the thought process behind the program from the code and its associated comments. The meta-language capabilities of literate programming are also claimed to facilitate thinking, giving a higher \"bird's eye view\" of the code and increasing the number of concepts the mind can successfully retain and process. Applicability of the concept to programming on a large scale, that of commercial-grade programs, is proven by an edition of TeX code as a literate program.\n\nContrast with documentation generation \n\nLiterate programming is very often misunderstood to refer only to formatted documentation produced from a common file with both source code and comments – which is properly called documentation generation – or to voluminous commentaries included with code. This is backwards: well-documented code or documentation extracted from code follows the structure of the code, with documentation embedded in the code; in literate programming code is embedded in documentation, with the code following the structure of the documentation.\n\nThis misconception has led to claims that comment-extraction tools, such as the Perl Plain Old Documentation or Java Javadoc systems, are \"literate programming tools\". However, because these tools do not implement the \"web of abstract concepts\" hiding behind the system of natural-language macros, or provide an ability to change the order of the source code from a machine-imposed sequence to one convenient to the human mind, they cannot properly be called literate programming tools in the sense intended by Knuth.\n\nWorkflow \n\nImplementing literate programming consists of two steps:\n\n# Weaving: Generating comprehensive document about program and its maintenance.\n# Tangling: Generating machine executable code\n\nWeaving and Tangling are done on the same source so that they are consistent with each other.\n\nExample \n\nA classic example of literate programming is the literate implementation of the standard Unix wc word counting program. Knuth presented a CWEB version of this example in Chapter 12 of his Literate Programming book. The same example was later rewritten for the noweb literate programming tool. This example provides a good illustration of the basic elements of literate programming.\n\nCreation of macros \n\nThe following snippet of the wc literate program shows how arbitrary descriptive phrases in a natural language are used in a literate program to create macros, which act as new \"operators\" in the literate programming language, and hide chunks of code or other macros. The mark-up notation consists of double angle brackets (\">\") that indicate macros, the \"@\" symbol which indicates the end of the code section in a noweb file. The \">\" symbol stands for the \"root\", topmost node the literate programming tool will start expanding the web of macros from. Actually, writing out the expanded source code can be done from any section or subsection (i.e. a piece of code designated as \">\n\", with the equal sign), so one literate program file can contain several files with machine source code.\n\nThe purpose of wc is to count lines, words, and/or characters in a list of files. The\nnumber of lines in a file is ......../more explanations/\n\nHere, then, is an overview of the file wc.c that is defined by the noweb program wc.nw:\n    >=\n    >\n    >\n    >\n    >\n    >\n    @\n\nWe must include the standard I/O definitions, since we want to send formatted output\nto stdout and stderr.\n    >=\n    #include \n    @\n\nThe unraveling of the chunks can be done in any place in the literate program text file, not necessarily in the order they are sequenced in the enclosing chunk, but as is demanded by the logic reflected in the explanatory text that envelops the whole program.\n\nProgram as a web—macros are not just section names \n\nMacros are not the same as \"section names\" in standard documentation. Literate programming macros can hide any chunk of code behind themselves, and be used inside any low-level machine language operators, often inside logical operators such as \"if\", \"while\" or \"case\". This is illustrated by the following snippet of the wc literate program.\n\nThe present chunk, which does the counting, was actually one of\nthe simplest to write. We look at each character and change state if it begins or ends\na word.\n\n    >=\n    while (1) {\n      >\n      c = *ptr++;\n      if (c > ' ' && c \n\nIn fact, macros can stand for any arbitrary chunk of code or other macros, and are thus more general than top-down or bottom-up \"chunking\", or than subsectioning. Knuth says that when he realized this, he began to think of a program as a web of various parts.\n\nOrder of human logic, not that of the compiler \n\nIn a noweb literate program besides the free order of their exposition, the chunks behind macros, once introduced with \">\", can be grown later in any place in the file by simply writing \">\n\" and adding more content to it, as the following snippet illustrates (\"plus\" is added by the document formatter for readability, and is not in the code).\n\n The grand totals must be initialized to zero at the beginning of the program.\nIf we made these variables local to main, we would have to do this  initialization\nexplicitly; however, C globals are automatically zeroed. (Or rather,``statically\nzeroed. (Get it?)\n\n    >+=\n    long tot_word_count, tot_line_count,\n         tot_char_count;\n      /* total number of words, lines, chars */\n    @\n\nRecord of the train of thought \n\nThe documentation for a literate program is produced as part of writing the program. Instead of comments provided as side notes to source code a literate program contains the explanation of concepts on each level, with lower level concepts deferred to their appropriate place, which allows for  better communication of thought. The snippets of the literate wc above show how an explanation of the program and its source code are interwoven. Such exposition of ideas creates the flow of thought that is like a literary work. Knuth wrote a \"novel\" which explains the code of the interactive fiction game Colossal Cave Adventure.The game, also known as ADVENT, was originally written by Crowther in about 700 lines of FORTRAN code; Knuth recast it into the WEB idiom. It is available at [http://www.literateprogramming.com/cweb_download.html literateprogramming.com] or on [http://sunburn.stanford.edu/~knuth/programs.html Knuth's website] .\n\nTools \n\nThe first published literate programming environment was WEB, introduced by Donald Knuth in 1981 for his TeX typesetting system; it uses Pascal as its underlying programming language and TeX for typesetting of the documentation. The complete commented TeX source code was published in Knuth's TeX: The program, volume B of his 5-volume Computers and Typesetting. Knuth had privately used a literate programming system called DOC as early as 1979. He was inspired by the ideas of Pierre-Arnoul de Marneffe. The free CWEB, written by Knuth and Silvio Levy, is WEB adapted for C and  C++, runs on most operating systems and can produce TeX and PDF documentation.\n\nThere are various other implementations of the literate programming concept:\n\n* Axiom, which is evolved from scratchpad, a computer algebra system developed by IBM. It is now being developed by Tim Daly, one of the developer of scratchpad, Axiom is totally written as a literate program. \n* noweb is independent of the programming language of the source code. It is well known for its simplicity, given the need of using only two text markup conventions and two tool invocations, and it allows for text formatting in HTML rather than going through the TeX system.\n* Literate is a \"modern literate programming system.\" Like noweb, it works with any programming language, but it produces pretty-printed and syntax-highlighted HTML, and it tries to retain all the advantages of CWEB, including output formatted like CWEB. Other notable advantages compared with older tools include being based on Markdown and generating well-formatted \"tangled\" code. https://github.com/zyedidia/Literate.\n* FunnelWeb is another LP tool that can produce HTML documentation output. It has more complicated markup (with \"@\" escaping any FunnelWeb command), but has many more flexible options. Like noweb, it is independent of the programming language of the source code. http://www.ross.net/funnelweb/\n* Nuweb can translate a single LP source into any number of code files in any mix of languages together with documentation in LaTeX. It does it in a single invocation; it does not have separate weave and tangle commands. It does not have the extensibility of noweb, but it can use the listings package of LaTeX to provide pretty-printing and the hyperref package to provide hyperlinks in  PDF output. It also has extensive indexing and cross-referencing facilities including cross-references from the generated code back to the documentation, both as automatically generated comments and as strings that the code can use to report its behaviour. Vimes is a type-checker for Z notation which shows the use of nuweb in a practical application. Around 15,000 lines of nuweb source are translated into nearly 15,000 lines of C/C++ code and over 460 pages of documentation. http://nuweb.sourceforge.net/\n* Molly is an LP tool written in Perl, which aims to modernize and scale it with \"folding HTML\" and \"virtual views\" on code. It uses \"noweb\" markup for the literate source files. https://github.com/unixtechie/Literate-Molly.\n* Codnar is an inverse literate programming tool available as a Ruby Gem. Instead of the machine-readable source code being extracted out of the literate documentation sources, the literate documentation is extracted out of the normal machine-readable source code files. This allows these source code files to be edited and maintained as usual. The approach is similar to that used by popular API documentation tools, such as JavaDoc. Such tools, however, generate API reference documentation, while Codnar generates a linear narrative describing the code, similar to that created by classical LP tools. Codnar can co-exist with API documentation tools, allowing both a reference manual and a linear narrative to be generated from the same set of source code files. https://github.com/orenbenkiki/codnar\n* The Leo text editor is an outlining editor which supports optional noweb and CWEB markup. The author of Leo mixes two different approaches: first, Leo is an outlining editor, which helps with management of large texts; second, Leo incorporates some of the ideas of literate programming, which in its pure form (i.e., the way it is used by Knuth Web tool or tools like \"noweb\") is possible only with some degree of inventiveness and the use of the editor in a way not exactly envisioned by its author (in modified @root nodes). However, this and other extensions (@file nodes) make outline programming and text management successful and easy and in some ways similar to literate programming.\n* The Haskell programming language has native support for semi-literate programming. The compiler/interpreter supports two file name extensions: .hs and .lhs; the latter stands for literate Haskell. \nThe literate scripts can be full LaTeX source text, at the same time it can be compiled, with no changes, because the interpreter only compile the text in a code environment, for example\n\n% here text describing the function:\n\\begin{code}\nfact 0 = 1\nfact (n+1) = (n+1) * fact n\n\\end{code}\nhere more text\n\nThe code can be also marked in the Richard Bird style, starting each line with a greater than symbol and a space, preceding and ending the piece of code with blank lines.\n* The LaTeX listings package provides a lstlisting environment which can be used to embellish the source code. It can be used to define a code environment to use within Haskell to print the symbols something like:\n\n\\newenvironment{code}{\\lstlistings[language=Haskell]}{\\endlstlistings}\n\n\\begin{code}\ncomp :: (beta -> gamma) -> (alpha -> beta) -> (alpha -> gamma)\n(g `comp` f) x = g(f x)\n\\end{code}\n\ncan be configured to yield something like this:\n:\n\\begin{align}\n&comp :: (\\beta \\to \\gamma) \\to (\\alpha \\to \\beta) \\to (\\alpha \\to \\gamma)\\\\\n&(g \\operatorname{comp} f) x = g(f x)\n\\end{align}\n\nAlthough the package does not provide means to organize chunks of code, one can split the LaTeX source code in different files. See [http://mirrors.ctan.org/macros/latex/contrib/listings/listings.pdf listings manual] for an overview.\n* The Web 68 Literate Programming system uses Algol 68 as the underlying programming language, although there is nothing in the pre-processor 'tang' to force the use of that language.\n* Emacs org-mode for literate programming through Babel,http://orgmode.org/worg/org-contrib/babel/intro.html which allows embedding blocks of source code from multiple programming languageshttp://orgmode.org/worg/org-contrib/babel/languages.html#langs within a single text document. Blocks of code can share data with each other, display images inline, or be parsed into pure source code using the noweb reference syntax.http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming\n* CoffeeScript supports a \"literate\" mode, which enables programs to be compiled from a source document written in Markdown with indented blocks of code.\n* Wolfram Language, formerly known as Mathematica, is written in notebooks which combine text with code.[https://books.google.com/books?idJTYPKxug49IC&pg\nPA157&lpgPA157&dq\n%22Stephen+Wolfram%22+%22Literate+programming%22&sourcebl&ots\nC7RhOB4uR5&sig_i5FMOR-d_BVsiwk7BD-C2Hye-8&hl\nen&saX&ved\n0CB0Q6AEwAGoVChMIhomzxbqGyQIVBcRjCh02pge6#vonepage&q\n%22Stephen%20Wolfram%22%20%22Literate%20programming%22&f=false Milestones in Computer Science and Information Technology] by Edwin D. Reilly, p. 157.\n* Swift (programming language), created by Apple Inc. can be edited in [https://developer.apple.com/library/prerelease/ios/recipes/Playground_Help/Chapters/AboutPlaygrounds.html Playgrounds] which provide an interactive programming environment that evaluates each statement and displays live results as the code is edited.  Playgrounds also allow the user to add Markup language along with the code that provide headers, inline formatting and images.\n* Jupyter Notebook, formerly IPython Notebook - works in the format of notebooks, which combine headings, text (including LaTeX), plots, etc. with the written code.\n* Julia (programming language) supports the iJulia mode of development which was inspired by iPython.\n* Agda (programming language) supports a limited form of literate programming out of the box.\n* [http://witheve.com Eve programming language] programs are primarily prose. Eve combines variants of Datalog and Markdown with a live graphical development environment.\n* Similar to Jupyter Notebooks, [http://rmarkdown.rstudio.com/r_notebooks.html R Notebooks] are a method of literate programming that allows for direct interaction with R (only) while producing a reproducible document with publication-quality output. Literate programming. http://en.wikipedia.org/?curid=18136."
  }
}
