{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=20362",
  "eid" : "41bc35b0-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778619531,
  "textBody" : "Merge algorithms are a family of algorithms that take multiple sorted lists as input and produce a single list as output, containing all the elements of the inputs lists in sorted order. These algorithms are used as subroutines in various sorting algorithms, most famously merge sort.\n\nApplication \n\nThe merge algorithm plays a critical role in the merge sort algorithm, a comparison-based sorting algorithm. Conceptually, merge sort algorithm consists of two steps:\n\n# Recursively divide the list into sublists of (roughly) equal length, until each sublist contains only one element. A list containing a single element is, by definition, sorted.\n# Repeatedly merge sublists to create a new sorted sublist until the single list contains all elements. The single list is the sorted list.\n\nThe merge algorithm is used repeatedly in the merge sort algorithm.\n\nAn example merge sort is given in the illustration. It starts with an unsorted array of 7 integers. The array is divided into 7 partitions; each partition contains 1 element and is sorted. The sorted partitions are then merged to produce larger, sorted, partitions, until 1 partition, the sorted array, is left.\n\nMerging two lists \n\nMerging two sorted lists into one can be done in linear time and linear space. The following pseudocode demonstrates an algorithm that merges input lists (either linked lists or arrays)  and  into a new list . The function  yields the first element of a list; \"dropping\" an element means removing it from its list, typically by incrementing a pointer or index.\n\n algorithm merge(A, B) is\n     inputs A, B : list\n     returns list\n \n     C := new empty list\n     while A is not empty and B is not empty do\n         if head(A) ≤ head(B) then\n             append head(A) to C\n             drop the head of A\n         else\n             append head(B) to C\n             drop the head of B\n \n     // By now, either A or B is empty. It remains to empty the other input list.\n     while A is not empty do\n         append head(A) to C\n         drop the head of A\n     while B is not empty do\n         append head(B) to C\n         drop the head of B\n \n     return C\n\nWhen the inputs are linked lists, this algorithm can be implemented to use only a constant amount of working space; the pointers in the lists' nodes can be reused for bookkeeping and for constructing the final merged list.\n\nIn the merge sort algorithm, this subroutine is typically used to merge two sub-arrays ,  of a single array . This can be done by copying the sub-arrays into a temporary array, then applying the merge algorithm above. The allocation of a temporary array can be avoided, but at the expense of speed and programming ease. Various in-place merge algorithms have been devised, sometimes sacrificing the linear-time bound to produce an  algorithm; see  for discussion.\n\nK-way merging\n\n-way merging generalizes binary merging to an arbitrary number  of sorted input lists. Applications of -way merging arise in various sorting algorithms, including patience sorting and an external sorting algorithm that divides its input into  blocks that fit in memory, sorts these one by one, then merges these blocks.\n\nSeveral solutions to this problem exist. A naive solution is to do a loop over the  lists to pick off the minimum element each time, and repeat this loop until all lists are empty:\n\n* Input: a list of  lists.\n* While any of the lists is non-empty:\n** Loop over the lists to find the one with the minimum first element.\n** Output the minimum element and remove it from its list.\n\nIn the worst case, this algorithm performs  element comparisons to perform its work if there are a total of  elements in the lists.\nIt can be improved by storing the lists in a priority queue (min-heap) keyed by their first element:\n\n* Build a min-heap  of the  lists, using the first element as the key.\n* While any of the lists is non-empty:\n** Let .\n** Output the first element of list  and remove it from its list.\n** Re-heapify .\n\nSearching for the next smallest element to be output (find-min) and restoring heap order can now be done in  time (more specifically,  comparisons), and the full problem can be solved in  time (approximately  comparisons).\n\nA third algorithm for the problem is a divide and conquer solution that builds on the binary merge algorithm:\n\n* If , output the single input list.\n* If , perform a binary merge.\n* Else, recursively merge the first  lists and the final  lists, then binary merge these.\n\nWhen the input lists to this algorithm are ordered by length, shortest first, it requires fewer than  comparisons, i.e., less than half the number used by the heap-based algorithm; in practice, it may be about as fast or slow as the heap-based algorithm.\n\nParallel merge \n\nA parallel version of the binary merge algorithm can serve as a building block of a parallel merge sort. The following pseudocode demonstrates this algorithm in a parallel divide-and-conquer style (adapted from Cormen et al.). It operates on two sorted arrays  and  and writes the sorted output to array . The notation  denotes the part of  from index  through , exclusive.\n\n algorithm merge(A[i...j], B[k...ℓ], C[p...q]) is\n     inputs A, B, C : array\n            i, j, k, ℓ, p, q : indices\n \n     let m = j - i,\n         n = ℓ - k\n \n     if m https://docs.python.org/library/heapq.html#heapq.merge",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Merge algorithm" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=20362" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Merge algorithms are a family of algorithms that take multiple sorted lists as input and produce a single list as output, containing all the elements of the inputs lists in sorted order. These algorithms are used as subroutines in various sorting algorithms, most famously merge sort.\n\nApplication \n\nThe merge algorithm plays a critical role in the merge sort algorithm, a comparison-based sorting algorithm. Conceptually, merge sort algorithm consists of two steps:\n\n# Recursively divide the list into sublists of (roughly) equal length, until each sublist contains only one element. A list containing a single element is, by definition, sorted.\n# Repeatedly merge sublists to create a new sorted sublist until the single list contains all elements. The single list is the sorted list.\n\nThe merge algorithm is used repeatedly in the merge sort algorithm.\n\nAn example merge sort is given in the illustration. It starts with an unsorted array of 7 integers. The array is divided into 7 partitions; each partition contains 1 element and is sorted. The sorted partitions are then merged to produce larger, sorted, partitions, until 1 partition, the sorted array, is left.\n\nMerging two lists \n\nMerging two sorted lists into one can be done in linear time and linear space. The following pseudocode demonstrates an algorithm that merges input lists (either linked lists or arrays)  and  into a new list . The function  yields the first element of a list; \"dropping\" an element means removing it from its list, typically by incrementing a pointer or index.\n\n algorithm merge(A, B) is\n     inputs A, B : list\n     returns list\n \n     C := new empty list\n     while A is not empty and B is not empty do\n         if head(A) ≤ head(B) then\n             append head(A) to C\n             drop the head of A\n         else\n             append head(B) to C\n             drop the head of B\n \n     // By now, either A or B is empty. It remains to empty the other input list.\n     while A is not empty do\n         append head(A) to C\n         drop the head of A\n     while B is not empty do\n         append head(B) to C\n         drop the head of B\n \n     return C\n\nWhen the inputs are linked lists, this algorithm can be implemented to use only a constant amount of working space; the pointers in the lists' nodes can be reused for bookkeeping and for constructing the final merged list.\n\nIn the merge sort algorithm, this subroutine is typically used to merge two sub-arrays ,  of a single array . This can be done by copying the sub-arrays into a temporary array, then applying the merge algorithm above. The allocation of a temporary array can be avoided, but at the expense of speed and programming ease. Various in-place merge algorithms have been devised, sometimes sacrificing the linear-time bound to produce an  algorithm; see  for discussion.\n\nK-way merging\n\n-way merging generalizes binary merging to an arbitrary number  of sorted input lists. Applications of -way merging arise in various sorting algorithms, including patience sorting and an external sorting algorithm that divides its input into  blocks that fit in memory, sorts these one by one, then merges these blocks.\n\nSeveral solutions to this problem exist. A naive solution is to do a loop over the  lists to pick off the minimum element each time, and repeat this loop until all lists are empty:\n\n* Input: a list of  lists.\n* While any of the lists is non-empty:\n** Loop over the lists to find the one with the minimum first element.\n** Output the minimum element and remove it from its list.\n\nIn the worst case, this algorithm performs  element comparisons to perform its work if there are a total of  elements in the lists.\nIt can be improved by storing the lists in a priority queue (min-heap) keyed by their first element:\n\n* Build a min-heap  of the  lists, using the first element as the key.\n* While any of the lists is non-empty:\n** Let .\n** Output the first element of list  and remove it from its list.\n** Re-heapify .\n\nSearching for the next smallest element to be output (find-min) and restoring heap order can now be done in  time (more specifically,  comparisons), and the full problem can be solved in  time (approximately  comparisons).\n\nA third algorithm for the problem is a divide and conquer solution that builds on the binary merge algorithm:\n\n* If , output the single input list.\n* If , perform a binary merge.\n* Else, recursively merge the first  lists and the final  lists, then binary merge these.\n\nWhen the input lists to this algorithm are ordered by length, shortest first, it requires fewer than  comparisons, i.e., less than half the number used by the heap-based algorithm; in practice, it may be about as fast or slow as the heap-based algorithm.\n\nParallel merge \n\nA parallel version of the binary merge algorithm can serve as a building block of a parallel merge sort. The following pseudocode demonstrates this algorithm in a parallel divide-and-conquer style (adapted from Cormen et al.). It operates on two sorted arrays  and  and writes the sorted output to array . The notation  denotes the part of  from index  through , exclusive.\n\n algorithm merge(A[i...j], B[k...ℓ], C[p...q]) is\n     inputs A, B, C : array\n            i, j, k, ℓ, p, q : indices\n \n     let m = j - i,\n         n = ℓ - k\n \n     if m https://docs.python.org/library/heapq.html#heapq.merge. Merge algorithm. http://en.wikipedia.org/?curid=20362."
  }
}
