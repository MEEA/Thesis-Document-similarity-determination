{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=13263",
  "eid" : "078f2c80-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778521928,
  "textBody" : "In mathematics and computing, hexadecimal (also base , or hex) is a positional numeral system with a radix, or base, of 16. It uses sixteen distinct symbols, most often the symbols 0–9 to represent values zero to nine, and A, B, C, D, E, F (or alternatively a, b, c, d, e, f) to represent values ten to fifteen.\n\nHexadecimal numerals are widely used by computer system designers and programmers. As each hexadecimal digit represents four binary digits (bits), it allows a more human-friendly representation of binary-coded values. One hexadecimal digit represents a nibble (4 bits), which is half of an octet or byte (8 bits). For example, a single byte can have values ranging from 00000000 to 11111111 in binary form, but this may be more conveniently represented as 00 to FF in hexadecimal.\n\nIn a non-programming context, a subscript is typically used to give the radix, for example the decimal value  would be expressed in hexadecimal as .  Several notations are used to support hexadecimal representation of constants in programming languages, usually involving a prefix or suffix.  The prefix \"0x\" is used in C and related languages, where this value might be denoted as 0x.\n\nRepresentation\n\nWritten representation\n\nUsing 0–9 and A–F\n\nIn contexts where the base is not clear, hexadecimal numbers can be ambiguous and confused with numbers expressed in other bases. There are several conventions for expressing values unambiguously. A numerical subscript (itself written in decimal) can give the base explicitly: 15910 is decimal 159; 15916 is hexadecimal 159, which is equal to 34510. Some authors prefer a text subscript, such as 159decimal and 159hex, or 159d and 159h.\n\nIn linear text systems, such as those used in most computer programming environments, a variety of methods have arisen:\n* In URIs (including URLs), character codes are written as hexadecimal pairs prefixed with %: http://www.example.com/name%20with%20spaces where %20 is the space (blank) character, ASCII code point 20 in hex, 32 in decimal.\n* In XML and XHTML, characters can be expressed as hexadecimal numeric character references using the notation &#xcode;, where the x denotes that code is a hex code point (of 1- to 6-digits) assigned to the character in the Unicode standard. Thus ’ represents the right single quotation mark (’), Unicode code point number 2019 in hex, 8217 (thus ’ in decimal).\n* In the Unicode standard, a character value is represented with U+ followed by the hex value, e.g. U+20AC is the Euro sign (€).\n* Color references in HTML, CSS and X Window can be expressed with six hexadecimal digits (two each for the red, green and blue components, in that order) prefixed with #: white, for example, is represented #FFFFFF . CSS allows 3-hexdigit abbreviations with one hexdigit per component: #FA3 abbreviates #FFAA33 (a golden orange: ).\n* *nix (Unix and related) shells, AT&T assembly language and likewise the C programming language, which was designed for Unix (and the syntactic descendants of C – including C++, C#, D, Java, JavaScript, Python and Windows PowerShell) use the prefix 0x for numeric constants represented in hex: 0x5A3. Character and string constants may express character codes in hexadecimal with the prefix \\x followed by two hex digits: '\\x1B' represents the Esc control character; \"\\x1B[0m\\x1B[25;1H\" is a string containing 11 characters (plus a trailing NUL to mark the end of the string) with two embedded Esc characters.The string \"\\x1B[0m\\x1B[25;1H\" specifies the character sequence Esc [ 0 m Esc [ 2 5 ; 1 H Nul. These are the escape sequences used on an ANSI terminal that reset the character set and color, and then move the cursor to line 25. To output an integer as hexadecimal with the printf function family, the format conversion code %X or %x is used.\n* In MIME (e-mail extensions) quoted-printable encoding, characters that cannot be represented as literal ASCII characters are represented by their codes as two hexadecimal digits (in ASCII) prefixed by an equal to sign , as in Espa\nF1a to send \"España\" (Spain). (Hexadecimal F1, equal to decimal 241, is the code number for the lower case n with tilde in the ISO/IEC 8859-1 character set.)\n* In Intel-derived assembly languages and Modula-2, hexadecimal is denoted with a suffixed H or h: FFh or 05A3H. Some implementations require a leading zero when the first hexadecimal digit character is not a decimal digit, so one would write 0FFh instead of FFh\n* Other assembly languages (6502, Motorola), Pascal, Delphi, some versions of BASIC (Commodore), Game Maker Language, Godot and Forth use $ as a prefix: $5A3.\n* Some assembly languages (Microchip) use the notation H'ABCD' (for ABCD16).\n* Ada and VHDL enclose hexadecimal numerals in based \"numeric quotes\": 16#5A3#. For bit vector constants VHDL uses the notation x\"5A3\".The [http://www.eng.auburn.edu/department/ee/mgc/vhdl.html#numbers VHDL MINI-REFERENCE: VHDL IDENTIFIERS, NUMBERS, STRINGS, AND EXPRESSIONS]\n* Verilog represents hexadecimal constants in the form 8'hFF, where 8 is the number of bits in the value and FF is the hexadecimal constant.\n* The Smalltalk language uses the prefix 16r: 16r5A3\n* PostScript and the Bourne shell and its derivatives denote hex with prefix 16#: 16#5A3. For PostScript, binary data (such as image pixels) can be expressed as unprefixed consecutive hexadecimal pairs: AA213FD51B3801043FBC...\n* Common Lisp uses the prefixes #x and #16r. Setting the variables *read-base* and *print-base* to 16 can also used to switch the reader and printer of a Common Lisp system to Hexadecimal number representation for reading and printing numbers. Thus Hexadecimal numbers can be represented without the #x or #16r prefix code, when the input or output base has been changed to 16.\n* MSX BASIC,[http://www.atarimagazines.com/compute/issue56/107_1_MSX_IS_COMING.php MSX is Coming — Part 2: Inside MSX] Compute!, issue 56, January 1985, p. 52 QuickBASIC, FreeBASIC and Visual Basic prefix hexadecimal numbers with &H: &H5A3\n* BBC BASIC and Locomotive BASIC use & for hex.BBC BASIC programs are not fully portable to Microsoft BASIC (without modification) since the latter takes & to prefix octal values. (Microsoft BASIC primarily uses &O to prefix octal, and it uses &H to prefix hexadecimal, but the ampersand alone yields a default interpretation as an octal prefix.\n* TI-89 and 92 series uses a 0h prefix: 0h5A3\n* ALGOL 68 uses the prefix 16r to denote hexadecimal numbers: 16r5a3.  Binary, quaternary (base-4) and octal numbers can be specified similarly.\n* The most common format for hexadecimal on IBM mainframes (zSeries) and midrange computers (IBM System i) running the traditional OS's (zOS, zVSE, zVM, TPF, IBM i) is X'5A3', and is used in Assembler, PL/I, COBOL, JCL, scripts, commands and other places. This format was common on other (and now obsolete) IBM systems as well.  Occasionally quotation marks were used instead of apostrophes.\n* Donald Knuth introduced the use of a particular typeface to represent a particular radix in his book The TeXbook.Donald E. Knuth. The TeXbook (Computers and Typesetting, Volume A). Reading, Massachusetts: Addison–Wesley, 1984. . The [http://www.ctan.org/tex-archive/systems/knuth/tex/texbook.tex source code of the book in TeX] (and a required set of macros [ftp://tug.ctan.org/pub/tex-archive/systems/knuth/lib/manmac.tex CTAN.org]) is available online on CTAN. Hexadecimal representations are written there in a typewriter typeface: 5A3\n* Any IPv6 address can be written as eight groups of four hexadecimal digits (sometimes called hextets), where each group is separated by a colon (:). This, for example, is a valid IPv6 address: 2001:0db8:85a3:0000:0000:8a2e:0370:7334; this can be abbreviated as 2001:db8:85a3::8a2e:370:7334. By contrast, IPv4 addresses are usually written in decimal.\n* Globally unique identifiers are written as thirty-two hexadecimal digits, often in unequal hyphen-separated groupings, for example {3F2504E0-4F89-41D3-9A0C-0305E82C3301}.\n\nThere is no universal convention to use lowercase or uppercase for the letter digits, and each is prevalent or preferred in particular environments by community standards or convention.\n\nHistory of written representations\n\nThe use of the letters A through F to represent the digits above 9 was not universal in the early history of computers.\n* During the 1950s, some installations favored using the digits 0 through 5 with an overline to denote the values 10–15 as , , , ,  and .\n* The SWAC (1950) and Bendix G-15 (1956) computers used the letters U through Z for values 10–15.\n* The ILLIAC I (1952) computer used the letters K, S, N, J, F and L for values 10–15.\n* The Librascope LGP-30 (1956) used the letters F, G, J, K, Q and W for values 10–15. (NB. This somewhat odd sequence was from the next six sequential numeric keyboard codes in the LGP-30's 6-bit character code.)\n* The NEC parametron computer  (1960) used the letters D, G, H, J, K (and possibly V) for values 10–15.\n* New numeric symbols and names were introduced in the Bibi-binary notation by Boby Lapointe in 1968. This notation did not become very popular. \n* Bruce Alan Martin of Brookhaven National Laboratory considered the choice of A–F \"ridiculous\". In a 1968 letter to the editor of the CACM, he proposed an entirely new set of symbols based on the bit locations, which did not gain much acceptance.\n* Soviet programmable calculators Б3-34 (1980) and similar used the symbols \"−\", \"L\", \"C\", \"Г\", \"E\", \" \" (space) for values 10–15 on their displays.\n* Seven-segment display decoder chips used various schemes for outputting values above nine. The Texas Instruments 7446/7447/7448/7449 and 74246/74247/74248/74249 use truncated versions of \"2\", \"3\", \"4\", \"5\" and \"6\" for values 10–14. Value 15 (1111 binary) was blank.\n\nVerbal and digital representations\n\nThere are no traditional numerals to represent the quantities from ten to fifteen — letters are used as a substitute — and most European languages lack non-decimal names for the numerals above ten. Even though English has names for several non-decimal powers (pair for the first binary power, score for the first vigesimal power, dozen, gross and great gross for the first three duodecimal powers), no English name describes the hexadecimal powers (decimal 16, 256, 4096, 65536, ... ). Some people read hexadecimal numbers digit by digit like a phone number, or using the NATO phonetic alphabet, the Joint Army/Navy Phonetic Alphabet, or a similar ad hoc system.\n\nSystems of counting on digits have been devised for both binary and hexadecimal.\nArthur C. Clarke suggested using each finger as an on/off bit, allowing finger counting from zero to 102310 on ten fingers. Another system for counting up to FF16 (25510) is illustrated on the right.\n\nSigns\n\nThe hexadecimal system can express negative numbers the same way as in decimal: −2A to represent −4210 and so on.\n\nHexadecimal can also be used to express the exact bit patterns used in the processor, so a sequence of hexadecimal digits may represent a signed or even a floating point value. This way, the negative number −4210 can be written as FFFF FFD6 in a 32-bit CPU register (in two's-complement), as C228 0000 in a 32-bit FPU register or C045 0000 0000 0000 in a 64-bit FPU register (in the IEEE floating-point standard).\n\nHexadecimal exponential notation\n\nJust as decimal numbers can be represented in exponential notation, so too can hexadecimal numbers.  By convention, the letter P (or p, for \"power\") represents times two raised to the power of, whereas E (or e) serves a similar purpose in decimal as part of the E notation.  The number after the P is decimal and represents the binary exponent.\n\nUsually the number is normalised so that the leading hexadecimal digit is 1 (unless the value is exactly 0).\n\nExample: 1.3DEp42 represents .\n\nHexadecimal exponential notation is required by the IEEE 754-2008 binary floating-point standard.\nThis notation can be used for floating-point literals in the C99 edition of the C programming language.\nUsing the %a or %A conversion specifiers, this notation can be produced by implementations of the printf family of functions following the C99 specification and\nSingle Unix Specification (IEEE Std 1003.1) POSIX standard.\n\nConversion\n\nBinary conversion\n\nMost computers manipulate binary data, but it is difficult for humans to work with the large number of digits for even a relatively small binary number. Although most humans are familiar with the base 10 system, it is much easier to map binary to hexadecimal than to decimal because each hexadecimal digit maps to a whole number of bits (410).\nThis example converts 11112 to base ten. Since each position in a binary numeral can contain either a 1 or a 0, its value may be easily determined by its position from the right:\n* 00012 = 110\n* 00102 = 210\n* 01002 = 410\n* 10002 = 810\nTherefore:\n\nWith little practice, mapping 11112 to F16 in one step becomes easy: see table in Written representation. The advantage of using hexadecimal rather than decimal increases rapidly with the size of the number. When the number becomes large, conversion to decimal is very tedious. However, when mapping to hexadecimal, it is trivial to regard the binary string as 4-digit groups and map each to a single hexadecimal digit.\n\nThis example shows the conversion of a binary number to decimal, mapping each digit to the decimal value, and adding the results.\n\nCompare this to the conversion to hexadecimal, where each group of four digits can be considered independently, and converted directly:\n\nThe conversion from hexadecimal to binary is equally direct.\n\nOther simple conversions\n\nAlthough quaternary (base 4) is little used, it can easily be converted to and from hexadecimal or binary. Each hexadecimal digit corresponds to a pair of quaternary digits and each quaternary digit corresponds to a pair of binary digits. In the above example 5 E B 5 216 = 11 32 23 11 024.\n\nThe octal (base 8) system can also be converted with relative ease, although not quite as trivially as with bases 2 and 4. Each octal digit corresponds to three binary digits, rather than four. Therefore we can convert between octal and hexadecimal via an intermediate conversion to binary followed by regrouping the binary digits in groups of either three or four.\n\nDivision-remainder in source base\n\nAs with all bases there is a simple algorithm for converting a representation of a number to hexadecimal by doing integer division and remainder operations in the source base. In theory, this is possible from any base, but for most humans only decimal and for most computers only binary (which can be converted by far more efficient methods) can be easily handled with this method.\n\nLet d be the number to represent in hexadecimal, and the series hihi−1...h2h1 be the hexadecimal digits representing the number.\n\n# i ← 1\n# hi ← d mod 16\n# d ← (d − hi) / 16\n# If d = 0 (return series hi) else increment i and go to step 2\n\n\"16\" may be replaced with any other base that may be desired.\n\nThe following is a JavaScript implementation of the above algorithm for converting any number to a hexadecimal in String representation. Its purpose is to illustrate the above algorithm. To work with data seriously, however, it is much more advisable to work with bitwise operators.\n\nfunction toHex(d) {\n  var r = d % 16;\n  if (d - r \n 0) {\n    return toChar(r);\n  }\n  return toHex( (d - r)/16 ) + toChar(r);\n}\n\nfunction toChar(n) {\n  const alpha = \"0123456789ABCDEF\";\n  return alpha.charAt(n);\n}\n\nAddition and multiplication\n\nIt is also possible to make the conversion by assigning each place in the source base the hexadecimal representation of its place value and then performing multiplication and addition to get the final representation.\nThat is, to convert the number B3AD to decimal one can split the hexadecimal number into its digits: B (1110), 3 (310), A (1010) and D (1310), and then get the final result by multiplying each decimal representation by 16p, where p is the corresponding hex digit position, counting from right to left, beginning with 0. In this case we have , which is 45997 base 10.\n\nTools for conversion\n\nMost modern computer systems with graphical user interfaces provide a built-in calculator utility, capable of performing conversions between various radices, in general including hexadecimal.\n\nIn Microsoft Windows, the Calculator utility can be set to Scientific mode (called Programmer mode in some versions), which allows conversions between radix 16 (hexadecimal), 10 (decimal), 8 (octal) and 2 (binary), the bases most commonly used by programmers. In Scientific Mode, the on-screen numeric keypad includes the hexadecimal digits A through F, which are active when \"Hex\" is selected. In hex mode, however, the Windows Calculator supports only integers.\n\nReal numbers\n\nRational numbers\n\nAs with other numeral systems, the hexadecimal system can be used to represent rational numbers, although repeating expansions are common since sixteen (10hex) has only a single prime factor (two):\n\nwhere an overline denotes a recurring pattern.\n\nFor any base, 0.1 (or \"1/10\") is always equivalent to one divided by the representation of that base value in its own number system. Thus, whether dividing one by two for binary or dividing one by sixteen for hexadecimal, both of these fractions are written as 0.1. Because the radix 16 is a perfect square (42), fractions expressed in hexadecimal have an odd period much more often than decimal ones, and there are no cyclic numbers (other than trivial single digits). Recurring digits are exhibited when the denominator in lowest terms has a prime factor not found in the radix; thus, when using hexadecimal notation, all fractions with denominators that are not a power of two result in an infinite string of recurring digits (such as thirds and fifths). This makes hexadecimal (and binary) less convenient than decimal for representing rational numbers since a larger proportion lie outside its range of finite representation.\n\nAll rational numbers finitely representable in hexadecimal are also finitely representable in decimal, duodecimal and sexagesimal: that is, any hexadecimal number with a finite number of digits has a finite number of digits when expressed in those other bases. Conversely, only a fraction of those finitely representable in the latter bases are finitely representable in hexadecimal. For example, decimal 0.1 corresponds to the infinite recurring representation 0.199999999999... in hexadecimal. However, hexadecimal is more efficient than bases 12 and 60 for representing fractions with powers of two in the denominator (e.g., decimal one sixteenth is 0.1 in hexadecimal, 0.09 in duodecimal, 0;3,45 in sexagesimal and 0.0625 in decimal).\n\nIrrational numbers\n\nThe table below gives the expansions of some common irrational numbers in decimal and hexadecimal.\n\nPowers\n\nPowers of two have very simple expansions in hexadecimal. The first sixteen powers of two are shown below.\n\nCultural\n\nEtymology\n\nThe word hexadecimal is composed of hexa-, derived from the Greek ἕξ (hex) for six, and -decimal, derived from the Latin for tenth. Webster's Third New International online derives hexadecimal as an alteration of the all-Latin sexadecimal (which appears in the earlier Bendix documentation). The earliest date attested for hexadecimal in Merriam-Webster Collegiate online is 1954, placing it safely in the category of international scientific vocabulary (ISV). It is common in ISV to mix Greek and Latin combining forms freely. The word sexagesimal (for base 60) retains the Latin prefix. Donald Knuth has pointed out that the etymologically correct term is senidenary (or possibly, sedenary), from the Latin term for grouped by 16. (The terms binary, ternary and quaternary are from the same Latin construction, and the etymologically correct terms for decimal and octal arithmetic are denary and octonary, respectively.)Knuth, Donald. (1969). The Art of Computer Programming, Volume 2. . (Chapter 17.) Alfred B. Taylor used senidenary in his mid-1800s work on alternative number bases, although he rejected base 16 because of its \"incommodious number of digits\".A.B. Taylor, [https://books.google.com/books?idX7wLAAAAYAAJ&pg\nPP5 Report on Weights and Measures], Pharmaceutical Association, 8th Annual Session, Boston, Sept. 15, 1859.  See pages and 33 and 41.Alfred B. Taylor, \"Octonary numeration and its application to a system of weights and measures\", [https://books.google.com/books?idKsAUAAAAYAAJ&pg\nPA296 Proc Amer. Phil. Soc. Vol XXIV], Philadelphia, 1887; pages 296-366.  See pages 317 and 322. Schwartzman notes that the expected form from usual Latin phrasing would be sexadecimal, but computer hackers would be tempted to shorten that word to sex.Schwartzman, S. (1994). The Words of Mathematics: an etymological dictionary of mathematical terms used in English. . The etymologically proper Greek term would be hexadecadic / ἑξαδεκαδικός / hexadekadikós (although in Modern Greek, decahexadic / δεκαεξαδικός / dekaexadikos is more commonly used).\n\nUse in Chinese culture\n\nThe traditional Chinese units of weight were base-16. For example, one jīn (斤) in the old system equals sixteen taels. The suanpan (Chinese abacus) could be used to perform hexadecimal calculations.\n\nPrimary numeral system\n\nAs with the duodecimal system, there have been occasional attempts to promote hexadecimal as the preferred numeral system. These attempts often propose specific pronunciation and symbols for the individual numerals. Some proposals unify standard measures so that they are multiples of 16.\n\nAn example of unified standard measures is hexadecimal time, which subdivides a day by 16 so that there are 16 \"hexhours\" in a day.\n\nTransfer encoding\n\nBase16 or hex (not to be confused with Intel HEX and the like) is one of the simplest binary-to-text encodings, which stores each byte as a pair of hexadecimal digits. Many variations of such format are possible, for example either uppercase (A-F) or lowercase (a-f) letters may be used for digits greater than 9; spaces, line breaks or other separators may be added between digit groups of different lengths; header and/or footer with metainformation may be added.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Hexadecimal" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=13263" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In mathematics and computing, hexadecimal (also base , or hex) is a positional numeral system with a radix, or base, of 16. It uses sixteen distinct symbols, most often the symbols 0–9 to represent values zero to nine, and A, B, C, D, E, F (or alternatively a, b, c, d, e, f) to represent values ten to fifteen.\n\nHexadecimal numerals are widely used by computer system designers and programmers. As each hexadecimal digit represents four binary digits (bits), it allows a more human-friendly representation of binary-coded values. One hexadecimal digit represents a nibble (4 bits), which is half of an octet or byte (8 bits). For example, a single byte can have values ranging from 00000000 to 11111111 in binary form, but this may be more conveniently represented as 00 to FF in hexadecimal.\n\nIn a non-programming context, a subscript is typically used to give the radix, for example the decimal value  would be expressed in hexadecimal as .  Several notations are used to support hexadecimal representation of constants in programming languages, usually involving a prefix or suffix.  The prefix \"0x\" is used in C and related languages, where this value might be denoted as 0x.\n\nRepresentation\n\nWritten representation\n\nUsing 0–9 and A–F\n\nIn contexts where the base is not clear, hexadecimal numbers can be ambiguous and confused with numbers expressed in other bases. There are several conventions for expressing values unambiguously. A numerical subscript (itself written in decimal) can give the base explicitly: 15910 is decimal 159; 15916 is hexadecimal 159, which is equal to 34510. Some authors prefer a text subscript, such as 159decimal and 159hex, or 159d and 159h.\n\nIn linear text systems, such as those used in most computer programming environments, a variety of methods have arisen:\n* In URIs (including URLs), character codes are written as hexadecimal pairs prefixed with %: http://www.example.com/name%20with%20spaces where %20 is the space (blank) character, ASCII code point 20 in hex, 32 in decimal.\n* In XML and XHTML, characters can be expressed as hexadecimal numeric character references using the notation &#xcode;, where the x denotes that code is a hex code point (of 1- to 6-digits) assigned to the character in the Unicode standard. Thus ’ represents the right single quotation mark (’), Unicode code point number 2019 in hex, 8217 (thus ’ in decimal).\n* In the Unicode standard, a character value is represented with U+ followed by the hex value, e.g. U+20AC is the Euro sign (€).\n* Color references in HTML, CSS and X Window can be expressed with six hexadecimal digits (two each for the red, green and blue components, in that order) prefixed with #: white, for example, is represented #FFFFFF . CSS allows 3-hexdigit abbreviations with one hexdigit per component: #FA3 abbreviates #FFAA33 (a golden orange: ).\n* *nix (Unix and related) shells, AT&T assembly language and likewise the C programming language, which was designed for Unix (and the syntactic descendants of C – including C++, C#, D, Java, JavaScript, Python and Windows PowerShell) use the prefix 0x for numeric constants represented in hex: 0x5A3. Character and string constants may express character codes in hexadecimal with the prefix \\x followed by two hex digits: '\\x1B' represents the Esc control character; \"\\x1B[0m\\x1B[25;1H\" is a string containing 11 characters (plus a trailing NUL to mark the end of the string) with two embedded Esc characters.The string \"\\x1B[0m\\x1B[25;1H\" specifies the character sequence Esc [ 0 m Esc [ 2 5 ; 1 H Nul. These are the escape sequences used on an ANSI terminal that reset the character set and color, and then move the cursor to line 25. To output an integer as hexadecimal with the printf function family, the format conversion code %X or %x is used.\n* In MIME (e-mail extensions) quoted-printable encoding, characters that cannot be represented as literal ASCII characters are represented by their codes as two hexadecimal digits (in ASCII) prefixed by an equal to sign , as in Espa\nF1a to send \"España\" (Spain). (Hexadecimal F1, equal to decimal 241, is the code number for the lower case n with tilde in the ISO/IEC 8859-1 character set.)\n* In Intel-derived assembly languages and Modula-2, hexadecimal is denoted with a suffixed H or h: FFh or 05A3H. Some implementations require a leading zero when the first hexadecimal digit character is not a decimal digit, so one would write 0FFh instead of FFh\n* Other assembly languages (6502, Motorola), Pascal, Delphi, some versions of BASIC (Commodore), Game Maker Language, Godot and Forth use $ as a prefix: $5A3.\n* Some assembly languages (Microchip) use the notation H'ABCD' (for ABCD16).\n* Ada and VHDL enclose hexadecimal numerals in based \"numeric quotes\": 16#5A3#. For bit vector constants VHDL uses the notation x\"5A3\".The [http://www.eng.auburn.edu/department/ee/mgc/vhdl.html#numbers VHDL MINI-REFERENCE: VHDL IDENTIFIERS, NUMBERS, STRINGS, AND EXPRESSIONS]\n* Verilog represents hexadecimal constants in the form 8'hFF, where 8 is the number of bits in the value and FF is the hexadecimal constant.\n* The Smalltalk language uses the prefix 16r: 16r5A3\n* PostScript and the Bourne shell and its derivatives denote hex with prefix 16#: 16#5A3. For PostScript, binary data (such as image pixels) can be expressed as unprefixed consecutive hexadecimal pairs: AA213FD51B3801043FBC...\n* Common Lisp uses the prefixes #x and #16r. Setting the variables *read-base* and *print-base* to 16 can also used to switch the reader and printer of a Common Lisp system to Hexadecimal number representation for reading and printing numbers. Thus Hexadecimal numbers can be represented without the #x or #16r prefix code, when the input or output base has been changed to 16.\n* MSX BASIC,[http://www.atarimagazines.com/compute/issue56/107_1_MSX_IS_COMING.php MSX is Coming — Part 2: Inside MSX] Compute!, issue 56, January 1985, p. 52 QuickBASIC, FreeBASIC and Visual Basic prefix hexadecimal numbers with &H: &H5A3\n* BBC BASIC and Locomotive BASIC use & for hex.BBC BASIC programs are not fully portable to Microsoft BASIC (without modification) since the latter takes & to prefix octal values. (Microsoft BASIC primarily uses &O to prefix octal, and it uses &H to prefix hexadecimal, but the ampersand alone yields a default interpretation as an octal prefix.\n* TI-89 and 92 series uses a 0h prefix: 0h5A3\n* ALGOL 68 uses the prefix 16r to denote hexadecimal numbers: 16r5a3.  Binary, quaternary (base-4) and octal numbers can be specified similarly.\n* The most common format for hexadecimal on IBM mainframes (zSeries) and midrange computers (IBM System i) running the traditional OS's (zOS, zVSE, zVM, TPF, IBM i) is X'5A3', and is used in Assembler, PL/I, COBOL, JCL, scripts, commands and other places. This format was common on other (and now obsolete) IBM systems as well.  Occasionally quotation marks were used instead of apostrophes.\n* Donald Knuth introduced the use of a particular typeface to represent a particular radix in his book The TeXbook.Donald E. Knuth. The TeXbook (Computers and Typesetting, Volume A). Reading, Massachusetts: Addison–Wesley, 1984. . The [http://www.ctan.org/tex-archive/systems/knuth/tex/texbook.tex source code of the book in TeX] (and a required set of macros [ftp://tug.ctan.org/pub/tex-archive/systems/knuth/lib/manmac.tex CTAN.org]) is available online on CTAN. Hexadecimal representations are written there in a typewriter typeface: 5A3\n* Any IPv6 address can be written as eight groups of four hexadecimal digits (sometimes called hextets), where each group is separated by a colon (:). This, for example, is a valid IPv6 address: 2001:0db8:85a3:0000:0000:8a2e:0370:7334; this can be abbreviated as 2001:db8:85a3::8a2e:370:7334. By contrast, IPv4 addresses are usually written in decimal.\n* Globally unique identifiers are written as thirty-two hexadecimal digits, often in unequal hyphen-separated groupings, for example {3F2504E0-4F89-41D3-9A0C-0305E82C3301}.\n\nThere is no universal convention to use lowercase or uppercase for the letter digits, and each is prevalent or preferred in particular environments by community standards or convention.\n\nHistory of written representations\n\nThe use of the letters A through F to represent the digits above 9 was not universal in the early history of computers.\n* During the 1950s, some installations favored using the digits 0 through 5 with an overline to denote the values 10–15 as , , , ,  and .\n* The SWAC (1950) and Bendix G-15 (1956) computers used the letters U through Z for values 10–15.\n* The ILLIAC I (1952) computer used the letters K, S, N, J, F and L for values 10–15.\n* The Librascope LGP-30 (1956) used the letters F, G, J, K, Q and W for values 10–15. (NB. This somewhat odd sequence was from the next six sequential numeric keyboard codes in the LGP-30's 6-bit character code.)\n* The NEC parametron computer  (1960) used the letters D, G, H, J, K (and possibly V) for values 10–15.\n* New numeric symbols and names were introduced in the Bibi-binary notation by Boby Lapointe in 1968. This notation did not become very popular. \n* Bruce Alan Martin of Brookhaven National Laboratory considered the choice of A–F \"ridiculous\". In a 1968 letter to the editor of the CACM, he proposed an entirely new set of symbols based on the bit locations, which did not gain much acceptance.\n* Soviet programmable calculators Б3-34 (1980) and similar used the symbols \"−\", \"L\", \"C\", \"Г\", \"E\", \" \" (space) for values 10–15 on their displays.\n* Seven-segment display decoder chips used various schemes for outputting values above nine. The Texas Instruments 7446/7447/7448/7449 and 74246/74247/74248/74249 use truncated versions of \"2\", \"3\", \"4\", \"5\" and \"6\" for values 10–14. Value 15 (1111 binary) was blank.\n\nVerbal and digital representations\n\nThere are no traditional numerals to represent the quantities from ten to fifteen — letters are used as a substitute — and most European languages lack non-decimal names for the numerals above ten. Even though English has names for several non-decimal powers (pair for the first binary power, score for the first vigesimal power, dozen, gross and great gross for the first three duodecimal powers), no English name describes the hexadecimal powers (decimal 16, 256, 4096, 65536, ... ). Some people read hexadecimal numbers digit by digit like a phone number, or using the NATO phonetic alphabet, the Joint Army/Navy Phonetic Alphabet, or a similar ad hoc system.\n\nSystems of counting on digits have been devised for both binary and hexadecimal.\nArthur C. Clarke suggested using each finger as an on/off bit, allowing finger counting from zero to 102310 on ten fingers. Another system for counting up to FF16 (25510) is illustrated on the right.\n\nSigns\n\nThe hexadecimal system can express negative numbers the same way as in decimal: −2A to represent −4210 and so on.\n\nHexadecimal can also be used to express the exact bit patterns used in the processor, so a sequence of hexadecimal digits may represent a signed or even a floating point value. This way, the negative number −4210 can be written as FFFF FFD6 in a 32-bit CPU register (in two's-complement), as C228 0000 in a 32-bit FPU register or C045 0000 0000 0000 in a 64-bit FPU register (in the IEEE floating-point standard).\n\nHexadecimal exponential notation\n\nJust as decimal numbers can be represented in exponential notation, so too can hexadecimal numbers.  By convention, the letter P (or p, for \"power\") represents times two raised to the power of, whereas E (or e) serves a similar purpose in decimal as part of the E notation.  The number after the P is decimal and represents the binary exponent.\n\nUsually the number is normalised so that the leading hexadecimal digit is 1 (unless the value is exactly 0).\n\nExample: 1.3DEp42 represents .\n\nHexadecimal exponential notation is required by the IEEE 754-2008 binary floating-point standard.\nThis notation can be used for floating-point literals in the C99 edition of the C programming language.\nUsing the %a or %A conversion specifiers, this notation can be produced by implementations of the printf family of functions following the C99 specification and\nSingle Unix Specification (IEEE Std 1003.1) POSIX standard.\n\nConversion\n\nBinary conversion\n\nMost computers manipulate binary data, but it is difficult for humans to work with the large number of digits for even a relatively small binary number. Although most humans are familiar with the base 10 system, it is much easier to map binary to hexadecimal than to decimal because each hexadecimal digit maps to a whole number of bits (410).\nThis example converts 11112 to base ten. Since each position in a binary numeral can contain either a 1 or a 0, its value may be easily determined by its position from the right:\n* 00012 = 110\n* 00102 = 210\n* 01002 = 410\n* 10002 = 810\nTherefore:\n\nWith little practice, mapping 11112 to F16 in one step becomes easy: see table in Written representation. The advantage of using hexadecimal rather than decimal increases rapidly with the size of the number. When the number becomes large, conversion to decimal is very tedious. However, when mapping to hexadecimal, it is trivial to regard the binary string as 4-digit groups and map each to a single hexadecimal digit.\n\nThis example shows the conversion of a binary number to decimal, mapping each digit to the decimal value, and adding the results.\n\nCompare this to the conversion to hexadecimal, where each group of four digits can be considered independently, and converted directly:\n\nThe conversion from hexadecimal to binary is equally direct.\n\nOther simple conversions\n\nAlthough quaternary (base 4) is little used, it can easily be converted to and from hexadecimal or binary. Each hexadecimal digit corresponds to a pair of quaternary digits and each quaternary digit corresponds to a pair of binary digits. In the above example 5 E B 5 216 = 11 32 23 11 024.\n\nThe octal (base 8) system can also be converted with relative ease, although not quite as trivially as with bases 2 and 4. Each octal digit corresponds to three binary digits, rather than four. Therefore we can convert between octal and hexadecimal via an intermediate conversion to binary followed by regrouping the binary digits in groups of either three or four.\n\nDivision-remainder in source base\n\nAs with all bases there is a simple algorithm for converting a representation of a number to hexadecimal by doing integer division and remainder operations in the source base. In theory, this is possible from any base, but for most humans only decimal and for most computers only binary (which can be converted by far more efficient methods) can be easily handled with this method.\n\nLet d be the number to represent in hexadecimal, and the series hihi−1...h2h1 be the hexadecimal digits representing the number.\n\n# i ← 1\n# hi ← d mod 16\n# d ← (d − hi) / 16\n# If d = 0 (return series hi) else increment i and go to step 2\n\n\"16\" may be replaced with any other base that may be desired.\n\nThe following is a JavaScript implementation of the above algorithm for converting any number to a hexadecimal in String representation. Its purpose is to illustrate the above algorithm. To work with data seriously, however, it is much more advisable to work with bitwise operators.\n\nfunction toHex(d) {\n  var r = d % 16;\n  if (d - r \n 0) {\n    return toChar(r);\n  }\n  return toHex( (d - r)/16 ) + toChar(r);\n}\n\nfunction toChar(n) {\n  const alpha = \"0123456789ABCDEF\";\n  return alpha.charAt(n);\n}\n\nAddition and multiplication\n\nIt is also possible to make the conversion by assigning each place in the source base the hexadecimal representation of its place value and then performing multiplication and addition to get the final representation.\nThat is, to convert the number B3AD to decimal one can split the hexadecimal number into its digits: B (1110), 3 (310), A (1010) and D (1310), and then get the final result by multiplying each decimal representation by 16p, where p is the corresponding hex digit position, counting from right to left, beginning with 0. In this case we have , which is 45997 base 10.\n\nTools for conversion\n\nMost modern computer systems with graphical user interfaces provide a built-in calculator utility, capable of performing conversions between various radices, in general including hexadecimal.\n\nIn Microsoft Windows, the Calculator utility can be set to Scientific mode (called Programmer mode in some versions), which allows conversions between radix 16 (hexadecimal), 10 (decimal), 8 (octal) and 2 (binary), the bases most commonly used by programmers. In Scientific Mode, the on-screen numeric keypad includes the hexadecimal digits A through F, which are active when \"Hex\" is selected. In hex mode, however, the Windows Calculator supports only integers.\n\nReal numbers\n\nRational numbers\n\nAs with other numeral systems, the hexadecimal system can be used to represent rational numbers, although repeating expansions are common since sixteen (10hex) has only a single prime factor (two):\n\nwhere an overline denotes a recurring pattern.\n\nFor any base, 0.1 (or \"1/10\") is always equivalent to one divided by the representation of that base value in its own number system. Thus, whether dividing one by two for binary or dividing one by sixteen for hexadecimal, both of these fractions are written as 0.1. Because the radix 16 is a perfect square (42), fractions expressed in hexadecimal have an odd period much more often than decimal ones, and there are no cyclic numbers (other than trivial single digits). Recurring digits are exhibited when the denominator in lowest terms has a prime factor not found in the radix; thus, when using hexadecimal notation, all fractions with denominators that are not a power of two result in an infinite string of recurring digits (such as thirds and fifths). This makes hexadecimal (and binary) less convenient than decimal for representing rational numbers since a larger proportion lie outside its range of finite representation.\n\nAll rational numbers finitely representable in hexadecimal are also finitely representable in decimal, duodecimal and sexagesimal: that is, any hexadecimal number with a finite number of digits has a finite number of digits when expressed in those other bases. Conversely, only a fraction of those finitely representable in the latter bases are finitely representable in hexadecimal. For example, decimal 0.1 corresponds to the infinite recurring representation 0.199999999999... in hexadecimal. However, hexadecimal is more efficient than bases 12 and 60 for representing fractions with powers of two in the denominator (e.g., decimal one sixteenth is 0.1 in hexadecimal, 0.09 in duodecimal, 0;3,45 in sexagesimal and 0.0625 in decimal).\n\nIrrational numbers\n\nThe table below gives the expansions of some common irrational numbers in decimal and hexadecimal.\n\nPowers\n\nPowers of two have very simple expansions in hexadecimal. The first sixteen powers of two are shown below.\n\nCultural\n\nEtymology\n\nThe word hexadecimal is composed of hexa-, derived from the Greek ἕξ (hex) for six, and -decimal, derived from the Latin for tenth. Webster's Third New International online derives hexadecimal as an alteration of the all-Latin sexadecimal (which appears in the earlier Bendix documentation). The earliest date attested for hexadecimal in Merriam-Webster Collegiate online is 1954, placing it safely in the category of international scientific vocabulary (ISV). It is common in ISV to mix Greek and Latin combining forms freely. The word sexagesimal (for base 60) retains the Latin prefix. Donald Knuth has pointed out that the etymologically correct term is senidenary (or possibly, sedenary), from the Latin term for grouped by 16. (The terms binary, ternary and quaternary are from the same Latin construction, and the etymologically correct terms for decimal and octal arithmetic are denary and octonary, respectively.)Knuth, Donald. (1969). The Art of Computer Programming, Volume 2. . (Chapter 17.) Alfred B. Taylor used senidenary in his mid-1800s work on alternative number bases, although he rejected base 16 because of its \"incommodious number of digits\".A.B. Taylor, [https://books.google.com/books?idX7wLAAAAYAAJ&pg\nPP5 Report on Weights and Measures], Pharmaceutical Association, 8th Annual Session, Boston, Sept. 15, 1859.  See pages and 33 and 41.Alfred B. Taylor, \"Octonary numeration and its application to a system of weights and measures\", [https://books.google.com/books?idKsAUAAAAYAAJ&pg\nPA296 Proc Amer. Phil. Soc. Vol XXIV], Philadelphia, 1887; pages 296-366.  See pages 317 and 322. Schwartzman notes that the expected form from usual Latin phrasing would be sexadecimal, but computer hackers would be tempted to shorten that word to sex.Schwartzman, S. (1994). The Words of Mathematics: an etymological dictionary of mathematical terms used in English. . The etymologically proper Greek term would be hexadecadic / ἑξαδεκαδικός / hexadekadikós (although in Modern Greek, decahexadic / δεκαεξαδικός / dekaexadikos is more commonly used).\n\nUse in Chinese culture\n\nThe traditional Chinese units of weight were base-16. For example, one jīn (斤) in the old system equals sixteen taels. The suanpan (Chinese abacus) could be used to perform hexadecimal calculations.\n\nPrimary numeral system\n\nAs with the duodecimal system, there have been occasional attempts to promote hexadecimal as the preferred numeral system. These attempts often propose specific pronunciation and symbols for the individual numerals. Some proposals unify standard measures so that they are multiples of 16.\n\nAn example of unified standard measures is hexadecimal time, which subdivides a day by 16 so that there are 16 \"hexhours\" in a day.\n\nTransfer encoding\n\nBase16 or hex (not to be confused with Intel HEX and the like) is one of the simplest binary-to-text encodings, which stores each byte as a pair of hexadecimal digits. Many variations of such format are possible, for example either uppercase (A-F) or lowercase (a-f) letters may be used for digits greater than 9; spaces, line breaks or other separators may be added between digit groups of different lengths; header and/or footer with metainformation may be added. Hexadecimal. http://en.wikipedia.org/?curid=13263."
  }
}
