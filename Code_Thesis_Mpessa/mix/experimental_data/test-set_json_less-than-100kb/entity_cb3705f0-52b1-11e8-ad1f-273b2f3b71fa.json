{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=4079",
  "eid" : "cb3705f0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778420687,
  "textBody" : "In computational complexity theory, BPP, which stands for bounded-error probabilistic polynomial time is the class of decision problems solvable by a probabilistic Turing machine in polynomial time with an error probability bounded away from 1/2 for all instances.\nBPP is one of the largest practical classes of problems, meaning most problems of interest in BPP have efficient probabilistic algorithms that can be run quickly on real modern machines.  BPP also contains P, the class of problems solvable in polynomial time with a deterministic machine, since a deterministic machine is a special case of a probabilistic machine.\n\nInformally, a problem is in BPP if there is an algorithm for it that has the following properties:\n*It is allowed to flip coins and make random decisions\n*It is guaranteed to run in polynomial time\n*On any given run of the algorithm, it has a probability of at most 1/3 of giving the wrong answer, whether the answer is YES or NO.\n\nDefinition \n\nA language L is in BPP if and only if there exists a probabilistic Turing machine M, such that\n* M runs for polynomial time on all inputs\n* For all x in L, M outputs 1 with probability greater than or equal to \n* For all x not in L, M outputs 1 with probability less than or equal to \nUnlike the complexity class ZPP, the machine M is required to run for polynomial time on all inputs, regardless of the outcome of the random coin flips.\n\nAlternatively, BPP can be defined using only deterministic Turing machines. A language L is in BPP if and only if there exists a polynomial p and deterministic Turing machine M, such that\n* M runs for polynomial time on all inputs\n* For all x in L, the fraction of strings y of length p(|x|) which satisfy  is greater than or equal to \n* For all x not in L, the fraction of strings y of length p(|x|) which satisfy  is less than or equal to \nIn this definition, the string y corresponds to the output of the random coin flips that the probabilistic Turing machine would have made. For some applications this definition is preferable since it does not mention probabilistic Turing machines.\n\nIn practice, an error probability of  might not be acceptable, however, the choice of  in the definition is arbitrary. It can be any constant between 0 and  (exclusive) and the set BPP will be unchanged. It does not even have to be constant: the same class of problems is defined by allowing error as high as  − n−c on the one hand, or requiring error as small as 2−nc on the other hand, where c is any positive constant, and n is the length of input. The idea is that there is a probability of error, but if the algorithm is run many times, the chance that the majority of the runs are wrong drops off exponentially as a consequence of the Chernoff bound.Valentine Kabanets, [http://www.cs.sfu.ca/~kabanets/cmpt710/lec16.pdf CMPT 710 - Complexity Theory: Lecture 16], October 28, 2003 This makes it possible to create a highly accurate algorithm by merely running the algorithm several times and taking a \"majority vote\" of the answers. For example, if one defined the class with the restriction that the algorithm can be wrong with probability at most , this would result in the same class of problems.\n\nProblems \n\nBesides the problems in P, which are obviously in BPP, many problems were known to be in BPP but not known to be in P. The number of such problems is decreasing, and it is conjectured that P = BPP.\n\nFor a long time, one of the most famous problems that was known to be in BPP but not known to be in P was the problem of determining whether a given number is prime. However, in the 2002 paper PRIMES is in P, Manindra Agrawal and his students Neeraj Kayal and Nitin Saxena found a deterministic polynomial-time algorithm for this problem, thus showing that it is in P.\n\nAn important example of a problem in BPP (in fact in co-RP) still not known to be in P is polynomial identity testing, the problem of determining whether a polynomial is identically equal to the zero polynomial, when you have access to the value of the polynomial for any given input, but not to the coefficients. In other words, is there an assignment of values to the variables such that when a nonzero polynomial is evaluated on these values, the result is nonzero? It suffices to choose each variable's value uniformly at random from a finite subset of at least d values to achieve bounded error probability, where d is the total degree of the polynomial.Madhu Sudan and Shien Jin Ong. Massachusetts Institute of Technology: 6.841/18.405J Advanced Complexity Theory: [http://people.csail.mit.edu/madhu/ST03/scribe/lect06.pdf Lecture 6: Randomized Algorithms, Properties of BPP]. February 26, 2003.\n\nRelated classes \n\nIf the access to randomness is removed from the definition of BPP, we get the complexity class P. In the definition of the class, if we replace the ordinary Turing machine with a quantum computer, we get the class BQP.\n\nAdding postselection to BPP, or allowing computation paths to have different lengths, gives the class BPPpath.[https://complexityzoo.uwaterloo.ca/Complexity_Zoo:B#bpppath BPPpath] in [https://complexityzoo.uwaterloo.ca/Complexity_Zoo Complexity Zoo] BPPpath is known to contain NP, and it is contained in its quantum counterpart PostBQP.\n\nA Monte Carlo algorithm is a randomized algorithm which is likely to be correct. Problems in the class BPP have Monte Carlo algorithms with polynomial bounded running time. This is compared to a Las Vegas algorithm which is a randomized algorithm which either outputs the correct answer, or outputs \"fail\" with low probability. Las Vegas algorithms with polynomial bound running times are used to define the class ZPP. Alternatively, ZPP contains probabilistic algorithms that are always correct and have expected polynomial running time. This is weaker than saying it is a polynomial time algorithm, since it may run for super-polynomial time, but with very low probability.\n\nComplexity-theoretic properties \n\nIt is known that BPP is closed under complement; that is, BPP co-BPP. BPP is low for itself, meaning that a BPP machine with the power to solve BPP problems instantly (a BPP oracle machine) is not any more powerful than the machine without this extra power. In symbols, BPPBPP \n BPP.\n\nThe relationship between BPP and NP is unknown: it is not known whether BPP is a subset of NP, NP is a subset of BPP or neither. If NP is contained in BPP, which is considered unlikely since it would imply practical solutions for NP-complete problems, then NP = RP and PH ⊆ BPP. Lance Fortnow and Bill Gasarch, [http://weblog.fortnow.com/2005/12/pulling-out-quantumness.html Pulling Out The Quantumness],  December 20, 2005\n\nIt is known that RP is a subset of BPP, and BPP is a subset of PP.  It is not known whether those two are strict subsets, since we don't even know if P is a strict subset of PSPACE. BPP is contained in the second level of the polynomial hierarchy and therefore it is contained in PH. More precisely, the Sipser–Lautemann theorem states that \\mathsf{BPP} \\subseteq \\Sigma_2 \\cap \\Pi_2 . As a result, P NP leads to P \n BPP since PH collapses to P in this case. Thus either P = BPP or P ≠ NP or both.\n\nAdleman's theorem states that membership in any language in BPP can be determined by a family of polynomial-size Boolean circuits, which means BPP is contained in P/poly. Indeed, as a consequence of the proof of this fact, every BPP algorithm operating on inputs of bounded length can be derandomized into a deterministic algorithm using a fixed string of random bits. Finding this string may be expensive, however.\nSome weak separation results for Monte Carlo time classes were proven by , see also \n.\n\nClosure properties \n\nThe class BPP is closed under complementation, union and intersection.\n\nRelativization \n\nRelative to oracles, we know that there exist oracles A and B, such that PA BPPA and PB ≠ BPPB. Moreover, relative to a random oracle with probability 1,  P \n BPP and BPP is strictly contained in NP and co-NP.\n\nThere is even an oracle in which BPPEXPNP (and hence P which can be iteratively constructed as follows.  For a fixed ENP (relativized) complete problem, the oracle will give correct answers with high probability if queried with the problem instance followed by a random string of length kn (n is instance length; k is an appropriate small constant).  Start with n\n1.  For every instance of the problem of length n fix oracle answers (see lemma below) to fix the instance output.  Next, provide the instance outputs for queries consisting of the instance followed by kn-length string, and then treat output for queries of length ≤(k+1)n as fixed, and proceed with instances of length n+1.\n\nLemma: Given a problem (specifically, an oracle machine code and time constraint) in relativized ENP, for every partially constructed oracle and input of length n, the output can be fixed by specifying 2O(n) oracle answers.\nProof: The machine is simulated, and the oracle answers (that are not already fixed) are fixed step-by-step.  There is at most one oracle query per deterministic computation step.  For the relativized NP oracle, if possible fix the output to be yes by choosing a computation path and fixing the answers of the base oracle; otherwise no fixing is necessary, and either way there is at most 1 answer of the base oracle per step.  Since there are 2O(n) steps, the lemma follows.\n\nThe lemma ensures that (for a large enough k), it is possible to do the construction while leaving enough strings for the relativized ENP answers.  Also, we can ensure that for the relativized ENP, linear time suffices, even for function problems (if given a function oracle and linear output size) and with exponentially small (with linear exponent) error probability.  Also, this construction is effective in that given an arbitrary oracle A we can arrange the oracle B to have PA≤PB and EXPNPAEXPNPB\nBPPB.  Also, for a ZPPEXP oracle (and hence ZPP\nBPP=EXP \n\\mathsf{i.o.-SUBEXP} = \\bigcap\\nolimits_{\\varepsilon>0} \\mathsf{i.o.-DTIME} \\left (2^{n^\\varepsilon} \\right). \nThe class i.o.-SUBEXP, which stands for infinitely often SUBEXP, contains problems which have sub-exponential time algorithms for infinitely many input sizes. They also showed that P = BPP if the exponential-time hierarchy, which is defined in terms of the polynomial hierarchy and E as EPH, collapses to E; however, note that the exponential-time hierarchy is usually conjectured not to collapse.\n\nRussell Impagliazzo and Avi Wigderson showed that if any problem in E, where \n\\mathsf{E} = \\mathsf{DTIME} \\left( 2^{O(n)} \\right), \nhas circuit complexity 2Ω(n) then P BPP.Russell Impagliazzo and Avi Wigderson (1997). \"P \n BPP if E requires exponential circuits: Derandomizing the XOR Lemma\". Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing, pp. 220–229.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "BPP (complexity)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=4079" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In computational complexity theory, BPP, which stands for bounded-error probabilistic polynomial time is the class of decision problems solvable by a probabilistic Turing machine in polynomial time with an error probability bounded away from 1/2 for all instances.\nBPP is one of the largest practical classes of problems, meaning most problems of interest in BPP have efficient probabilistic algorithms that can be run quickly on real modern machines.  BPP also contains P, the class of problems solvable in polynomial time with a deterministic machine, since a deterministic machine is a special case of a probabilistic machine.\n\nInformally, a problem is in BPP if there is an algorithm for it that has the following properties:\n*It is allowed to flip coins and make random decisions\n*It is guaranteed to run in polynomial time\n*On any given run of the algorithm, it has a probability of at most 1/3 of giving the wrong answer, whether the answer is YES or NO.\n\nDefinition \n\nA language L is in BPP if and only if there exists a probabilistic Turing machine M, such that\n* M runs for polynomial time on all inputs\n* For all x in L, M outputs 1 with probability greater than or equal to \n* For all x not in L, M outputs 1 with probability less than or equal to \nUnlike the complexity class ZPP, the machine M is required to run for polynomial time on all inputs, regardless of the outcome of the random coin flips.\n\nAlternatively, BPP can be defined using only deterministic Turing machines. A language L is in BPP if and only if there exists a polynomial p and deterministic Turing machine M, such that\n* M runs for polynomial time on all inputs\n* For all x in L, the fraction of strings y of length p(|x|) which satisfy  is greater than or equal to \n* For all x not in L, the fraction of strings y of length p(|x|) which satisfy  is less than or equal to \nIn this definition, the string y corresponds to the output of the random coin flips that the probabilistic Turing machine would have made. For some applications this definition is preferable since it does not mention probabilistic Turing machines.\n\nIn practice, an error probability of  might not be acceptable, however, the choice of  in the definition is arbitrary. It can be any constant between 0 and  (exclusive) and the set BPP will be unchanged. It does not even have to be constant: the same class of problems is defined by allowing error as high as  − n−c on the one hand, or requiring error as small as 2−nc on the other hand, where c is any positive constant, and n is the length of input. The idea is that there is a probability of error, but if the algorithm is run many times, the chance that the majority of the runs are wrong drops off exponentially as a consequence of the Chernoff bound.Valentine Kabanets, [http://www.cs.sfu.ca/~kabanets/cmpt710/lec16.pdf CMPT 710 - Complexity Theory: Lecture 16], October 28, 2003 This makes it possible to create a highly accurate algorithm by merely running the algorithm several times and taking a \"majority vote\" of the answers. For example, if one defined the class with the restriction that the algorithm can be wrong with probability at most , this would result in the same class of problems.\n\nProblems \n\nBesides the problems in P, which are obviously in BPP, many problems were known to be in BPP but not known to be in P. The number of such problems is decreasing, and it is conjectured that P = BPP.\n\nFor a long time, one of the most famous problems that was known to be in BPP but not known to be in P was the problem of determining whether a given number is prime. However, in the 2002 paper PRIMES is in P, Manindra Agrawal and his students Neeraj Kayal and Nitin Saxena found a deterministic polynomial-time algorithm for this problem, thus showing that it is in P.\n\nAn important example of a problem in BPP (in fact in co-RP) still not known to be in P is polynomial identity testing, the problem of determining whether a polynomial is identically equal to the zero polynomial, when you have access to the value of the polynomial for any given input, but not to the coefficients. In other words, is there an assignment of values to the variables such that when a nonzero polynomial is evaluated on these values, the result is nonzero? It suffices to choose each variable's value uniformly at random from a finite subset of at least d values to achieve bounded error probability, where d is the total degree of the polynomial.Madhu Sudan and Shien Jin Ong. Massachusetts Institute of Technology: 6.841/18.405J Advanced Complexity Theory: [http://people.csail.mit.edu/madhu/ST03/scribe/lect06.pdf Lecture 6: Randomized Algorithms, Properties of BPP]. February 26, 2003.\n\nRelated classes \n\nIf the access to randomness is removed from the definition of BPP, we get the complexity class P. In the definition of the class, if we replace the ordinary Turing machine with a quantum computer, we get the class BQP.\n\nAdding postselection to BPP, or allowing computation paths to have different lengths, gives the class BPPpath.[https://complexityzoo.uwaterloo.ca/Complexity_Zoo:B#bpppath BPPpath] in [https://complexityzoo.uwaterloo.ca/Complexity_Zoo Complexity Zoo] BPPpath is known to contain NP, and it is contained in its quantum counterpart PostBQP.\n\nA Monte Carlo algorithm is a randomized algorithm which is likely to be correct. Problems in the class BPP have Monte Carlo algorithms with polynomial bounded running time. This is compared to a Las Vegas algorithm which is a randomized algorithm which either outputs the correct answer, or outputs \"fail\" with low probability. Las Vegas algorithms with polynomial bound running times are used to define the class ZPP. Alternatively, ZPP contains probabilistic algorithms that are always correct and have expected polynomial running time. This is weaker than saying it is a polynomial time algorithm, since it may run for super-polynomial time, but with very low probability.\n\nComplexity-theoretic properties \n\nIt is known that BPP is closed under complement; that is, BPP co-BPP. BPP is low for itself, meaning that a BPP machine with the power to solve BPP problems instantly (a BPP oracle machine) is not any more powerful than the machine without this extra power. In symbols, BPPBPP \n BPP.\n\nThe relationship between BPP and NP is unknown: it is not known whether BPP is a subset of NP, NP is a subset of BPP or neither. If NP is contained in BPP, which is considered unlikely since it would imply practical solutions for NP-complete problems, then NP = RP and PH ⊆ BPP. Lance Fortnow and Bill Gasarch, [http://weblog.fortnow.com/2005/12/pulling-out-quantumness.html Pulling Out The Quantumness],  December 20, 2005\n\nIt is known that RP is a subset of BPP, and BPP is a subset of PP.  It is not known whether those two are strict subsets, since we don't even know if P is a strict subset of PSPACE. BPP is contained in the second level of the polynomial hierarchy and therefore it is contained in PH. More precisely, the Sipser–Lautemann theorem states that \\mathsf{BPP} \\subseteq \\Sigma_2 \\cap \\Pi_2 . As a result, P NP leads to P \n BPP since PH collapses to P in this case. Thus either P = BPP or P ≠ NP or both.\n\nAdleman's theorem states that membership in any language in BPP can be determined by a family of polynomial-size Boolean circuits, which means BPP is contained in P/poly. Indeed, as a consequence of the proof of this fact, every BPP algorithm operating on inputs of bounded length can be derandomized into a deterministic algorithm using a fixed string of random bits. Finding this string may be expensive, however.\nSome weak separation results for Monte Carlo time classes were proven by , see also \n.\n\nClosure properties \n\nThe class BPP is closed under complementation, union and intersection.\n\nRelativization \n\nRelative to oracles, we know that there exist oracles A and B, such that PA BPPA and PB ≠ BPPB. Moreover, relative to a random oracle with probability 1,  P \n BPP and BPP is strictly contained in NP and co-NP.\n\nThere is even an oracle in which BPPEXPNP (and hence P which can be iteratively constructed as follows.  For a fixed ENP (relativized) complete problem, the oracle will give correct answers with high probability if queried with the problem instance followed by a random string of length kn (n is instance length; k is an appropriate small constant).  Start with n\n1.  For every instance of the problem of length n fix oracle answers (see lemma below) to fix the instance output.  Next, provide the instance outputs for queries consisting of the instance followed by kn-length string, and then treat output for queries of length ≤(k+1)n as fixed, and proceed with instances of length n+1.\n\nLemma: Given a problem (specifically, an oracle machine code and time constraint) in relativized ENP, for every partially constructed oracle and input of length n, the output can be fixed by specifying 2O(n) oracle answers.\nProof: The machine is simulated, and the oracle answers (that are not already fixed) are fixed step-by-step.  There is at most one oracle query per deterministic computation step.  For the relativized NP oracle, if possible fix the output to be yes by choosing a computation path and fixing the answers of the base oracle; otherwise no fixing is necessary, and either way there is at most 1 answer of the base oracle per step.  Since there are 2O(n) steps, the lemma follows.\n\nThe lemma ensures that (for a large enough k), it is possible to do the construction while leaving enough strings for the relativized ENP answers.  Also, we can ensure that for the relativized ENP, linear time suffices, even for function problems (if given a function oracle and linear output size) and with exponentially small (with linear exponent) error probability.  Also, this construction is effective in that given an arbitrary oracle A we can arrange the oracle B to have PA≤PB and EXPNPAEXPNPB\nBPPB.  Also, for a ZPPEXP oracle (and hence ZPP\nBPP=EXP \n\\mathsf{i.o.-SUBEXP} = \\bigcap\\nolimits_{\\varepsilon>0} \\mathsf{i.o.-DTIME} \\left (2^{n^\\varepsilon} \\right). \nThe class i.o.-SUBEXP, which stands for infinitely often SUBEXP, contains problems which have sub-exponential time algorithms for infinitely many input sizes. They also showed that P = BPP if the exponential-time hierarchy, which is defined in terms of the polynomial hierarchy and E as EPH, collapses to E; however, note that the exponential-time hierarchy is usually conjectured not to collapse.\n\nRussell Impagliazzo and Avi Wigderson showed that if any problem in E, where \n\\mathsf{E} = \\mathsf{DTIME} \\left( 2^{O(n)} \\right), \nhas circuit complexity 2Ω(n) then P BPP.Russell Impagliazzo and Avi Wigderson (1997). \"P \n BPP if E requires exponential circuits: Derandomizing the XOR Lemma\". Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing, pp. 220–229. BPP (complexity). http://en.wikipedia.org/?curid=4079."
  }
}
