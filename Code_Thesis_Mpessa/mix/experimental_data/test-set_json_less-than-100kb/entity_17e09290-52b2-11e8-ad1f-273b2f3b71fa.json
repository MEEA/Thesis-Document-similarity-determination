{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=14801",
  "eid" : "17e09290-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778549305,
  "textBody" : "Icon is a very high-level programming language featuring goal-directed execution and many facilities for managing strings and textual patterns. It is related to SNOBOL and SL5, string processing languages. Icon is not object-oriented, but an object-oriented extension called Idol was developed in 1996 which eventually became Unicon.\n\nBasic syntax\n\nThe Icon language is derived from the ALGOL-class of structured programming languages, and thus has syntax similar to C or Pascal. Icon is most similar to Pascal, using := syntax for assignments, the procedure keyword and similar syntax. On the other hand, Icon uses C-style brackets for structuring execution groups, and programs start by running a procedure called \"main\".\n\nIn many ways Icon also shares features with most scripting languages (as well as SNOBOL and SL5, from which they were taken): variables do not have to be declared, types are cast automatically, and numbers can be converted to strings and back automatically. Another feature common to many scripting languages, but not all, is the lack of a line-ending character; in Icon, lines not ended by a semicolon get ended by an implied semicolon if it makes sense.\n\nProcedures are the basic building blocks of Icon programs. Although they use Pascal naming, they work more like C functions and can return values; there is no function keyword in Icon.\n\n procedure doSomething(aString)\n   write(aString)\n end\n\nGoal-directed execution\n\nOne of Icon's key concepts is that control structures are based on the \"success\" or \"failure\" of expressions, rather than on boolean logic, as in most other programming languages. Under this model, simple comparisons like if a  do not mean \"if the operations to the right evaluate to true\" as they would under most languages; instead it means something more like \"if the operations to the right succeed\". In this case the if a , a common type of comparison that in most languages must be written as a conjunction of two inequalities like if a .\n\nThe utility of this concept becomes much clearer when you consider real-world examples. Since Icon uses success or failure for all flow control, this simple code:\n\nif a := read() then write(a)\n\nwill copy one line of standard input to standard output. This code will work even if the read() causes an error, for instance, if the file does not exist. In that case the statement a := read() will fail, and write will simply not be called.\n\nSuccess and failure are passed \"up\" through functions, meaning that a failure inside a nested function will cause the functions calling it to fail as well. For instance, we can write a program to copy an entire input file to output in a single line:\n\nwhile write(read())\n\nWhen the read() command fails, at the end of file for instance, the failure will be passed up the chain, and write() will fail as well. The while, being a control structure, stops on failure, meaning it stops when the file is empty. For comparison, consider a similar example written in pseudocode (using syntax close to C++ and derived languages such as Java):\n\n try {\n   while ((a read()) !\n EOF) {\n     write(a);\n   }\n } catch (Exception e) {\n   // do nothing, exit the loop\n }\n\nThis case needs two comparisons: one for end of file (EOF) and another for all other errors. Since Java does not allow errors to be compared as logic elements, as under Icon, the lengthy try/catch syntax must be used instead. Try blocks also impose a performance penalty for simply using them, even if no error occurs, a distributed cost that Icon avoids.\n\nIcon refers to this concept as goal-directed execution, referring to the way that execution continues until some goal is reached. In the example above the goal is to read the entire file; the read command continues to succeed while there is more information to be read, and fails when there isn't. The goal is thus coded directly in the language, instead of using statements checking return codes or similar constructs.\n\nGenerators\n\nExpressions in Icon often return a single value, for instance, x  will evaluate and succeed if the value of x is less than 5, or else fail. However several of the examples below rely on the fact that many expressions do not immediately return success or failure, returning values in the meantime. This drives the examples with every and to; every causes to to continue to return values until it fails.\n\nThis is a key concept in Icon, known as generators. Generators drive much of the loop functionality in the language, but do so more directly; the programmer does not write a loop and then pull out and compare values, Icon will do all of this for you.\n\nWithin the parlance of Icon, the evaluation of an expression or function results in a result sequence. A result sequence contains all the possible values that can be generated by the expression or function. When the result sequence is exhausted (e.g. there are no more values within the result sequence), the expression or function fails. Iteration over the result sequence is achieved either implicitly via Icon's goal directed evaluation or explicitly via the every clause.\n\nIcon includes several generator-builders. The alternator syntax allows a series of items to be generated in sequence until one fails:\n\n 1 | \"hello\" | x \ncan generate \"1\", \"hello\", and \"5\" if x is less than 5. Alternators can be read as \"or\" in many cases, for instance:\n\n if y \n\nwill write out the value of y if it is smaller than x or 5. Internally Icon checks every value from left to right until one succeeds or the list empties and it returns a failure. Remember that functions will not be called unless the calls within do not fail, so this example can be shortened to:\n\n write(\"y=\", (x | 5) > y)\n\nAnother simple generator is the to, which generates lists of integers; every write(1 to 10) will do exactly what it seems to. The bang syntax generates every item of a list; every write(!aString) will output each character of aString on a new line.\n\nTo demonstrate the power of this concept, consider string operations. Most languages include a function known as find or indexOf that returns the location of a string within another. Consider:\n\n s = \"All the world's a stage. And all the men and women merely players\";\n i = indexOf(\"the\", s)\n\nThis code will return 4, the position of the first occurrence of the word \"the\". To get the next instance of \"the\" an alternate form must be used,\n\n i = indexOf(\"the\", s, 5)\nthe 5 at the end saying it should look from position 5 on. In order to extract all the occurrences of \"the\", a loop must be used...\n\n s = \"All the world's a stage. And all the men and women merely players\";\n i = indexOf(\"the\", s)\n while i != -1 {\n   write(i);\n   i =  indexOf(\"the\", s, i+1);\n }\n\nUnder Icon the find function is a generator, and will return the next instance of the string each time it is resumed before finally failing after it passes the end of the string. The same code under Icon can be written:\n\n s := \"All the world's a stage. And all the men and women merely players\"\n every write(find(\"the\",s))\n\nfind will return the index of the next instance of \"the\" each time it is resumed by every, eventually passing the end of the string and failing. As in the prior example, this will cause write to fail, and the (one-line) every loop to exit.\n\nOf course there are times where you deliberately want to find a string after some point in input, for instance, you might be scanning a text file containing data in multiple columns. Goal-directed execution works here as well, and can be used this way:\n\n write(5 \n\nThe position will only be returned if \"the\" appears after position 5, the comparison will fail otherwise, passing that failure to write() as before. There is one small \"trick\" to this code that needs to be considered: comparisons return the right-hand result, so it is important to put the find on the right-hand side of the comparison. If the 5 were placed on the right, 5 would be written.\n\nIcon adds several control structures for looping through\ngenerators. The every operator is similar to while, looping through every item returned by a generator and exiting on failure:\n\n  every k := i to j do\n   write(someFunction(k))\n\nWhy use every instead of a while loop in this case?\nBecause while re-evaluates the first result,\nbut every produces all results.\nThe every syntax actually injects values into the function in a fashion similar to blocks under Smalltalk. For instance, the above loop can be re-written this way:\n\n every write(someFunction(i to j))\n\nUsers can build new generators easily using the suspend keyword:\n\n procedure findOnlyOdd(pattern, theString)\n   every i := find(pattern, theString) do\n     if i % 2 = 1 then suspend i\n end\n\nThis example loops over theString using find to look for pattern. When one is found, and the position is odd, the location is returned from the function with suspend. Unlike return, suspend writes down where it is in the internal generators as well, allowing it to pick up where it left off on the next iteration.\n\nStrings\n\nIn keeping with its script-like functionality, Icon adds a number of features to make working with strings easier. Most notable among these is the scanning system, which repeatedly calls functions on a string:\n\ns ? write(find(\"the\"))\n\nis a short form of the examples shown earlier. In this case the subject of the find function is placed outside the parameters in front of the question-mark. Icon functions are deliberately (as opposed to automatically) written to identify the subject in parameter lists and allow them to be pulled out in this fashion.\n\nSubstrings can be extracted from a string by using a range specification within brackets. A range specification can return a point to a single character, or a slice of the string. Strings can be indexed from either the right or the left. Positions within a string are defined to be between the characters 1A2B3C4 and can be specified from the right −3A−2B−1C0\n\nFor example,\n\n \"Wikipedia\"[1]     \n> \"W\"\n \"Wikipedia\"[3]     \n> \"k\"\n \"Wikipedia\"[0]     \n> \"a\"\n \"Wikipedia\"[1:3]   \n> \"Wi\"\n \"Wikipedia\"[-2:0]  \n> \"ia\"\n \"Wikipedia\"[2+:3]  \n> \"iki\"\n\nWhere the last example shows using a length instead of an ending position\n\nThe subscripting specification can be used as a lvalue within an expression. This can be used to insert strings into another string or delete parts of a string. For example,\n\n    s := \"abc\"\n    s[2] := \"123\"\n    s now has a value of \"a123c\"\n    s := \"abcdefg\"\n    s[3:5] := \"ABCD\"\n    s now has a value of \"abABCDefg\"\n    s := \"abcdefg\"\n    s[3:5] := \"\"\n    s now has a value of \"abefg\"\n\nAs noted above, Icon's subscript indices are between the elements. Given the string s := \"ABCDEFG\", the indexes are: 1A2B3C4D5E6F7G8. The slice s[3:5] is the string between the indices 3 and 5, which is the string \"CD\".\n\nOther structures\n\nIcon also allows the user to easily construct their own lists (or arrays):\n\naCat := [\"muffins\", \"tabby\", 2002, 8]\n\nThe items within a list can be of any sort, including other structures. To quickly build larger lists, Icon includes the list generator; i := list(10, \"word\") generates a list containing 10 copies of \"word\".\n\nLike arrays in other languages, Icon allows items to be looked up by position, e.g., weight := aCat[4]. As with strings, the indices are between the elements, and a slice of a list can be obtained by specifying the range, e.g., aCat[2:4] produces the list [\"tabby\",2002]. Unlike strings, a slice using a range cannot be a lvalue.\n\nThe bang-syntax, e.g., every write(!aCat), will print out four lines, each with one element.\n\nIcon includes stack-like functions, push and pop to allow them to form the basis of stacks and queues.\n\nIcon also includes functionality for sets and tables (known as hashes, associative arrays, dictionaries, etc.):\n\n symbols := table(0)\n symbols[\"there\"] := 1\n symbols[\"here\"] := 2\n\nThis code creates a table that will use zero as the default value of any unknown key. It then adds two items into it, with the keys \"there\" and \"here\", and values 1 and 2.\n\nString scanning\n\nOne of the powerful features of Icon is string scanning. The scan string operator, ? saves the current string scanning environment and creates a new string scanning environment. The string scanning environment consists of two keyword variables, &subject and &pos. Where &subject is the string being scanned, and &pos is the cursor or current position within the subject string.\n\nFor example,\n\n  s := \"this is a string\"\n  s ? write(\"subject[\",&subject,\"] pos\n[\",&pos,\"]\")\n\nwould produce\n\nsubject[this is a string] pos\n[1]\n\nBuilt-in and user-defined functions can be used to move around within the string being scanned. Many of the built-in functions will default to &subject and &pos (for example the find function). The following, for example, will write all blank delimited \"words\" in a string.\n\n  s := \"this is a string\"\n  s ? {                               # Establish string scanning environment\n      while not pos(0) do  {          # Test for end of string\n          tab(many(' '))              # Skip past any blanks\n          word := tab(upto(' ') | 0)  # the next word is up to the next blank -or- the end of the line\n          write(word)                 # write the word\n      }\n  }\n\nA more complex example demonstrates the integration of generators and string scanning within the language.\n\n procedure main()\n     s := \"Mon Dec 8\"\n     s ? write(Mdate() | \"not a valid date\")\n end\n # Define a matching function that returns\n # a string that matches a day month dayofmonth\n procedure Mdate()\n # Define some initial values\n static dates\n static days\n initial {\n        days := [\"Mon\",\"Tue\",\"Wed\",\"Thr\",\"Fri\",\"Sat\",\"Sun\"]\n        dates := [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n                  \"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]\n }\n every suspend   (retval \n\nThe idiom of  expr1 & expr2 & expr3 returns the value of the last expression",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Icon (programming language)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=14801" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Icon is a very high-level programming language featuring goal-directed execution and many facilities for managing strings and textual patterns. It is related to SNOBOL and SL5, string processing languages. Icon is not object-oriented, but an object-oriented extension called Idol was developed in 1996 which eventually became Unicon.\n\nBasic syntax\n\nThe Icon language is derived from the ALGOL-class of structured programming languages, and thus has syntax similar to C or Pascal. Icon is most similar to Pascal, using := syntax for assignments, the procedure keyword and similar syntax. On the other hand, Icon uses C-style brackets for structuring execution groups, and programs start by running a procedure called \"main\".\n\nIn many ways Icon also shares features with most scripting languages (as well as SNOBOL and SL5, from which they were taken): variables do not have to be declared, types are cast automatically, and numbers can be converted to strings and back automatically. Another feature common to many scripting languages, but not all, is the lack of a line-ending character; in Icon, lines not ended by a semicolon get ended by an implied semicolon if it makes sense.\n\nProcedures are the basic building blocks of Icon programs. Although they use Pascal naming, they work more like C functions and can return values; there is no function keyword in Icon.\n\n procedure doSomething(aString)\n   write(aString)\n end\n\nGoal-directed execution\n\nOne of Icon's key concepts is that control structures are based on the \"success\" or \"failure\" of expressions, rather than on boolean logic, as in most other programming languages. Under this model, simple comparisons like if a  do not mean \"if the operations to the right evaluate to true\" as they would under most languages; instead it means something more like \"if the operations to the right succeed\". In this case the if a , a common type of comparison that in most languages must be written as a conjunction of two inequalities like if a .\n\nThe utility of this concept becomes much clearer when you consider real-world examples. Since Icon uses success or failure for all flow control, this simple code:\n\nif a := read() then write(a)\n\nwill copy one line of standard input to standard output. This code will work even if the read() causes an error, for instance, if the file does not exist. In that case the statement a := read() will fail, and write will simply not be called.\n\nSuccess and failure are passed \"up\" through functions, meaning that a failure inside a nested function will cause the functions calling it to fail as well. For instance, we can write a program to copy an entire input file to output in a single line:\n\nwhile write(read())\n\nWhen the read() command fails, at the end of file for instance, the failure will be passed up the chain, and write() will fail as well. The while, being a control structure, stops on failure, meaning it stops when the file is empty. For comparison, consider a similar example written in pseudocode (using syntax close to C++ and derived languages such as Java):\n\n try {\n   while ((a read()) !\n EOF) {\n     write(a);\n   }\n } catch (Exception e) {\n   // do nothing, exit the loop\n }\n\nThis case needs two comparisons: one for end of file (EOF) and another for all other errors. Since Java does not allow errors to be compared as logic elements, as under Icon, the lengthy try/catch syntax must be used instead. Try blocks also impose a performance penalty for simply using them, even if no error occurs, a distributed cost that Icon avoids.\n\nIcon refers to this concept as goal-directed execution, referring to the way that execution continues until some goal is reached. In the example above the goal is to read the entire file; the read command continues to succeed while there is more information to be read, and fails when there isn't. The goal is thus coded directly in the language, instead of using statements checking return codes or similar constructs.\n\nGenerators\n\nExpressions in Icon often return a single value, for instance, x  will evaluate and succeed if the value of x is less than 5, or else fail. However several of the examples below rely on the fact that many expressions do not immediately return success or failure, returning values in the meantime. This drives the examples with every and to; every causes to to continue to return values until it fails.\n\nThis is a key concept in Icon, known as generators. Generators drive much of the loop functionality in the language, but do so more directly; the programmer does not write a loop and then pull out and compare values, Icon will do all of this for you.\n\nWithin the parlance of Icon, the evaluation of an expression or function results in a result sequence. A result sequence contains all the possible values that can be generated by the expression or function. When the result sequence is exhausted (e.g. there are no more values within the result sequence), the expression or function fails. Iteration over the result sequence is achieved either implicitly via Icon's goal directed evaluation or explicitly via the every clause.\n\nIcon includes several generator-builders. The alternator syntax allows a series of items to be generated in sequence until one fails:\n\n 1 | \"hello\" | x \ncan generate \"1\", \"hello\", and \"5\" if x is less than 5. Alternators can be read as \"or\" in many cases, for instance:\n\n if y \n\nwill write out the value of y if it is smaller than x or 5. Internally Icon checks every value from left to right until one succeeds or the list empties and it returns a failure. Remember that functions will not be called unless the calls within do not fail, so this example can be shortened to:\n\n write(\"y=\", (x | 5) > y)\n\nAnother simple generator is the to, which generates lists of integers; every write(1 to 10) will do exactly what it seems to. The bang syntax generates every item of a list; every write(!aString) will output each character of aString on a new line.\n\nTo demonstrate the power of this concept, consider string operations. Most languages include a function known as find or indexOf that returns the location of a string within another. Consider:\n\n s = \"All the world's a stage. And all the men and women merely players\";\n i = indexOf(\"the\", s)\n\nThis code will return 4, the position of the first occurrence of the word \"the\". To get the next instance of \"the\" an alternate form must be used,\n\n i = indexOf(\"the\", s, 5)\nthe 5 at the end saying it should look from position 5 on. In order to extract all the occurrences of \"the\", a loop must be used...\n\n s = \"All the world's a stage. And all the men and women merely players\";\n i = indexOf(\"the\", s)\n while i != -1 {\n   write(i);\n   i =  indexOf(\"the\", s, i+1);\n }\n\nUnder Icon the find function is a generator, and will return the next instance of the string each time it is resumed before finally failing after it passes the end of the string. The same code under Icon can be written:\n\n s := \"All the world's a stage. And all the men and women merely players\"\n every write(find(\"the\",s))\n\nfind will return the index of the next instance of \"the\" each time it is resumed by every, eventually passing the end of the string and failing. As in the prior example, this will cause write to fail, and the (one-line) every loop to exit.\n\nOf course there are times where you deliberately want to find a string after some point in input, for instance, you might be scanning a text file containing data in multiple columns. Goal-directed execution works here as well, and can be used this way:\n\n write(5 \n\nThe position will only be returned if \"the\" appears after position 5, the comparison will fail otherwise, passing that failure to write() as before. There is one small \"trick\" to this code that needs to be considered: comparisons return the right-hand result, so it is important to put the find on the right-hand side of the comparison. If the 5 were placed on the right, 5 would be written.\n\nIcon adds several control structures for looping through\ngenerators. The every operator is similar to while, looping through every item returned by a generator and exiting on failure:\n\n  every k := i to j do\n   write(someFunction(k))\n\nWhy use every instead of a while loop in this case?\nBecause while re-evaluates the first result,\nbut every produces all results.\nThe every syntax actually injects values into the function in a fashion similar to blocks under Smalltalk. For instance, the above loop can be re-written this way:\n\n every write(someFunction(i to j))\n\nUsers can build new generators easily using the suspend keyword:\n\n procedure findOnlyOdd(pattern, theString)\n   every i := find(pattern, theString) do\n     if i % 2 = 1 then suspend i\n end\n\nThis example loops over theString using find to look for pattern. When one is found, and the position is odd, the location is returned from the function with suspend. Unlike return, suspend writes down where it is in the internal generators as well, allowing it to pick up where it left off on the next iteration.\n\nStrings\n\nIn keeping with its script-like functionality, Icon adds a number of features to make working with strings easier. Most notable among these is the scanning system, which repeatedly calls functions on a string:\n\ns ? write(find(\"the\"))\n\nis a short form of the examples shown earlier. In this case the subject of the find function is placed outside the parameters in front of the question-mark. Icon functions are deliberately (as opposed to automatically) written to identify the subject in parameter lists and allow them to be pulled out in this fashion.\n\nSubstrings can be extracted from a string by using a range specification within brackets. A range specification can return a point to a single character, or a slice of the string. Strings can be indexed from either the right or the left. Positions within a string are defined to be between the characters 1A2B3C4 and can be specified from the right −3A−2B−1C0\n\nFor example,\n\n \"Wikipedia\"[1]     \n> \"W\"\n \"Wikipedia\"[3]     \n> \"k\"\n \"Wikipedia\"[0]     \n> \"a\"\n \"Wikipedia\"[1:3]   \n> \"Wi\"\n \"Wikipedia\"[-2:0]  \n> \"ia\"\n \"Wikipedia\"[2+:3]  \n> \"iki\"\n\nWhere the last example shows using a length instead of an ending position\n\nThe subscripting specification can be used as a lvalue within an expression. This can be used to insert strings into another string or delete parts of a string. For example,\n\n    s := \"abc\"\n    s[2] := \"123\"\n    s now has a value of \"a123c\"\n    s := \"abcdefg\"\n    s[3:5] := \"ABCD\"\n    s now has a value of \"abABCDefg\"\n    s := \"abcdefg\"\n    s[3:5] := \"\"\n    s now has a value of \"abefg\"\n\nAs noted above, Icon's subscript indices are between the elements. Given the string s := \"ABCDEFG\", the indexes are: 1A2B3C4D5E6F7G8. The slice s[3:5] is the string between the indices 3 and 5, which is the string \"CD\".\n\nOther structures\n\nIcon also allows the user to easily construct their own lists (or arrays):\n\naCat := [\"muffins\", \"tabby\", 2002, 8]\n\nThe items within a list can be of any sort, including other structures. To quickly build larger lists, Icon includes the list generator; i := list(10, \"word\") generates a list containing 10 copies of \"word\".\n\nLike arrays in other languages, Icon allows items to be looked up by position, e.g., weight := aCat[4]. As with strings, the indices are between the elements, and a slice of a list can be obtained by specifying the range, e.g., aCat[2:4] produces the list [\"tabby\",2002]. Unlike strings, a slice using a range cannot be a lvalue.\n\nThe bang-syntax, e.g., every write(!aCat), will print out four lines, each with one element.\n\nIcon includes stack-like functions, push and pop to allow them to form the basis of stacks and queues.\n\nIcon also includes functionality for sets and tables (known as hashes, associative arrays, dictionaries, etc.):\n\n symbols := table(0)\n symbols[\"there\"] := 1\n symbols[\"here\"] := 2\n\nThis code creates a table that will use zero as the default value of any unknown key. It then adds two items into it, with the keys \"there\" and \"here\", and values 1 and 2.\n\nString scanning\n\nOne of the powerful features of Icon is string scanning. The scan string operator, ? saves the current string scanning environment and creates a new string scanning environment. The string scanning environment consists of two keyword variables, &subject and &pos. Where &subject is the string being scanned, and &pos is the cursor or current position within the subject string.\n\nFor example,\n\n  s := \"this is a string\"\n  s ? write(\"subject[\",&subject,\"] pos\n[\",&pos,\"]\")\n\nwould produce\n\nsubject[this is a string] pos\n[1]\n\nBuilt-in and user-defined functions can be used to move around within the string being scanned. Many of the built-in functions will default to &subject and &pos (for example the find function). The following, for example, will write all blank delimited \"words\" in a string.\n\n  s := \"this is a string\"\n  s ? {                               # Establish string scanning environment\n      while not pos(0) do  {          # Test for end of string\n          tab(many(' '))              # Skip past any blanks\n          word := tab(upto(' ') | 0)  # the next word is up to the next blank -or- the end of the line\n          write(word)                 # write the word\n      }\n  }\n\nA more complex example demonstrates the integration of generators and string scanning within the language.\n\n procedure main()\n     s := \"Mon Dec 8\"\n     s ? write(Mdate() | \"not a valid date\")\n end\n # Define a matching function that returns\n # a string that matches a day month dayofmonth\n procedure Mdate()\n # Define some initial values\n static dates\n static days\n initial {\n        days := [\"Mon\",\"Tue\",\"Wed\",\"Thr\",\"Fri\",\"Sat\",\"Sun\"]\n        dates := [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n                  \"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]\n }\n every suspend   (retval \n\nThe idiom of  expr1 & expr2 & expr3 returns the value of the last expression. Icon (programming language). http://en.wikipedia.org/?curid=14801."
  }
}
