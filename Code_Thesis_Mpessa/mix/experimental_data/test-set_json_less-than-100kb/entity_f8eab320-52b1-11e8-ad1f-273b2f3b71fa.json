{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=10987",
  "eid" : "f8eab320-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778497362,
  "textBody" : "In mathematics, a functor is a type of mapping between categories arising in category theory. Functors can be thought of as homomorphisms between categories. In the category of small categories, functors can be thought of more generally as morphisms.\n\nFunctors were first considered in algebraic topology, where algebraic objects (like the fundamental group) are associated to topological spaces, and algebraic homomorphisms are associated to continuous maps. Nowadays, functors are used throughout modern mathematics to relate various categories. Thus, functors are generally applicable in areas within mathematics that category theory can make an abstraction of.\n\nThe word functor was borrowed by mathematicians from the philosopher Rudolf Carnap, who used the term in a linguistic context;Rudolf Carnap, The Logical Syntax of Language, Routledge & Kegan Paul, 1937, pp. 13–14.\nsee function word.\n\nDefinition\n\nLet C and D be categories. A functor F from C to D is a mapping thatJacobson (2009), p. 19, def. 1.2.\n* associates to each object X in C an object F(X) in D,\n* associates to each morphism f:X\\rightarrow Y in C a morphism F(f):F(X) \\rightarrow F(Y) in D such that the following two conditions hold:\n** F(\\mathrm{id}_{X}) = \\mathrm{id}_{F(X)}\\,\\! for every object X in C,\n** F(g \\circ f) = F(g) \\circ F(f) for all morphisms f:X \\rightarrow Y\\,\\! and g:Y\\rightarrow Z in C.\n\nThat is, functors must preserve identity morphisms and composition of morphisms.\n\nCovariance and contravariance\n\nThere are many constructions in mathematics that would be functors but for the fact that they \"turn morphisms around\" and \"reverse composition\". We then define a contravariant functor F from C to D as a mapping that \n*associates to each object X in C an object F(X) in D,\n*associates to each morphism f:X\\rightarrow Y in C a morphism F(f):F(Y) \\rightarrow F(X) in D such that the following two conditions hold:\n**F(\\mathrm{id}_X) = \\mathrm{id}_{F(X)}\\,\\! for every object X in C,\n**F(g \\circ f) = F(f) \\circ F(g) for all morphisms f:X\\rightarrow Y and g:Y\\rightarrow Z in C.\n\nNote that contravariant functors reverse the direction of composition.\n\nOrdinary functors are also called covariant functors in order to distinguish them from contravariant ones. Note that one can also define a contravariant functor as a covariant functor on the opposite category C^\\mathrm{op}.Jacobson (2009), p. 19–20. Some authors prefer to write all expressions covariantly. That is, instead of saying F: C\\rightarrow D is a contravariant functor, they simply write F: C^{\\mathrm{op}} \\rightarrow D  (or sometimes F:C \\rightarrow D^{\\mathrm{op}}) and call it a functor.\n\nContravariant functors are also occasionally called cofunctors.\n\nThere is a convention which refers to \"vectors\"—i.e, vector fields, elements of the space of sections \\Gamma(TM) of a tangent bundle TM—as \"contravariant\" and to \"covectors\"—i.e., 1-forms, elements of the space of sections \\Gamma(T^*M) of a cotangent bundle T^*M—as \"covariant\".  This terminology originates in physics, and its rationale has to do with the position of the indices (\"upstairs\" and \"downstairs\") in expressions such as x^i \\Lambda^i_j x^j for \\mathbf{x}' \n \\boldsymbol{\\Lambda}\\mathbf{x} or \\omega_i \\Lambda^j_i \\omega_j for \\boldsymbol{\\omega}' \n \\boldsymbol{\\omega}\\boldsymbol{\\Lambda}^T.  In this formalism it is observed that the coordinate transformation symbol \\Lambda^j_i (representing the matrix \\boldsymbol{\\Lambda}^T) acts on the basis vectors \"in the same way\" as on the \"covector coordinates\": \\mathbf{e}_i \\Lambda^j_i\\mathbf{e}_j—whereas it acts \"in the opposite way\" on the \"vector coordinates\" (but \"in the same way\" as on the basis covectors: \\mathbf{e}^i \n \\Lambda^i_j \\mathbf{e}^j).  This terminology is contrary to the one used in Category Theory because it is the covectors that have pullbacks in general and are thus contravariant, whereas vectors in general are covariant since they can be pushed forward.  See also Covariance and contravariance of vectors.\n\nOpposite functor\n\nEvery functor F: C\\rightarrow D induces the opposite functor F^\\mathrm{op}: C^\\mathrm{op}\\rightarrow D^\\mathrm{op}, where C^\\mathrm{op} and D^\\mathrm{op} are the opposite categories to C and D. By definition, F^\\mathrm{op} maps objects and morphisms identically to F. Since C^\\mathrm{op} does not coincide with C as a category, and similarly for D, F^\\mathrm{op} is distinguished from F. For example, when composing F: C_0\\rightarrow C_1 with G: C_1^\\mathrm{op}\\rightarrow C_2, one should use either G\\circ F^\\mathrm{op} or G^\\mathrm{op}\\circ F. Note that, following the property of opposite category, (F^\\mathrm{op})^\\mathrm{op} = F.\n\nBifunctors and multifunctors\n\nA bifunctor (also known as a binary functor) is a functor whose domain is a product category. For example, the Hom functor is of the type . It can be seen as a functor in two arguments. The Hom functor is a natural example; it is contravariant in one argument, covariant in the other.\n\nA multifunctor is a generalization of the functor concept to n variables. So, for example, a bifunctor is a multifunctor with .\n\nExamples\n\nDiagram: For categories C and J, a diagram of type J in C is a covariant functor D:J\\rightarrow C.\n\n(Category theoretical) presheaf: For categories C and J, a J-presheaf on C is a contravariant functor D:C\\rightarrow J.\n\nPresheaves: If X is a topological space, then the open sets in X form a partially ordered set Open(X) under inclusion. Like every partially ordered set, Open(X) forms a small category by adding a single arrow  if and only if U \\subseteq V. Contravariant functors on Open(X) are called presheaves on X. For instance, by assigning to every open set U the associative algebra of real-valued continuous functions on U, one obtains a presheaf of algebras on X.\n\nConstant functor: The functor  which maps every object of C to a fixed object X in D and every morphism in C to the identity morphism on X. Such a functor is called a constant or selection functor.\n\nEndofunctor: A functor that maps a category to itself; e.g., polynomial functor.\n\nIdentity functor: in category C, written 1C or idC, maps an object to itself and a morphism to itself. The identity functor is an endofunctor.\n\nDiagonal functor: The diagonal functor is defined as the functor from D to the functor category DC which sends each object in D to the constant functor at that object.\n\nLimit functor: For a fixed index category J, if every functor  has a limit (for instance if C is complete), then the limit functor  assigns to each functor its limit.  The existence of this functor can be proved by realizing that it is the right-adjoint to the diagonal functor and invoking the Freyd adjoint functor theorem.  This requires a suitable version of the axiom of choice.  Similar remarks apply to the colimit functor (which is covariant).\n\nPower sets: The power set functor  maps each set to its power set and each function  f : X \\to Y to the map which sends U \\subseteq X to its image f(U) \\subseteq Y. One can also consider the contravariant power set functor which sends  f : X \\to Y  to the map which\nsends V \\subseteq Y to its inverse image f^{-1}(V) \\subseteq X.\n\nThe map which assigns to every vector space its dual space and to every linear map its dual or transpose is a contravariant functor from the category of all vector spaces over a fixed field to itself.\n\nFundamental group: Consider the category of pointed topological spaces, i.e. topological spaces with distinguished points. The objects are pairs , where X is a topological space and x0 is a point in X. A morphism from  to  is given by a continuous map  with .\n\nTo every topological space X with distinguished point x0, one can define the fundamental group based at x0, denoted . This is the group of homotopy classes of loops based at x0. If  is a morphism of pointed spaces, then every loop in X with base point x0 can be composed with f to yield a loop in Y with base point y0. This operation is compatible with the homotopy equivalence relation and the composition of loops, and we get a group homomorphism from  to . We thus obtain a functor from the category of pointed topological spaces to the category of groups.\n\nIn the category of topological spaces (without distinguished point), one considers homotopy classes of generic curves, but they cannot be composed unless they share an endpoint.  Thus one has the fundamental groupoid instead of the fundamental group, and this construction is functorial.\n\nAlgebra of continuous functions: a contravariant functor from the category of topological spaces (with continuous maps as morphisms) to the category of real associative algebras is given by assigning to every topological space X the algebra C(X) of all real-valued continuous functions on that space. Every continuous map  induces an algebra homomorphism  by the rule  for every φ in C(Y).\n\nTangent and cotangent bundles: The map which sends every differentiable manifold to its tangent bundle and every smooth map to its derivative is a covariant functor from the category of differentiable manifolds to the category of vector bundles.\n\nDoing this constructions pointwise gives the tangent space, a covariant functor from the category of pointed differentiable manifolds to the category of real vector spaces. Likewise, cotangent space is a contravariant functor, essentially the composition of the tangent space with the dual space above.\n\nGroup actions/representations: Every group G can be considered as a category with a single object whose morphisms are the elements of G. A functor from G to Set is then nothing but a group action of G on a particular set, i.e. a G-set. Likewise, a functor from G to the category of vector spaces, VectK, is a linear representation of G. In general, a functor  can be considered as an \"action\" of G on an object in the category C. If C is a group, then this action is a group homomorphism.\n\nLie algebras: Assigning to every real (complex) Lie group its real (complex) Lie algebra defines a functor.\n\nTensor products: If C denotes the category of vector spaces over a fixed field, with linear maps as morphisms, then the tensor product V \\otimes W defines a functor  which is covariant in both arguments.\n\nForgetful functors: The functor  which maps a group to its underlying set and a group homomorphism to its underlying function of sets is a functor.Jacobson (2009), p. 20, ex. 2. Functors like these, which \"forget\" some structure, are termed forgetful functors. Another example is the functor  which maps a ring to its underlying additive abelian group. Morphisms in Rng (ring homomorphisms) become morphisms in Ab (abelian group homomorphisms).\n\nFree functors: Going in the opposite direction of forgetful functors are free functors. The free functor  sends every set X to the free group generated by X. Functions get mapped to group homomorphisms between free groups. Free constructions exist for many categories based on structured sets. See free object.\n\nHomomorphism groups: To every pair A, B of abelian groups one can assign the abelian group Hom(A,B) consisting of all group homomorphisms from A to B. This is a functor which is contravariant in the first and covariant in the second argument, i.e. it is a functor  (where Ab denotes the category of abelian groups with group homomorphisms). If  and  are morphisms in Ab, then the group homomorphism :  is given by .  See Hom functor.\n\nRepresentable functors: We can generalize the previous example to any category C. To every pair X, Y of objects in C one can assign the set  of morphisms from X to Y. This defines a functor to Set which is contravariant in the first argument and covariant in the second, i.e. it is a functor . If  and  are morphisms in C, then the group homomorphism  is given by .\n\nFunctors like these are called representable functors. An important goal in many settings is to determine whether a given functor is representable.\n\nProperties\n\nTwo important consequences of the functor axioms are:\n* F transforms each commutative diagram in C into a commutative diagram in D;\n* if f is an isomorphism in C, then F(f) is an isomorphism in D.\n\nOne can compose functors, i.e. if F is a functor from A to B and G is a functor from B to C then one can form the composite functor  from A to C. Composition of functors is associative where defined. Identity of composition of functors is identity functor. This shows that functors can be considered as morphisms in categories of categories, for example in the category of small categories.\n\nA small category with a single object is the same thing as a monoid: the morphisms of a one-object category can be thought of as elements of the monoid, and composition in the category is thought of as the monoid operation. Functors between one-object categories correspond to monoid homomorphisms. So in a sense, functors between arbitrary categories are a kind of generalization of monoid homomorphisms to categories with more than one object.\n\nRelation to other categorical concepts\n\nLet \\mathcal{C} and \\mathcal{D} be categories. The collection of all functors \\mathcal{C}\\to\\mathcal{D} form the objects of a category: the functor category. Morphisms in this category are natural transformations between functors.\n\nFunctors are often defined by universal properties; examples are the tensor product, the direct sum and direct product of groups or vector spaces, construction of free groups and modules, direct and inverse limits. The concepts of limit and colimit generalize several of the above.\n\nUniversal constructions often give rise to pairs of adjoint functors.\n\nComputer implementations\n\nFunctors sometimes appear in functional programming. For instance, the programming language Haskell has a class Functor where fmap is a polytypic function used to map functions (morphisms on Hask, the category of Haskell types)It's not entirely clear that Haskell datatypes truly form a category. See https://wiki.haskell.org/Hask for more details. between existing types to functions between some new types.See https://wiki.haskell.org/Category_theory/Functor#Functors_in_Haskell for more information.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Functor" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=10987" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In mathematics, a functor is a type of mapping between categories arising in category theory. Functors can be thought of as homomorphisms between categories. In the category of small categories, functors can be thought of more generally as morphisms.\n\nFunctors were first considered in algebraic topology, where algebraic objects (like the fundamental group) are associated to topological spaces, and algebraic homomorphisms are associated to continuous maps. Nowadays, functors are used throughout modern mathematics to relate various categories. Thus, functors are generally applicable in areas within mathematics that category theory can make an abstraction of.\n\nThe word functor was borrowed by mathematicians from the philosopher Rudolf Carnap, who used the term in a linguistic context;Rudolf Carnap, The Logical Syntax of Language, Routledge & Kegan Paul, 1937, pp. 13–14.\nsee function word.\n\nDefinition\n\nLet C and D be categories. A functor F from C to D is a mapping thatJacobson (2009), p. 19, def. 1.2.\n* associates to each object X in C an object F(X) in D,\n* associates to each morphism f:X\\rightarrow Y in C a morphism F(f):F(X) \\rightarrow F(Y) in D such that the following two conditions hold:\n** F(\\mathrm{id}_{X}) = \\mathrm{id}_{F(X)}\\,\\! for every object X in C,\n** F(g \\circ f) = F(g) \\circ F(f) for all morphisms f:X \\rightarrow Y\\,\\! and g:Y\\rightarrow Z in C.\n\nThat is, functors must preserve identity morphisms and composition of morphisms.\n\nCovariance and contravariance\n\nThere are many constructions in mathematics that would be functors but for the fact that they \"turn morphisms around\" and \"reverse composition\". We then define a contravariant functor F from C to D as a mapping that \n*associates to each object X in C an object F(X) in D,\n*associates to each morphism f:X\\rightarrow Y in C a morphism F(f):F(Y) \\rightarrow F(X) in D such that the following two conditions hold:\n**F(\\mathrm{id}_X) = \\mathrm{id}_{F(X)}\\,\\! for every object X in C,\n**F(g \\circ f) = F(f) \\circ F(g) for all morphisms f:X\\rightarrow Y and g:Y\\rightarrow Z in C.\n\nNote that contravariant functors reverse the direction of composition.\n\nOrdinary functors are also called covariant functors in order to distinguish them from contravariant ones. Note that one can also define a contravariant functor as a covariant functor on the opposite category C^\\mathrm{op}.Jacobson (2009), p. 19–20. Some authors prefer to write all expressions covariantly. That is, instead of saying F: C\\rightarrow D is a contravariant functor, they simply write F: C^{\\mathrm{op}} \\rightarrow D  (or sometimes F:C \\rightarrow D^{\\mathrm{op}}) and call it a functor.\n\nContravariant functors are also occasionally called cofunctors.\n\nThere is a convention which refers to \"vectors\"—i.e, vector fields, elements of the space of sections \\Gamma(TM) of a tangent bundle TM—as \"contravariant\" and to \"covectors\"—i.e., 1-forms, elements of the space of sections \\Gamma(T^*M) of a cotangent bundle T^*M—as \"covariant\".  This terminology originates in physics, and its rationale has to do with the position of the indices (\"upstairs\" and \"downstairs\") in expressions such as x^i \\Lambda^i_j x^j for \\mathbf{x}' \n \\boldsymbol{\\Lambda}\\mathbf{x} or \\omega_i \\Lambda^j_i \\omega_j for \\boldsymbol{\\omega}' \n \\boldsymbol{\\omega}\\boldsymbol{\\Lambda}^T.  In this formalism it is observed that the coordinate transformation symbol \\Lambda^j_i (representing the matrix \\boldsymbol{\\Lambda}^T) acts on the basis vectors \"in the same way\" as on the \"covector coordinates\": \\mathbf{e}_i \\Lambda^j_i\\mathbf{e}_j—whereas it acts \"in the opposite way\" on the \"vector coordinates\" (but \"in the same way\" as on the basis covectors: \\mathbf{e}^i \n \\Lambda^i_j \\mathbf{e}^j).  This terminology is contrary to the one used in Category Theory because it is the covectors that have pullbacks in general and are thus contravariant, whereas vectors in general are covariant since they can be pushed forward.  See also Covariance and contravariance of vectors.\n\nOpposite functor\n\nEvery functor F: C\\rightarrow D induces the opposite functor F^\\mathrm{op}: C^\\mathrm{op}\\rightarrow D^\\mathrm{op}, where C^\\mathrm{op} and D^\\mathrm{op} are the opposite categories to C and D. By definition, F^\\mathrm{op} maps objects and morphisms identically to F. Since C^\\mathrm{op} does not coincide with C as a category, and similarly for D, F^\\mathrm{op} is distinguished from F. For example, when composing F: C_0\\rightarrow C_1 with G: C_1^\\mathrm{op}\\rightarrow C_2, one should use either G\\circ F^\\mathrm{op} or G^\\mathrm{op}\\circ F. Note that, following the property of opposite category, (F^\\mathrm{op})^\\mathrm{op} = F.\n\nBifunctors and multifunctors\n\nA bifunctor (also known as a binary functor) is a functor whose domain is a product category. For example, the Hom functor is of the type . It can be seen as a functor in two arguments. The Hom functor is a natural example; it is contravariant in one argument, covariant in the other.\n\nA multifunctor is a generalization of the functor concept to n variables. So, for example, a bifunctor is a multifunctor with .\n\nExamples\n\nDiagram: For categories C and J, a diagram of type J in C is a covariant functor D:J\\rightarrow C.\n\n(Category theoretical) presheaf: For categories C and J, a J-presheaf on C is a contravariant functor D:C\\rightarrow J.\n\nPresheaves: If X is a topological space, then the open sets in X form a partially ordered set Open(X) under inclusion. Like every partially ordered set, Open(X) forms a small category by adding a single arrow  if and only if U \\subseteq V. Contravariant functors on Open(X) are called presheaves on X. For instance, by assigning to every open set U the associative algebra of real-valued continuous functions on U, one obtains a presheaf of algebras on X.\n\nConstant functor: The functor  which maps every object of C to a fixed object X in D and every morphism in C to the identity morphism on X. Such a functor is called a constant or selection functor.\n\nEndofunctor: A functor that maps a category to itself; e.g., polynomial functor.\n\nIdentity functor: in category C, written 1C or idC, maps an object to itself and a morphism to itself. The identity functor is an endofunctor.\n\nDiagonal functor: The diagonal functor is defined as the functor from D to the functor category DC which sends each object in D to the constant functor at that object.\n\nLimit functor: For a fixed index category J, if every functor  has a limit (for instance if C is complete), then the limit functor  assigns to each functor its limit.  The existence of this functor can be proved by realizing that it is the right-adjoint to the diagonal functor and invoking the Freyd adjoint functor theorem.  This requires a suitable version of the axiom of choice.  Similar remarks apply to the colimit functor (which is covariant).\n\nPower sets: The power set functor  maps each set to its power set and each function  f : X \\to Y to the map which sends U \\subseteq X to its image f(U) \\subseteq Y. One can also consider the contravariant power set functor which sends  f : X \\to Y  to the map which\nsends V \\subseteq Y to its inverse image f^{-1}(V) \\subseteq X.\n\nThe map which assigns to every vector space its dual space and to every linear map its dual or transpose is a contravariant functor from the category of all vector spaces over a fixed field to itself.\n\nFundamental group: Consider the category of pointed topological spaces, i.e. topological spaces with distinguished points. The objects are pairs , where X is a topological space and x0 is a point in X. A morphism from  to  is given by a continuous map  with .\n\nTo every topological space X with distinguished point x0, one can define the fundamental group based at x0, denoted . This is the group of homotopy classes of loops based at x0. If  is a morphism of pointed spaces, then every loop in X with base point x0 can be composed with f to yield a loop in Y with base point y0. This operation is compatible with the homotopy equivalence relation and the composition of loops, and we get a group homomorphism from  to . We thus obtain a functor from the category of pointed topological spaces to the category of groups.\n\nIn the category of topological spaces (without distinguished point), one considers homotopy classes of generic curves, but they cannot be composed unless they share an endpoint.  Thus one has the fundamental groupoid instead of the fundamental group, and this construction is functorial.\n\nAlgebra of continuous functions: a contravariant functor from the category of topological spaces (with continuous maps as morphisms) to the category of real associative algebras is given by assigning to every topological space X the algebra C(X) of all real-valued continuous functions on that space. Every continuous map  induces an algebra homomorphism  by the rule  for every φ in C(Y).\n\nTangent and cotangent bundles: The map which sends every differentiable manifold to its tangent bundle and every smooth map to its derivative is a covariant functor from the category of differentiable manifolds to the category of vector bundles.\n\nDoing this constructions pointwise gives the tangent space, a covariant functor from the category of pointed differentiable manifolds to the category of real vector spaces. Likewise, cotangent space is a contravariant functor, essentially the composition of the tangent space with the dual space above.\n\nGroup actions/representations: Every group G can be considered as a category with a single object whose morphisms are the elements of G. A functor from G to Set is then nothing but a group action of G on a particular set, i.e. a G-set. Likewise, a functor from G to the category of vector spaces, VectK, is a linear representation of G. In general, a functor  can be considered as an \"action\" of G on an object in the category C. If C is a group, then this action is a group homomorphism.\n\nLie algebras: Assigning to every real (complex) Lie group its real (complex) Lie algebra defines a functor.\n\nTensor products: If C denotes the category of vector spaces over a fixed field, with linear maps as morphisms, then the tensor product V \\otimes W defines a functor  which is covariant in both arguments.\n\nForgetful functors: The functor  which maps a group to its underlying set and a group homomorphism to its underlying function of sets is a functor.Jacobson (2009), p. 20, ex. 2. Functors like these, which \"forget\" some structure, are termed forgetful functors. Another example is the functor  which maps a ring to its underlying additive abelian group. Morphisms in Rng (ring homomorphisms) become morphisms in Ab (abelian group homomorphisms).\n\nFree functors: Going in the opposite direction of forgetful functors are free functors. The free functor  sends every set X to the free group generated by X. Functions get mapped to group homomorphisms between free groups. Free constructions exist for many categories based on structured sets. See free object.\n\nHomomorphism groups: To every pair A, B of abelian groups one can assign the abelian group Hom(A,B) consisting of all group homomorphisms from A to B. This is a functor which is contravariant in the first and covariant in the second argument, i.e. it is a functor  (where Ab denotes the category of abelian groups with group homomorphisms). If  and  are morphisms in Ab, then the group homomorphism :  is given by .  See Hom functor.\n\nRepresentable functors: We can generalize the previous example to any category C. To every pair X, Y of objects in C one can assign the set  of morphisms from X to Y. This defines a functor to Set which is contravariant in the first argument and covariant in the second, i.e. it is a functor . If  and  are morphisms in C, then the group homomorphism  is given by .\n\nFunctors like these are called representable functors. An important goal in many settings is to determine whether a given functor is representable.\n\nProperties\n\nTwo important consequences of the functor axioms are:\n* F transforms each commutative diagram in C into a commutative diagram in D;\n* if f is an isomorphism in C, then F(f) is an isomorphism in D.\n\nOne can compose functors, i.e. if F is a functor from A to B and G is a functor from B to C then one can form the composite functor  from A to C. Composition of functors is associative where defined. Identity of composition of functors is identity functor. This shows that functors can be considered as morphisms in categories of categories, for example in the category of small categories.\n\nA small category with a single object is the same thing as a monoid: the morphisms of a one-object category can be thought of as elements of the monoid, and composition in the category is thought of as the monoid operation. Functors between one-object categories correspond to monoid homomorphisms. So in a sense, functors between arbitrary categories are a kind of generalization of monoid homomorphisms to categories with more than one object.\n\nRelation to other categorical concepts\n\nLet \\mathcal{C} and \\mathcal{D} be categories. The collection of all functors \\mathcal{C}\\to\\mathcal{D} form the objects of a category: the functor category. Morphisms in this category are natural transformations between functors.\n\nFunctors are often defined by universal properties; examples are the tensor product, the direct sum and direct product of groups or vector spaces, construction of free groups and modules, direct and inverse limits. The concepts of limit and colimit generalize several of the above.\n\nUniversal constructions often give rise to pairs of adjoint functors.\n\nComputer implementations\n\nFunctors sometimes appear in functional programming. For instance, the programming language Haskell has a class Functor where fmap is a polytypic function used to map functions (morphisms on Hask, the category of Haskell types)It's not entirely clear that Haskell datatypes truly form a category. See https://wiki.haskell.org/Hask for more details. between existing types to functions between some new types.See https://wiki.haskell.org/Category_theory/Functor#Functors_in_Haskell for more information. Functor. http://en.wikipedia.org/?curid=10987."
  }
}
