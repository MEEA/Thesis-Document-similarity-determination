{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=11168",
  "eid" : "fa0300f0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778499199,
  "textBody" : "Fortran (; formerly FORTRAN, derived from Formula Translation) is a general-purpose, imperative programming language that is especially suited to numeric computation and scientific computing. Originally developed by IBM in the 1950s for scientific and engineering applications, FORTRAN came to dominate this area of programming early on and has been in continuous use for over half a century in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing and is used for programs that benchmark and rank the world's fastest supercomputers.\n\nFortran encompasses a lineage of versions, each of which evolved to add extensions to the language while usually retaining compatibility with prior versions.  Successive versions have added support for structured programming\nand processing of character-based data (FORTRAN 77), array programming, modular programming and generic programming (Fortran 90), high performance Fortran (Fortran 95), object-oriented programming (Fortran 2003) and concurrent programming (Fortran 2008).\n\nNaming \n\nThe names of earlier versions of the language through FORTRAN 77 were conventionally spelled in all-capitals (FORTRAN 77 was the last version in which the use of lowercase letters in keywords was strictly non-standard).  The capitalization has been dropped in referring to newer versions beginning with Fortran 90. The official language standards now refer to the language as \"Fortran\" rather than all-caps \"FORTRAN\".\n\nHistory\n\nIn late 1953, John W. Backus submitted a proposal to his superiors at IBM to develop a more practical alternative to assembly language for programming their IBM 704 mainframe computer. Backus' historic FORTRAN team consisted of programmers Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Lois Haibt, and David Sayre.  Its concepts included easier entry of equations into a computer, an idea developed by J. Halcombe Laning and demonstrated in the Laning and Zierler system of 1952.Mindell, David, Digital Apollo, MIT Press, Cambridge MA, 2008, p.99.\n\nA draft specification for The IBM Mathematical Formula Translating System was completed by mid-1954.  The first manual for FORTRAN appeared in October 1956, with the first FORTRAN compiler delivered in April 1957.  This was the first optimizing compiler, because customers were reluctant to use a high-level programming language unless its compiler could generate code with performance comparable to that of hand-coded assembly language.[http://polaris.cs.uiuc.edu/publications/c1070.pdf The Fortran I Compiler] \"The Fortran I compiler was the first major project in code optimization. It tackled problems of crucial importance whose general solution was an important research focus in compiler technology for several decades. Many classical techniques for compiler analysis and optimization can trace their origins and inspiration to the Fortran I compiler.\"\n\nWhile the community was skeptical that this new method could possibly outperform hand-coding, it reduced the number of programming statements necessary to operate a machine by a factor of 20, and quickly gained acceptance.  John Backus said during a 1979 interview with Think, the IBM employee magazine, \"Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701, writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs.\"\n\nThe language was widely adopted by scientists for writing numerically intensive programs, which encouraged compiler writers to produce compilers that could generate faster and more efficient code.  The inclusion of a complex number data type in the language made Fortran especially suited to technical applications such as electrical engineering.\n\nBy 1960, versions of FORTRAN were available for the IBM 709, 650, 1620, and 7090 computers.  Significantly, the increasing popularity of FORTRAN spurred competing computer manufacturers to provide FORTRAN compilers for their machines, so that by 1963 over 40 FORTRAN compilers existed.  For these reasons, FORTRAN is considered to be the first widely used  programming language supported across a variety of computer architectures.\n\nThe development of Fortran paralleled the early evolution of compiler technology, and many advances in the theory and design of compilers were specifically motivated by the need to generate efficient code for Fortran programs.\n\nFORTRAN\n\nThe initial release of FORTRAN for the IBM 704 contained 32 statements, including:\n\n* DIMENSION and EQUIVALENCE statements\n* Assignment statements\n* Three-way arithmetic IF statement, which passed control to one of three locations in the program depending on whether the result of the arithmetic statement was negative, zero, or positive\n* IF statements for checking exceptions (ACCUMULATOR OVERFLOW, QUOTIENT OVERFLOW, and DIVIDE CHECK); and IF statements for manipulating sense switches and sense lights\n* GO TO, computed GO TO, ASSIGN, and assigned GO TO\n* DO loops\n* Formatted I/O: FORMAT, READ, READ INPUT TAPE, WRITE, WRITE OUTPUT TAPE, PRINT, and PUNCH\n* Unformatted I/O: READ TAPE, READ DRUM, WRITE TAPE, and WRITE DRUM\n* Other I/O: END FILE, REWIND, and BACKSPACE\n* PAUSE, STOP, and CONTINUE\n* FREQUENCY statement (for providing optimization hints to the compiler).\n\nThe arithmetic IF statement was reminiscent of (but not readily implementable by) a three-way comparison instruction (CAS Compare Accumulator with Storage) available on the 704. The statement provided the only way to compare numbers by testing their difference, with an attendant risk of overflow. This deficiency was later overcome by \"logical\" facilities introduced in FORTRAN IV.\n\nThe FREQUENCY statement was used originally (and optionally) to give branch probabilities for the three branch cases of the arithmetic IF statement. The first FORTRAN compiler used this weighting to perform at compile time a Monte Carlo simulation of the generated code, the results of which were used to optimize the placement of basic blocks in memory a very sophisticated optimization for its time. The Monte Carlo technique is documented in Backus et al.'s paper on this original implementation, The FORTRAN Automatic Coding System:\n\nThe fundamental unit of program is the basic block; a basic block is a stretch of program which has one entry point and one exit point. The purpose of section 4 is to prepare for section 5 a table of predecessors (PRED table) which enumerates the basic blocks and lists for every basic block each of the basic blocks which can be its immediate predecessor in flow, together with the absolute frequency of each such basic block link. This table is obtained by running the program once in Monte-Carlo fashion, in which the outcome of conditional transfers arising out of IF-type statements and computed GO TO's is determined by a random number generator suitably weighted according to whatever FREQUENCY statements have been provided. Online at [http://www.softwarepreservation.org/projects/FORTRAN/paper/BackusEtAl-FortranAutomaticCodingSystem-1957.pdf], [http://archive.computerhistory.org/resources/text/Fortran/102663113.05.01.acc.pdf]\n\nMany years later, the FREQUENCY statement had no effect on the code, and was treated as a comment statement, since the compilers no longer did this kind of compile-time simulation. A similar fate has befallen compiler hints in several other programming languages; for example C's register keyword.\n\nThe first FORTRAN compiler reported diagnostic information by halting the program when an error was found and outputting an error code on its console. That code could be looked up by the programmer in an error messages table in the operator's manual, providing them with a brief description of the problem.\n\nFixed layout and punched cards \n\nBefore the development of disk files, text editors and terminals, programs were most often entered on a keypunch keyboard onto 80-column punched cards, one line to a card. The resulting deck of cards would be fed into a card reader to be compiled. Punched card codes included no lower-case letters or many special characters, and special versions of the IBM 026 keypunch were offered that would correctly print the re-purposed special characters used in FORTRAN.\n\nReflecting punched card input practice, Fortran programs were originally written in a fixed-column format, with the first 72 columns read into twelve 36-bit words.\n\nA letter \"C\" in column 1 caused the entire card to be treated as a comment and ignored by the compiler. Otherwise, the columns of the card were divided into four fields:\n* 1 to 5 were the label field: a sequence of digits here was taken as a label for use in DO or control statements such as GO TO and IF, or to identify a FORMAT statement referred to in a WRITE or READ statement. Leading zeros are ignored and 0 is not a valid label number. \n* 6 was a continuation field: a character other than a blank or a zero here caused the card to be taken as a continuation of the statement on the prior card. The continuation cards were usually numbered 1, 2, etc. and the starting card might therefore have zero in its continuation column - which is not a continuation of its preceding card. \n* 7 to 72 served as the statement field. \n* 73 to 80 were ignored (the IBM 704's card reader only used 72 columns).[http://www.mirrorservice.org/sites/www.bitsavers.org/pdf/ibm/7090/22-6528-4_7090Manual.pdf Reference Manual, IBM 7090 Data Processing System], 1961, IBM A22-6528-3.\n\nColumns 73 to 80 could therefore be used for identification information, such as punching a sequence number or text, which could be used to re-order cards if a stack of cards was dropped; though in practice this was reserved for stable, production programs. An IBM 519 could be used to copy a program deck and add sequence numbers. Some early compilers, e.g., the IBM 650's, had additional restrictions due to limitations on their card readers. Keypunches could be programmed to tab to column 7 and skip out after column 72. Later compilers relaxed most fixed-format restrictions, and the requirement was eliminated in the Fortran 90 standard.\n\nWithin the statement field, whitespace characters (blanks) were ignored outside a text literal. This allowed omitting spaces between tokens for brevity or including spaces within identifiers for clarity. For example, AVG OF X was a valid identifier, equivalent to AVGOFX, and 101010DO101I\n1,101 was a valid statement, equivalent to \n10101    DO 101   I \n 1, 101 because the zero in column 6 is treated as if it were a space (!), while 101010DO101I\n1.101 was instead 10101    DO101I \n 1.101, the assignment of 1.101 to a variable called DO101I. Note the slight visual difference between a comma and a period.\n\nHollerith strings, originally allowed only in FORMAT and DATA statements, were prefixed by a character count and the letter H (e.g., 26HTHIS IS ALPHANUMERIC DATA.), allowing blanks to be retained within the character string. Miscounts were a problem.\n\nFORTRAN II\n\nIBM's FORTRAN II appeared in 1958.  The main enhancement was to support procedural programming by allowing user-written subroutines and functions which returned values, with parameters passed by reference.  The COMMON statement provided a way for subroutines to access common (or global) variables. Six new statements were introduced:\n\n* SUBROUTINE, FUNCTION, and END\n* CALL and RETURN\n* COMMON\n\nOver the next few years, FORTRAN II would also add support for the DOUBLE PRECISION and COMPLEX data types.\n\nEarly FORTRAN compilers supported no recursion in subroutines. Early computer architectures supported no concept of a stack, and when they did directly support subroutine calls, the return location was often stored in one fixed location adjacent to the subroutine code (e.g. the IBM 1130) or a specific machine register (IBM 360 et seq), which only allows recursion if a stack is maintained by software and the return address is stored on the stack before the call is made and restored after the call returns. Although not specified in Fortran 77, many F77 compilers supported recursion as an option, and the Burroughs mainframes, designed with recursion built-in, did so by default. It became a standard in Fortran 90 via the new keyword RECURSIVE.\n\nSimple FORTRAN II program\n\nThis program, for Heron's formula, reads data on a tape reel containing three 5-digit integers A, B, and C as input. There are no \"type\" declarations available: variables whose name starts with I, J, K, L, M, or N are \"fixed-point\" (i.e. integers), otherwise floating-point. Since integers are to be processed in this example, the names of the variables start with the letter \"I\". The name of a variable must start with a letter and can continue with both letters and digits, up to a limit of six characters in FORTRAN II.  If A, B, and C cannot represent the sides of a triangle in plane geometry, then the program's execution will end with an error code of \"STOP 1\".  Otherwise, an output line will be printed showing the input values for A, B, and C, followed by the computed AREA of the triangle as a floating-point number occupying ten spaces along the line of output and showing 2 digits after the decimal point, the .2 in F10.2 of the FORMAT statement with label 601.\n\nC AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION\nC INPUT - TAPE READER UNIT 5, INTEGER INPUT\nC OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT\nC INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING\n      READ INPUT TAPE 5, 501, IA, IB, IC\n  501 FORMAT (3I5)\nC IA, IB, AND IC MAY NOT BE NEGATIVE OR ZERO\nC FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE\nC MUST BE GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO\n      IF (IA) 777, 777, 701\n  701 IF (IB) 777, 777, 702\n  702 IF (IC) 777, 777, 703\n  703 IF (IA+IB-IC) 777, 777, 704\n  704 IF (IA+IC-IB) 777, 777, 705\n  705 IF (IB+IC-IA) 777, 777, 799\n  777 STOP 1\nC USING HERON'S FORMULA WE CALCULATE THE\nC AREA OF THE TRIANGLE\n  799 S = FLOATF (IA + IB + IC) / 2.0\n      AREA = SQRTF( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) *\n     +     (S - FLOATF(IC)))\n      WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA\n  601 FORMAT (4H A,I5,5H  B\n ,I5,5H  C,I5,8H  AREA\n ,F10.2,\n     +        13H SQUARE UNITS)\n      STOP\n      END\n\nFORTRAN III\n\nIBM also developed a FORTRAN III in 1958 that allowed for inline assembly code among other features; however, this version was never released as a product.  Like the 704 FORTRAN and FORTRAN II, FORTRAN III included machine-dependent features that made code written in it unportable from machine to machine.  Early versions of FORTRAN provided by other vendors suffered from the same disadvantage.\n\nIBM 1401 FORTRAN\n\nFORTRAN was provided for the IBM 1401 computer by an innovative 63-phase compiler that ran entirely in its core memory of only 8000 (six-bit) characters.  The compiler could be run from tape, or from a 2200-card deck; it used no further tape or disk storage.  It kept the program in memory and loaded overlays that gradually transformed it, in place, into executable form, as described by Haines. \nThis article was reprinted, edited, in both editions of Anatomy of a Compiler  and in the IBM manual \"Fortran Specifications and Operating Procedures, IBM 1401\".  The executable form was not entirely machine language; rather, floating-point arithmetic, sub-scripting, input/output, and function references were interpreted, preceeding UCSD Pascal P-code by two decades.\n\nIBM later provided a FORTRAN IV compiler for the 1400 series of computers.\n\nFORTRAN IV\n\nStarting in 1961, as a result of customer demands, IBM began development of a FORTRAN IV that removed the machine-dependent features of FORTRAN II (such as READ INPUT TAPE), while adding new features such as a LOGICAL data type, logical Boolean expressions and the logical IF statement as an alternative to the arithmetic IF statement.  FORTRAN IV was eventually released in 1962, first for the IBM 7030 (\"Stretch\") computer, followed by versions for the IBM 7090, IBM 7094, and later for the IBM 1401 in 1966.\n\nBy 1965, FORTRAN IV was supposed to be compliant with the standard being developed by the American Standards Association X3.4.3 FORTRAN Working Group.\n\nAt about this time FORTRAN IV had started to become an important educational tool and implementations such as the University of Waterloo's WATFOR and WATFIV were created to simplify the complex compile and link processes of earlier compilers.\n\nFORTRAN 66\n\nPerhaps the most significant development in the early history of FORTRAN was the decision by the American Standards Association (now American National Standards Institute (ANSI)) to form a committee sponsored by BEMA, the Business Equipment Manufacturers Association, to develop an American Standard Fortran.  The resulting two standards, approved in March 1966, defined two languages, FORTRAN (based on FORTRAN IV, which had served as a de facto standard), and Basic FORTRAN (based on FORTRAN II, but stripped of its machine-dependent features).  The FORTRAN defined by the first standard, officially denoted X3.9-1966, became known as FORTRAN 66 (although many continued to term it FORTRAN IV, the language on which the standard was largely based).  FORTRAN 66 effectively became the first industry-standard version of FORTRAN. FORTRAN 66 included:\n\n* Main program, SUBROUTINE, FUNCTION, and BLOCK DATA program units\n* INTEGER, REAL, DOUBLE PRECISION, COMPLEX, and LOGICAL data types\n* COMMON, DIMENSION, and EQUIVALENCE statements\n* DATA statement for specifying initial values\n* Intrinsic and EXTERNAL (e.g., library) functions\n* Assignment statement\n* GO TO, computed GO TO, assigned GO TO, and ASSIGN statements\n* Logical IF and arithmetic (three-way) IF statements\n* DO loop statement\n* READ, WRITE, BACKSPACE, REWIND, and ENDFILE statements for sequential I/O\n* FORMAT statement and assigned format\n* CALL, RETURN, PAUSE, and STOP statements\n* Hollerith constants in DATA and FORMAT statements, and as arguments to procedures\n* Identifiers of up to six characters in length\n* Comment lines\n* END line\n\nFORTRAN 77\n\nAfter the release of the FORTRAN 66 standard, compiler vendors introduced several extensions to Standard Fortran, prompting ANSI committee X3J3 in 1969 to begin work on revising the 1966 standard, under sponsorship of CBEMA, the Computer Business Equipment Manufacturers Association (formerly BEMA).  Final drafts of this revised standard circulated in 1977, leading to formal approval of the new FORTRAN standard in April 1978.  The new standard, called FORTRAN 77 and officially denoted X3.9-1978, added a number of significant features to address many of the shortcomings of FORTRAN 66:\n\n* Block IF and END IF statements, with optional ELSE and ELSE IF clauses, to provide improved language support for structured programming\n* DO loop extensions, including parameter expressions, negative increments, and zero trip counts\n* OPEN, CLOSE, and INQUIRE statements for improved I/O capability\n* Direct-access file I/O\n* IMPLICIT statement, to override implicit conventions that undeclared variables are INTEGER if their name begins with I, J, K, L, M, or N (and REAL otherwise)\n* CHARACTER data type, replacing Hollerith strings with vastly expanded facilities for character input and output and processing of character-based data\n* PARAMETER statement for specifying constants\n* SAVE statement for persistent local variables\n* Generic names for intrinsic functions (e.g. SQRT also accepts arguments of other types, such as COMPLEX or REAL*16 ).\n* A set of intrinsics (LGE, LGT, LLE, LLT) for lexical comparison of strings, based upon the ASCII collating sequence. (These ASCII functions were demanded by the U.S. Department of Defense, in their conditional approval vote.)\n\nIn this revision of the standard, a number of features were removed or altered in a manner that might invalidate formerly standard-conforming programs.\n(Removal was the only allowable alternative to X3J3 at that time, since the concept of \"deprecation\" was not yet available for ANSI standards.)\nWhile most of the 24 items in the conflict list (see Appendix A2 of X3.9-1978) addressed loopholes or pathological cases permitted by the prior standard but rarely used, a small number of specific capabilities were deliberately removed, such as:\n\n* Hollerith constants and Hollerith data, such as       GREET \n 12HHELLO THERE!\n* Reading into an H edit (Hollerith field) descriptor in a FORMAT specification\n* Overindexing of array bounds by subscripts \n      DIMENSION A(10,5)\n      Y=  A(11,1)\n\n* Transfer of control out of and back into the range of a DO loop (also known as \"Extended Range\")\n\nVariants: Minnesota FORTRAN\n\nControl Data Corporation computers had another version of FORTRAN 77, called Minnesota FORTRAN (MNF), designed especially for student use, with variations in output constructs, special uses of COMMONs and DATA statements, optimizations code levels for compiling, and detailed error listings, extensive warning messages, and debugs.\n\nTransition to ANSI Standard Fortran\n\nThe development of a revised standard to succeed FORTRAN 77 would be repeatedly delayed as the standardization process struggled to keep up with rapid changes in computing and programming practice.  In the meantime, as the \"Standard FORTRAN\" for nearly fifteen years, FORTRAN 77 would become the historically most important dialect.\n\nAn important practical extension to FORTRAN 77 was the release of MIL-STD-1753 in 1978. This specification, developed by the U.S. Department of Defense, standardized a number of features implemented by most FORTRAN 77 compilers but not included in the ANSI FORTRAN 77 standard. These features would eventually be incorporated into the Fortran 90 standard.\n\n* DO WHILE and END DO statements\n* INCLUDE statement\n* IMPLICIT NONE variant of the IMPLICIT statement\n* Bit manipulation intrinsic functions, based on similar functions included in Industrial Real-Time Fortran (ANSI/ISA S61.1 (1976))\n\nThe IEEE 1003.9 POSIX Standard, released in 1991, provided a simple means for FORTRAN 77 programmers to issue POSIX system calls. Over 100 calls were defined in the document allowing access to POSIX-compatible process control, signal handling, file system control, device control, procedure pointing, and stream I/O in a portable manner.\n\nFortran 90\n\nThe much-delayed successor to FORTRAN 77, informally known as Fortran 90 (and prior to that, Fortran 8X), was finally released as ISO/IEC standard 1539:1991 in 1991 and an ANSI Standard in 1992.  In addition to changing the official spelling from FORTRAN to Fortran, this major revision added many new features to reflect the significant changes in programming practice that had evolved since the 1978 standard:\n\n* Free-form source input, also with lowercase Fortran keywords\n* Identifiers up to 31 characters in length (In the previous standard, it was only six characters).\n* Inline comments\n* Ability to operate on arrays (or array sections) as a whole, thus greatly simplifying math and engineering computations.\n** whole, partial and masked array assignment statements and array expressions, such as    X(1:N)=R(1:N)*COS(A(1:N)) \n** WHERE statement for selective array assignment\n** array-valued constants and expressions,\n** user-defined array-valued functions and array constructors.\n* RECURSIVE procedures\n* Modules, to group related procedures and data together, and make them available to other program units, including the capability to limit the accessibility to only specific parts of the module.\n* A vastly improved argument-passing mechanism, allowing interfaces to be checked at compile time\n* User-written interfaces for generic procedures\n* Operator overloading\n* Derived (structured) data types\n* New data type declaration syntax, to specify the data type and other attributes of variables\n* Dynamic memory allocation by means of the ALLOCATABLE attribute and the ALLOCATE and DEALLOCATE statements\n* POINTER attribute, pointer assignment, and NULLIFY statement to facilitate the creation and manipulation of dynamic data structures\n* Structured looping constructs, with an END DO statement for loop termination, and EXIT and CYCLE statements for terminating normal DO loop iterations in an orderly way\n* SELECT . . . CASE construct for multi-way selection\n* Portable specification of numerical precision under the user's control\n* New and enhanced intrinsic procedures.\n\nObsolescence and deletions\n\nUnlike the prior revision, Fortran 90 removed no features. (Appendix B.1 says, \"The list of deleted features in this standard is empty.\") Any standard-conforming FORTRAN 77 program is also standard-conforming under Fortran 90, and either standard should be usable to define its behavior.\n\nA small set of features were identified as \"obsolescent\"\nand expected to be removed in a future standard.\n\n\"Hello world\" example\n\nprogram helloworld\n     print *, \"Hello world!\"\nend program helloworld \n\nFortran 95\n\nFortran 95, published officially as ISO/IEC 1539-1:1997, was a minor revision, mostly to resolve some outstanding issues from the Fortran 90 standard.  Nevertheless, Fortran 95 also added a number of extensions, notably from the High Performance Fortran specification:\n\n* FORALL and nested WHERE constructs to aid vectorization\n* User-defined PURE and ELEMENTAL procedures\n* Default initialization of derived type components, including pointer initialization\n* Expanded the ability to use initialization expressions for data objects\n* Initialization of pointers to NULL()\n* Clearly defined that ALLOCATABLE arrays are automatically deallocated when they go out of scope.\n\nA number of intrinsic functions were extended (for example a dim argument was added to the maxloc intrinsic).\n\nSeveral features noted in Fortran 90 to be \"obsolescent\" were removed from Fortran 95:\n\n* DO statements using REAL and DOUBLE PRECISION index variables\n* Branching to an END IF statement from outside its block\n* PAUSE statement\n* ASSIGN and assigned GO TO statement, and assigned format specifiers\n* H edit descriptor.\n\nAn important supplement to Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally known as the Allocatable TR.  This specification defined enhanced use of ALLOCATABLE arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers.  Such uses include ALLOCATABLE arrays as derived type components, in procedure dummy argument lists, and as function return values.  (ALLOCATABLE arrays are preferable to POINTER-based arrays because ALLOCATABLE arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage.  In addition, elements of allocatable arrays are contiguous, and aliasing is not an issue for optimization of array references, allowing compilers to generate faster code than in the case of pointers.)\n\nAnother important supplement to Fortran 95 was the ISO technical report TR-15580: Floating-point exception handling, informally known as the IEEE TR.  This specification defined support for IEEE floating-point arithmetic and floating point exception handling.\n\nConditional compilation and varying length strings\n\nIn addition to the mandatory \"Base language\"\n(defined in ISO/IEC 1539-1 : 1997),\nthe Fortran 95 language also includes two optional modules:\n* Varying length character strings (ISO/IEC 1539-2 : 2000)\n* Conditional compilation (ISO/IEC 1539-3 : 1998)\nwhich, together, compose the multi-part International Standard (ISO/IEC 1539).\n\nAccording to the standards developers, \"the optional parts describe self-contained features which have been requested by a substantial body of users and/or implementors, but which are not deemed to be of sufficient generality for them to be required in all standard-conforming Fortran compilers.\" Nevertheless, if a standard-conforming Fortran does provide such options, then they \"must be provided in accordance with the description of those facilities in the appropriate Part of the Standard\".\n\nFortran 2003\n\nFortran 2003, officially published as ISO/IEC 1539-1:2004, is a major revision introducing many new features. A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (ISO/IEC JTC1/SC22/WG5) official Web site.[http://www.nag.co.uk/sc22wg5/ Fortran Working Group (WG5)]. It may also be downloaded as a [https://wg5-fortran.org/N1551-N1600/N1579.pdf PDF file], FTP.nag.co.uk\n\nFrom that article, the major enhancements for this revision include:\n\n* Derived type enhancements: parameterized derived types, improved control of accessibility, improved structure constructors, and finalizers\n* Object-oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures, providing complete support for abstract data types\n* Data manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, VOLATILE attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures\n* Input/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the FLUSH statement, regularization of keywords, and access to error messages\n* Procedure pointers\n* Support for IEEE floating-point arithmetic and floating point exception handling (incorporating TR 15580)\n* Interoperability with the C programming language\n* Support for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output\n* Enhanced integration with the host operating system: access to command line arguments, environment variables, and processor error messages\n\nAn important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran.  This report provided sub-modules, which make Fortran modules more similar to Modula-2 modules.  They are similar to Ada private child sub-units.  This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades.\n\nFortran 2008\n\nThe most recent standard, ISO/IEC 1539-1:2010, informally known as Fortran 2008, was approved in September 2010.N1836, Summary of Voting/Table of Replies on ISO/IEC FDIS 1539-1, Information technology – Programming languages – Fortran – Part 1: Base language [https://wg5-fortran.org/N1801-N1850/N1836.pdf]   As with Fortran 95, this is a minor upgrade, incorporating clarifications and corrections to Fortran 2003, as well as introducing a select few new capabilities.  The new capabilities include:\n\n* Sub-modules – additional structuring facilities for modules; supersedes ISO/IEC TR 19767:2005\n* Coarray Fortran – a parallel execution model\n* The DO CONCURRENT construct – for loop iterations with no interdependencies\n* The CONTIGUOUS attribute – to specify storage layout restrictions\n* The BLOCK construct – can contain declarations of objects with construct scope\n* Recursive allocatable components – as an alternative to recursive pointers in derived types\n\nThe Final Draft international Standard (FDIS) is available as document N1830.N1830, Information technology – Programming languages – Fortran – Part 1: Base language [ftp://ftp.nag.co.uk/sc22wg5/N1801-N1850/N1830.pdf]\n\nAn important supplement to Fortran 2008 is the ISO Technical Specification (TS) 29113 on Further Interoperability of Fortran with C,ISO page to [http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=45136 ISO/IEC DTS 29113, Further Interoperability of Fortran with C][https://wg5-fortran.org/N1901-N1950/N1917.pdf Draft of the Technical Specification (TS) 29113] which has been submitted to ISO in May 2012 for approval. The specification adds support for accessing the array descriptor from C and allows ignoring the type and rank of arguments.\n\nFortran 2018\n\nThe next revision of the language (Fortran 2018) was earlier referred to as Fortran 2015. It is a significant revision and is planned for release in mid-2018.\n\nFortran 2018 incorporates two previously published Technical Specifications:\n* ISO/IEC TS 29113:2012 Further Interoperability with C\n* ISO/IEC TS 18508:2015 Additional Parallel Features in Fortran\n\nAdditional changes and new features include support for ISO/IEC/IEEE 60559:2011, hexadecimal input/output, IMPLICIT NONE enhancements and other changes[http://j3-fortran.org/doc/year/18/18-007.pdf Fortran 2018 Draft], 28 December 2017\n\nScience and engineering\n\nAlthough a 1968 journal article by the authors of BASIC already described FORTRAN as \"old-fashioned\", since Fortran has been in use for several decades there is a vast body of Fortran software in daily use throughout the scientific and engineering communities. Jay Pasachoff wrote in 1984 that \"physics and astronomy students simply have to learn FORTRAN. So much exists in FORTRAN that it seems unlikely that scientists will change to Pascal, Modula-2, or whatever.\" In 1993, Cecil E. Leith called FORTRAN the \"mother tongue of scientific computing\" adding that its replacement by any other possible language \"may remain a forlorn hope\".  \n\nIt is the primary language for some of the most intensive super-computing tasks, such as astronomy, weather and climate modeling, numerical linear algebra (LAPACK), numerical libraries (IMSL and NAG), structural engineering, hydrological modeling, optimization, satellite simulation and data analysis, computational fluid dynamics, computational chemistry, computational economics and computational physics. Many of the floating-point benchmarks to gauge the performance of new computer processors such as [http://www.spec.org/cpu2006/CFP2006/ CFP2006], the floating-point component of the SPEC [http://www.spec.org/cpu2006/ CPU2006] benchmarks are written in Fortran.\n\nOn the other hand, more modern code generally uses large program libraries such as PETSc or Trilinos for linear algebra capabilities, METIS for graph partitioning, deal.II or FEniCS for mesh and finite element support, and other generic libraries. Since the late 1990s, almost all of the most widely used support libraries have been written in C and, more often, C++. Consequently, a growing fraction of scientific code is also written in these languages.  For this reason, facilities for inter-operation with C were added to Fortran 2003, and enhanced by ISO/IEC technical specification 29113, which will be incorporated into Fortran 2018. This shift is also evident in the selection of applications between the SPEC CPU 2000 and SPEC CPU 2006 floating point benchmarks.\n\nSoftware for NASA probes Voyager 1 and Voyager 2 was originally written in FORTRAN 5, and later ported to FORTRAN 77.  some of the software is still in Fortran and some has been ported to C.\n\nLanguage features\n\nThe precise characteristics and syntax of Fortran 95 are discussed in Fortran 95 language features.\n\nPortability\n\nPortability was a problem in the early days because there was no agreed standard not even IBM's reference manual and computer companies vied to differentiate their offerings from others by providing incompatible features.  Standards have improved portability.  The 1966 standard provided a reference syntax and semantics, but vendors continued to provide incompatible extensions.  Although careful programmers were coming to realize that use of incompatible extensions caused expensive portability problems, and were therefore using programs such as The PFORT Verifier, it was not until after the 1977 standard, when the National Bureau of Standards (now NIST) published FIPS PUB 69, that processors purchased by the U.S. Government were required to diagnose extensions of the standard.  Rather than offer two processors, essentially every compiler eventually had at least an option to diagnose extensions.\n\nIncompatible extensions were not the only portability problem.  For numerical calculations, it is important to take account of the characteristics of the arithmetic.  This was addressed by Fox et al. in the context of the 1966 standard by the PORT library.  The ideas therein became widely used, and were eventually incorporated into the 1990 standard by way of intrinsic inquiry functions.  The widespread (now almost universal) adoption of the IEEE 754 standard for binary floating-point arithmetic has essentially removed this problem.\n\nAccess to the computing environment (e.g., the program's command line, environment variables, textual explanation of error conditions) remained a problem until it was addressed by the 2003 standard.\n\nLarge collections of library software that could be described as being loosely related to engineering and scientific calculations, such as graphics libraries, have been written in C, and therefore access to them presented a portability problem.  This has been addressed by incorporation of C interoperability into the 2003 standard.\n\nIt is now possible (and relatively easy) to write an entirely portable program in Fortran, even without recourse to a preprocessor.\n\nVariants\n\nFortran 5\n\nFortran 5 was marketed by Data General Corp in the late 1970s and early 1980s, for the Nova, Eclipse, and MV line of computers.  It had an optimizing compiler that was quite good for minicomputers of its time.  The language most closely resembles FORTRAN 66.  The name is a pun on the earlier FORTRAN IV.\n\nFORTRAN V\n\nFORTRAN V was distributed by Control Data Corporation in 1968 for the CDC 6600 series. The language was based upon FORTRAN IV.\n\nUnivac also offered a compiler for the 1100 series known as FORTRAN V.  A spinoff of Univac Fortran V was Athena FORTRAN.\n\nFortran 6\n\nFortran 6 or Visual Fortran 2001 was licensed to Compaq by Microsoft. They have licensed Compaq Visual Fortran and have provided the Visual Studio 5 environment interface for Compaq v6 up to v6.1.\n\nSpecific variants\n\nVendors of high-performance scientific computers (e.g., Burroughs, Control Data Corporation (CDC), Cray, Honeywell, IBM, Texas Instruments, and UNIVAC) added extensions to Fortran to take advantage of special hardware features such as instruction cache, CPU pipelines, and vector arrays.  For example, one of IBM's FORTRAN compilers (H Extended IUP) had a level of optimization which reordered the machine code instructions to keep multiple internal arithmetic units busy simultaneously.  Another example is CFD, a special variant of FORTRAN designed specifically for the ILLIAC IV supercomputer, running at NASA's Ames Research Center.\nIBM Research Labs also developed an extended FORTRAN-based language called VECTRAN for processing vectors and matrices.\n\nObject-Oriented Fortran was an object-oriented extension of Fortran, in which data items can be grouped into objects, which can be instantiated and executed in parallel.  It was available for Sun, Iris, iPSC, and nCUBE, but is no longer supported.\n\nSuch machine-specific extensions have either disappeared over time or have had elements incorporated into the main standards. The major remaining extension is OpenMP, which is a cross-platform extension for shared memory programming.  One new extension, Coarray Fortran, is intended to support parallel programming.\n\nFOR TRANSIT for the IBM 650\n\nFOR TRANSIT was the name of a reduced version of the IBM 704 FORTRAN language,\nwhich was implemented for the IBM 650, using a translator program developed\nat Carnegie in the late 1950s.\"Internal Translator (IT) A Compiler for the IBM 650\",\nby A. J. Perlis, J. W. Smith, and H. R. Van Zoeren, Computation Center,\nCarnegie Institute of Technology\n\nThe following comment appears in the IBM Reference Manual (FOR TRANSIT Automatic Coding System C28-4038, Copyright 1957, 1959 by IBM):\nThe FORTRAN system was designed for a more complex machine than the 650, and consequently some of the 32 statements found in the FORTRAN Programmer's Reference Manual are not acceptable to the FOR TRANSIT system.  In addition, certain restrictions to the FORTRAN language have been added.  However, none of these restrictions make a source program written for FOR TRANSIT incompatible with the FORTRAN system for the 704.\n\nThe permissible statements were:\n\n* Arithmetic assignment statements, e.g., \n* \n* GO TO (n1, n2, ..., nm), i\n* IF (a) n1, n2, n3\n* \n* \n* DO n i = m1, m2\n* \n* \n* \n* \n* \n* \n\nUp to ten subroutines could be used in one program.\n\nFOR TRANSIT statements were limited to columns 7 through 56, only.\nPunched cards were used for input and output on the IBM 650.  Three passes were required to translate source code to the \"IT\" language, then to compile the IT statements into SOAP assembly language, and finally to produce the object program, which could then be loaded into the machine to run the program (using punched cards for data input, and outputting results onto punched cards).\n\nTwo versions existed for the 650s with a 2000 word memory drum:  FOR TRANSIT I (S) and FOR TRANSIT II, the latter for machines equipped with indexing registers and automatic floating point decimal (bi-quinary) arithmetic.  Appendix A of the manual included wiring diagrams for the IBM 533 card reader/punch control panel.\n\nFortran-based languages\n\nPrior to FORTRAN 77, a number of preprocessors were commonly used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler.  These preprocessors would typically support structured programming, variable names longer than six characters, additional data types, conditional compilation, and even macro capabilities.  Popular preprocessors included FLECS, iftran, MORTRAN, SFtran, S-Fortran, Ratfor, and Ratfiv.  Ratfor and Ratfiv, for example, implemented a C-like language, outputting preprocessed code in standard FORTRAN 66.  Despite advances in the Fortran language, preprocessors continue to be used for conditional compilation and macro substitution.\n\nOne of the earliest versions of FORTRAN, introduced in the '60s, was popularly used in colleges and universities.  Developed, supported, and distributed by the University of Waterloo, WATFOR was based largely on FORTRAN IV.  A student using WATFOR could submit their batch FORTRAN job and, if there were no syntax errors, the program would move straight to execution.  This simplification allowed students to concentrate on their program's syntax and semantics, or execution logic flow, rather than dealing with submission Job Control Language (JCL), the compile/link-edit/execution successive process(es), or other complexities of the mainframe/minicomputer environment.  A down side to this simplified environment was that WATFOR was not a good choice for programmers needing the expanded abilities of their host processor(s), e.g., WATFOR typically had very limited access to I/O devices. WATFOR was succeeded by WATFIV and its later versions.\n\n  (line programming)\n\nLRLTRAN was developed at the Lawrence Radiation Laboratory to provide support for vector arithmetic and dynamic storage, among other extensions to support systems programming.  The distribution included the LTSS operating system.\n\nThe Fortran-95 Standard includes an optional Part 3 which defines an optional conditional compilation capability.  This capability is often referred to as \"CoCo\".\n\nMany Fortran compilers have integrated subsets of the C preprocessor into their systems.\n\nSIMSCRIPT is an application specific Fortran preprocessor for modeling and simulating large discrete systems.\n\nThe F programming language was designed to be a clean subset of Fortran 95 that attempted to remove the redundant, unstructured, and deprecated features of Fortran, such as the EQUIVALENCE statement.  F retains the array features added in Fortran 90, and removes control statements that were made obsolete by structured programming constructs added to both FORTRAN 77 and Fortran 90.  F is described by its creators as \"a compiled, structured, array programming language especially well suited to education and scientific computing\".\n\nLahey and Fujitsu teamed up to create Fortran for the Microsoft .NET Framework. Silverfrost FTN95 is also capable of creating .NET code.\n\nCode examples\n\nThe following program illustrates dynamic memory allocation and array-based operations, two features introduced with Fortran 90.  Particularly noteworthy is the absence of DO loops and IF/THEN statements in manipulating the array; mathematical operations are applied to the array as a whole.  Also apparent is the use of descriptive variable names and general code formatting that conform with contemporary programming style.  This example computes an average over data entered interactively.\n\nprogram average\n\n  ! Read in some numbers and take the average\n  ! As written, if there are no data points, an average of zero is returned\n  ! While this may not be desired behavior, it keeps this example simple\n\n  implicit none\n\n  real, dimension(:), allocatable :: points\n  integer                         :: number_of_points\n  real                            :: average_points0., positive_average\n0., negative_average=0.\n\n  write (*,*) \"Input number of points to average:\"\n  read  (*,*) number_of_points\n\n  allocate (points(number_of_points))\n\n  write (*,*) \"Enter the points to average:\"\n  read  (*,*) points\n\n  ! Take the average by summing points and dividing by number_of_points\n  if (number_of_points > 0) average_points = sum(points) / number_of_points\n\n  ! Now form average over positive and negative points only\n  if (count(points > 0.) > 0) then\n     positive_average = sum(points, points > 0.) / count(points > 0.)\n  end if\n\n  if (count(points  0) then\n     negative_average = sum(points, points \n\nHumor\n\nDuring the same FORTRAN standards committee meeting at which the name \"FORTRAN 77\" was chosen, a satirical technical proposal was incorporated into the official distribution bearing the title \"Letter O Considered Harmful\".  This proposal purported to address the confusion that sometimes arises between the letter \"O\" and the numeral zero, by eliminating the letter from allowable variable names.  However, the method proposed was to eliminate the letter from the character set entirely (thereby retaining 48 as the number of lexical characters, which the colon had increased to 49).  This was considered beneficial in that it would promote structured programming, by making it impossible to use the notorious GO TO statement as before. (Troublesome FORMAT statements would also be eliminated.)  It was noted that this \"might invalidate some existing programs\" but that most of these \"probably were non-conforming, anyway\".X3J3 post-meeting distribution for meeting held at Brookhaven National Laboratory in November 1976.\"The obliteration of O\", Computer Weekly, 3 March 1977.\n\nDuring the standards committee battle over whether the \"minimum trip count\" for the FORTRAN 77 DO statement should be zero (allowing no execution of the block) or one (the \"plunge-ahead\" DO), another facetious alternative was proposed (by Loren Meissner) to have the minimum be two since there is no need for a loop if it is only executed once.\n\nWhen assumed-length arrays were being added, there was a dispute as to the appropriate character to separate upper and lower bounds.\nIn a comment examining these arguments, Dr. Walt Brainerd penned an article entitled \"Astronomy vs. Gastroenterology\"\nbecause some proponents had suggested using the star or asterisk (\"*\"), while others favored the colon (\":\").\n\nIn Fortran 77, variable names beginning with the letters I–N had a default type of integer, while variables starting with any other letters defaulted to real, although programmers could override the defaults with an explicit declaration. This led to the joke: \"In Fortran, GOD is REAL (unless declared INTEGER).\"",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Fortran" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=11168" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Fortran (; formerly FORTRAN, derived from Formula Translation) is a general-purpose, imperative programming language that is especially suited to numeric computation and scientific computing. Originally developed by IBM in the 1950s for scientific and engineering applications, FORTRAN came to dominate this area of programming early on and has been in continuous use for over half a century in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics, computational physics, crystallography and computational chemistry. It is a popular language for high-performance computing and is used for programs that benchmark and rank the world's fastest supercomputers.\n\nFortran encompasses a lineage of versions, each of which evolved to add extensions to the language while usually retaining compatibility with prior versions.  Successive versions have added support for structured programming\nand processing of character-based data (FORTRAN 77), array programming, modular programming and generic programming (Fortran 90), high performance Fortran (Fortran 95), object-oriented programming (Fortran 2003) and concurrent programming (Fortran 2008).\n\nNaming \n\nThe names of earlier versions of the language through FORTRAN 77 were conventionally spelled in all-capitals (FORTRAN 77 was the last version in which the use of lowercase letters in keywords was strictly non-standard).  The capitalization has been dropped in referring to newer versions beginning with Fortran 90. The official language standards now refer to the language as \"Fortran\" rather than all-caps \"FORTRAN\".\n\nHistory\n\nIn late 1953, John W. Backus submitted a proposal to his superiors at IBM to develop a more practical alternative to assembly language for programming their IBM 704 mainframe computer. Backus' historic FORTRAN team consisted of programmers Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Lois Haibt, and David Sayre.  Its concepts included easier entry of equations into a computer, an idea developed by J. Halcombe Laning and demonstrated in the Laning and Zierler system of 1952.Mindell, David, Digital Apollo, MIT Press, Cambridge MA, 2008, p.99.\n\nA draft specification for The IBM Mathematical Formula Translating System was completed by mid-1954.  The first manual for FORTRAN appeared in October 1956, with the first FORTRAN compiler delivered in April 1957.  This was the first optimizing compiler, because customers were reluctant to use a high-level programming language unless its compiler could generate code with performance comparable to that of hand-coded assembly language.[http://polaris.cs.uiuc.edu/publications/c1070.pdf The Fortran I Compiler] \"The Fortran I compiler was the first major project in code optimization. It tackled problems of crucial importance whose general solution was an important research focus in compiler technology for several decades. Many classical techniques for compiler analysis and optimization can trace their origins and inspiration to the Fortran I compiler.\"\n\nWhile the community was skeptical that this new method could possibly outperform hand-coding, it reduced the number of programming statements necessary to operate a machine by a factor of 20, and quickly gained acceptance.  John Backus said during a 1979 interview with Think, the IBM employee magazine, \"Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701, writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs.\"\n\nThe language was widely adopted by scientists for writing numerically intensive programs, which encouraged compiler writers to produce compilers that could generate faster and more efficient code.  The inclusion of a complex number data type in the language made Fortran especially suited to technical applications such as electrical engineering.\n\nBy 1960, versions of FORTRAN were available for the IBM 709, 650, 1620, and 7090 computers.  Significantly, the increasing popularity of FORTRAN spurred competing computer manufacturers to provide FORTRAN compilers for their machines, so that by 1963 over 40 FORTRAN compilers existed.  For these reasons, FORTRAN is considered to be the first widely used  programming language supported across a variety of computer architectures.\n\nThe development of Fortran paralleled the early evolution of compiler technology, and many advances in the theory and design of compilers were specifically motivated by the need to generate efficient code for Fortran programs.\n\nFORTRAN\n\nThe initial release of FORTRAN for the IBM 704 contained 32 statements, including:\n\n* DIMENSION and EQUIVALENCE statements\n* Assignment statements\n* Three-way arithmetic IF statement, which passed control to one of three locations in the program depending on whether the result of the arithmetic statement was negative, zero, or positive\n* IF statements for checking exceptions (ACCUMULATOR OVERFLOW, QUOTIENT OVERFLOW, and DIVIDE CHECK); and IF statements for manipulating sense switches and sense lights\n* GO TO, computed GO TO, ASSIGN, and assigned GO TO\n* DO loops\n* Formatted I/O: FORMAT, READ, READ INPUT TAPE, WRITE, WRITE OUTPUT TAPE, PRINT, and PUNCH\n* Unformatted I/O: READ TAPE, READ DRUM, WRITE TAPE, and WRITE DRUM\n* Other I/O: END FILE, REWIND, and BACKSPACE\n* PAUSE, STOP, and CONTINUE\n* FREQUENCY statement (for providing optimization hints to the compiler).\n\nThe arithmetic IF statement was reminiscent of (but not readily implementable by) a three-way comparison instruction (CAS Compare Accumulator with Storage) available on the 704. The statement provided the only way to compare numbers by testing their difference, with an attendant risk of overflow. This deficiency was later overcome by \"logical\" facilities introduced in FORTRAN IV.\n\nThe FREQUENCY statement was used originally (and optionally) to give branch probabilities for the three branch cases of the arithmetic IF statement. The first FORTRAN compiler used this weighting to perform at compile time a Monte Carlo simulation of the generated code, the results of which were used to optimize the placement of basic blocks in memory a very sophisticated optimization for its time. The Monte Carlo technique is documented in Backus et al.'s paper on this original implementation, The FORTRAN Automatic Coding System:\n\nThe fundamental unit of program is the basic block; a basic block is a stretch of program which has one entry point and one exit point. The purpose of section 4 is to prepare for section 5 a table of predecessors (PRED table) which enumerates the basic blocks and lists for every basic block each of the basic blocks which can be its immediate predecessor in flow, together with the absolute frequency of each such basic block link. This table is obtained by running the program once in Monte-Carlo fashion, in which the outcome of conditional transfers arising out of IF-type statements and computed GO TO's is determined by a random number generator suitably weighted according to whatever FREQUENCY statements have been provided. Online at [http://www.softwarepreservation.org/projects/FORTRAN/paper/BackusEtAl-FortranAutomaticCodingSystem-1957.pdf], [http://archive.computerhistory.org/resources/text/Fortran/102663113.05.01.acc.pdf]\n\nMany years later, the FREQUENCY statement had no effect on the code, and was treated as a comment statement, since the compilers no longer did this kind of compile-time simulation. A similar fate has befallen compiler hints in several other programming languages; for example C's register keyword.\n\nThe first FORTRAN compiler reported diagnostic information by halting the program when an error was found and outputting an error code on its console. That code could be looked up by the programmer in an error messages table in the operator's manual, providing them with a brief description of the problem.\n\nFixed layout and punched cards \n\nBefore the development of disk files, text editors and terminals, programs were most often entered on a keypunch keyboard onto 80-column punched cards, one line to a card. The resulting deck of cards would be fed into a card reader to be compiled. Punched card codes included no lower-case letters or many special characters, and special versions of the IBM 026 keypunch were offered that would correctly print the re-purposed special characters used in FORTRAN.\n\nReflecting punched card input practice, Fortran programs were originally written in a fixed-column format, with the first 72 columns read into twelve 36-bit words.\n\nA letter \"C\" in column 1 caused the entire card to be treated as a comment and ignored by the compiler. Otherwise, the columns of the card were divided into four fields:\n* 1 to 5 were the label field: a sequence of digits here was taken as a label for use in DO or control statements such as GO TO and IF, or to identify a FORMAT statement referred to in a WRITE or READ statement. Leading zeros are ignored and 0 is not a valid label number. \n* 6 was a continuation field: a character other than a blank or a zero here caused the card to be taken as a continuation of the statement on the prior card. The continuation cards were usually numbered 1, 2, etc. and the starting card might therefore have zero in its continuation column - which is not a continuation of its preceding card. \n* 7 to 72 served as the statement field. \n* 73 to 80 were ignored (the IBM 704's card reader only used 72 columns).[http://www.mirrorservice.org/sites/www.bitsavers.org/pdf/ibm/7090/22-6528-4_7090Manual.pdf Reference Manual, IBM 7090 Data Processing System], 1961, IBM A22-6528-3.\n\nColumns 73 to 80 could therefore be used for identification information, such as punching a sequence number or text, which could be used to re-order cards if a stack of cards was dropped; though in practice this was reserved for stable, production programs. An IBM 519 could be used to copy a program deck and add sequence numbers. Some early compilers, e.g., the IBM 650's, had additional restrictions due to limitations on their card readers. Keypunches could be programmed to tab to column 7 and skip out after column 72. Later compilers relaxed most fixed-format restrictions, and the requirement was eliminated in the Fortran 90 standard.\n\nWithin the statement field, whitespace characters (blanks) were ignored outside a text literal. This allowed omitting spaces between tokens for brevity or including spaces within identifiers for clarity. For example, AVG OF X was a valid identifier, equivalent to AVGOFX, and 101010DO101I\n1,101 was a valid statement, equivalent to \n10101    DO 101   I \n 1, 101 because the zero in column 6 is treated as if it were a space (!), while 101010DO101I\n1.101 was instead 10101    DO101I \n 1.101, the assignment of 1.101 to a variable called DO101I. Note the slight visual difference between a comma and a period.\n\nHollerith strings, originally allowed only in FORMAT and DATA statements, were prefixed by a character count and the letter H (e.g., 26HTHIS IS ALPHANUMERIC DATA.), allowing blanks to be retained within the character string. Miscounts were a problem.\n\nFORTRAN II\n\nIBM's FORTRAN II appeared in 1958.  The main enhancement was to support procedural programming by allowing user-written subroutines and functions which returned values, with parameters passed by reference.  The COMMON statement provided a way for subroutines to access common (or global) variables. Six new statements were introduced:\n\n* SUBROUTINE, FUNCTION, and END\n* CALL and RETURN\n* COMMON\n\nOver the next few years, FORTRAN II would also add support for the DOUBLE PRECISION and COMPLEX data types.\n\nEarly FORTRAN compilers supported no recursion in subroutines. Early computer architectures supported no concept of a stack, and when they did directly support subroutine calls, the return location was often stored in one fixed location adjacent to the subroutine code (e.g. the IBM 1130) or a specific machine register (IBM 360 et seq), which only allows recursion if a stack is maintained by software and the return address is stored on the stack before the call is made and restored after the call returns. Although not specified in Fortran 77, many F77 compilers supported recursion as an option, and the Burroughs mainframes, designed with recursion built-in, did so by default. It became a standard in Fortran 90 via the new keyword RECURSIVE.\n\nSimple FORTRAN II program\n\nThis program, for Heron's formula, reads data on a tape reel containing three 5-digit integers A, B, and C as input. There are no \"type\" declarations available: variables whose name starts with I, J, K, L, M, or N are \"fixed-point\" (i.e. integers), otherwise floating-point. Since integers are to be processed in this example, the names of the variables start with the letter \"I\". The name of a variable must start with a letter and can continue with both letters and digits, up to a limit of six characters in FORTRAN II.  If A, B, and C cannot represent the sides of a triangle in plane geometry, then the program's execution will end with an error code of \"STOP 1\".  Otherwise, an output line will be printed showing the input values for A, B, and C, followed by the computed AREA of the triangle as a floating-point number occupying ten spaces along the line of output and showing 2 digits after the decimal point, the .2 in F10.2 of the FORMAT statement with label 601.\n\nC AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION\nC INPUT - TAPE READER UNIT 5, INTEGER INPUT\nC OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT\nC INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING\n      READ INPUT TAPE 5, 501, IA, IB, IC\n  501 FORMAT (3I5)\nC IA, IB, AND IC MAY NOT BE NEGATIVE OR ZERO\nC FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE\nC MUST BE GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO\n      IF (IA) 777, 777, 701\n  701 IF (IB) 777, 777, 702\n  702 IF (IC) 777, 777, 703\n  703 IF (IA+IB-IC) 777, 777, 704\n  704 IF (IA+IC-IB) 777, 777, 705\n  705 IF (IB+IC-IA) 777, 777, 799\n  777 STOP 1\nC USING HERON'S FORMULA WE CALCULATE THE\nC AREA OF THE TRIANGLE\n  799 S = FLOATF (IA + IB + IC) / 2.0\n      AREA = SQRTF( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) *\n     +     (S - FLOATF(IC)))\n      WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA\n  601 FORMAT (4H A,I5,5H  B\n ,I5,5H  C,I5,8H  AREA\n ,F10.2,\n     +        13H SQUARE UNITS)\n      STOP\n      END\n\nFORTRAN III\n\nIBM also developed a FORTRAN III in 1958 that allowed for inline assembly code among other features; however, this version was never released as a product.  Like the 704 FORTRAN and FORTRAN II, FORTRAN III included machine-dependent features that made code written in it unportable from machine to machine.  Early versions of FORTRAN provided by other vendors suffered from the same disadvantage.\n\nIBM 1401 FORTRAN\n\nFORTRAN was provided for the IBM 1401 computer by an innovative 63-phase compiler that ran entirely in its core memory of only 8000 (six-bit) characters.  The compiler could be run from tape, or from a 2200-card deck; it used no further tape or disk storage.  It kept the program in memory and loaded overlays that gradually transformed it, in place, into executable form, as described by Haines. \nThis article was reprinted, edited, in both editions of Anatomy of a Compiler  and in the IBM manual \"Fortran Specifications and Operating Procedures, IBM 1401\".  The executable form was not entirely machine language; rather, floating-point arithmetic, sub-scripting, input/output, and function references were interpreted, preceeding UCSD Pascal P-code by two decades.\n\nIBM later provided a FORTRAN IV compiler for the 1400 series of computers.\n\nFORTRAN IV\n\nStarting in 1961, as a result of customer demands, IBM began development of a FORTRAN IV that removed the machine-dependent features of FORTRAN II (such as READ INPUT TAPE), while adding new features such as a LOGICAL data type, logical Boolean expressions and the logical IF statement as an alternative to the arithmetic IF statement.  FORTRAN IV was eventually released in 1962, first for the IBM 7030 (\"Stretch\") computer, followed by versions for the IBM 7090, IBM 7094, and later for the IBM 1401 in 1966.\n\nBy 1965, FORTRAN IV was supposed to be compliant with the standard being developed by the American Standards Association X3.4.3 FORTRAN Working Group.\n\nAt about this time FORTRAN IV had started to become an important educational tool and implementations such as the University of Waterloo's WATFOR and WATFIV were created to simplify the complex compile and link processes of earlier compilers.\n\nFORTRAN 66\n\nPerhaps the most significant development in the early history of FORTRAN was the decision by the American Standards Association (now American National Standards Institute (ANSI)) to form a committee sponsored by BEMA, the Business Equipment Manufacturers Association, to develop an American Standard Fortran.  The resulting two standards, approved in March 1966, defined two languages, FORTRAN (based on FORTRAN IV, which had served as a de facto standard), and Basic FORTRAN (based on FORTRAN II, but stripped of its machine-dependent features).  The FORTRAN defined by the first standard, officially denoted X3.9-1966, became known as FORTRAN 66 (although many continued to term it FORTRAN IV, the language on which the standard was largely based).  FORTRAN 66 effectively became the first industry-standard version of FORTRAN. FORTRAN 66 included:\n\n* Main program, SUBROUTINE, FUNCTION, and BLOCK DATA program units\n* INTEGER, REAL, DOUBLE PRECISION, COMPLEX, and LOGICAL data types\n* COMMON, DIMENSION, and EQUIVALENCE statements\n* DATA statement for specifying initial values\n* Intrinsic and EXTERNAL (e.g., library) functions\n* Assignment statement\n* GO TO, computed GO TO, assigned GO TO, and ASSIGN statements\n* Logical IF and arithmetic (three-way) IF statements\n* DO loop statement\n* READ, WRITE, BACKSPACE, REWIND, and ENDFILE statements for sequential I/O\n* FORMAT statement and assigned format\n* CALL, RETURN, PAUSE, and STOP statements\n* Hollerith constants in DATA and FORMAT statements, and as arguments to procedures\n* Identifiers of up to six characters in length\n* Comment lines\n* END line\n\nFORTRAN 77\n\nAfter the release of the FORTRAN 66 standard, compiler vendors introduced several extensions to Standard Fortran, prompting ANSI committee X3J3 in 1969 to begin work on revising the 1966 standard, under sponsorship of CBEMA, the Computer Business Equipment Manufacturers Association (formerly BEMA).  Final drafts of this revised standard circulated in 1977, leading to formal approval of the new FORTRAN standard in April 1978.  The new standard, called FORTRAN 77 and officially denoted X3.9-1978, added a number of significant features to address many of the shortcomings of FORTRAN 66:\n\n* Block IF and END IF statements, with optional ELSE and ELSE IF clauses, to provide improved language support for structured programming\n* DO loop extensions, including parameter expressions, negative increments, and zero trip counts\n* OPEN, CLOSE, and INQUIRE statements for improved I/O capability\n* Direct-access file I/O\n* IMPLICIT statement, to override implicit conventions that undeclared variables are INTEGER if their name begins with I, J, K, L, M, or N (and REAL otherwise)\n* CHARACTER data type, replacing Hollerith strings with vastly expanded facilities for character input and output and processing of character-based data\n* PARAMETER statement for specifying constants\n* SAVE statement for persistent local variables\n* Generic names for intrinsic functions (e.g. SQRT also accepts arguments of other types, such as COMPLEX or REAL*16 ).\n* A set of intrinsics (LGE, LGT, LLE, LLT) for lexical comparison of strings, based upon the ASCII collating sequence. (These ASCII functions were demanded by the U.S. Department of Defense, in their conditional approval vote.)\n\nIn this revision of the standard, a number of features were removed or altered in a manner that might invalidate formerly standard-conforming programs.\n(Removal was the only allowable alternative to X3J3 at that time, since the concept of \"deprecation\" was not yet available for ANSI standards.)\nWhile most of the 24 items in the conflict list (see Appendix A2 of X3.9-1978) addressed loopholes or pathological cases permitted by the prior standard but rarely used, a small number of specific capabilities were deliberately removed, such as:\n\n* Hollerith constants and Hollerith data, such as       GREET \n 12HHELLO THERE!\n* Reading into an H edit (Hollerith field) descriptor in a FORMAT specification\n* Overindexing of array bounds by subscripts \n      DIMENSION A(10,5)\n      Y=  A(11,1)\n\n* Transfer of control out of and back into the range of a DO loop (also known as \"Extended Range\")\n\nVariants: Minnesota FORTRAN\n\nControl Data Corporation computers had another version of FORTRAN 77, called Minnesota FORTRAN (MNF), designed especially for student use, with variations in output constructs, special uses of COMMONs and DATA statements, optimizations code levels for compiling, and detailed error listings, extensive warning messages, and debugs.\n\nTransition to ANSI Standard Fortran\n\nThe development of a revised standard to succeed FORTRAN 77 would be repeatedly delayed as the standardization process struggled to keep up with rapid changes in computing and programming practice.  In the meantime, as the \"Standard FORTRAN\" for nearly fifteen years, FORTRAN 77 would become the historically most important dialect.\n\nAn important practical extension to FORTRAN 77 was the release of MIL-STD-1753 in 1978. This specification, developed by the U.S. Department of Defense, standardized a number of features implemented by most FORTRAN 77 compilers but not included in the ANSI FORTRAN 77 standard. These features would eventually be incorporated into the Fortran 90 standard.\n\n* DO WHILE and END DO statements\n* INCLUDE statement\n* IMPLICIT NONE variant of the IMPLICIT statement\n* Bit manipulation intrinsic functions, based on similar functions included in Industrial Real-Time Fortran (ANSI/ISA S61.1 (1976))\n\nThe IEEE 1003.9 POSIX Standard, released in 1991, provided a simple means for FORTRAN 77 programmers to issue POSIX system calls. Over 100 calls were defined in the document allowing access to POSIX-compatible process control, signal handling, file system control, device control, procedure pointing, and stream I/O in a portable manner.\n\nFortran 90\n\nThe much-delayed successor to FORTRAN 77, informally known as Fortran 90 (and prior to that, Fortran 8X), was finally released as ISO/IEC standard 1539:1991 in 1991 and an ANSI Standard in 1992.  In addition to changing the official spelling from FORTRAN to Fortran, this major revision added many new features to reflect the significant changes in programming practice that had evolved since the 1978 standard:\n\n* Free-form source input, also with lowercase Fortran keywords\n* Identifiers up to 31 characters in length (In the previous standard, it was only six characters).\n* Inline comments\n* Ability to operate on arrays (or array sections) as a whole, thus greatly simplifying math and engineering computations.\n** whole, partial and masked array assignment statements and array expressions, such as    X(1:N)=R(1:N)*COS(A(1:N)) \n** WHERE statement for selective array assignment\n** array-valued constants and expressions,\n** user-defined array-valued functions and array constructors.\n* RECURSIVE procedures\n* Modules, to group related procedures and data together, and make them available to other program units, including the capability to limit the accessibility to only specific parts of the module.\n* A vastly improved argument-passing mechanism, allowing interfaces to be checked at compile time\n* User-written interfaces for generic procedures\n* Operator overloading\n* Derived (structured) data types\n* New data type declaration syntax, to specify the data type and other attributes of variables\n* Dynamic memory allocation by means of the ALLOCATABLE attribute and the ALLOCATE and DEALLOCATE statements\n* POINTER attribute, pointer assignment, and NULLIFY statement to facilitate the creation and manipulation of dynamic data structures\n* Structured looping constructs, with an END DO statement for loop termination, and EXIT and CYCLE statements for terminating normal DO loop iterations in an orderly way\n* SELECT . . . CASE construct for multi-way selection\n* Portable specification of numerical precision under the user's control\n* New and enhanced intrinsic procedures.\n\nObsolescence and deletions\n\nUnlike the prior revision, Fortran 90 removed no features. (Appendix B.1 says, \"The list of deleted features in this standard is empty.\") Any standard-conforming FORTRAN 77 program is also standard-conforming under Fortran 90, and either standard should be usable to define its behavior.\n\nA small set of features were identified as \"obsolescent\"\nand expected to be removed in a future standard.\n\n\"Hello world\" example\n\nprogram helloworld\n     print *, \"Hello world!\"\nend program helloworld \n\nFortran 95\n\nFortran 95, published officially as ISO/IEC 1539-1:1997, was a minor revision, mostly to resolve some outstanding issues from the Fortran 90 standard.  Nevertheless, Fortran 95 also added a number of extensions, notably from the High Performance Fortran specification:\n\n* FORALL and nested WHERE constructs to aid vectorization\n* User-defined PURE and ELEMENTAL procedures\n* Default initialization of derived type components, including pointer initialization\n* Expanded the ability to use initialization expressions for data objects\n* Initialization of pointers to NULL()\n* Clearly defined that ALLOCATABLE arrays are automatically deallocated when they go out of scope.\n\nA number of intrinsic functions were extended (for example a dim argument was added to the maxloc intrinsic).\n\nSeveral features noted in Fortran 90 to be \"obsolescent\" were removed from Fortran 95:\n\n* DO statements using REAL and DOUBLE PRECISION index variables\n* Branching to an END IF statement from outside its block\n* PAUSE statement\n* ASSIGN and assigned GO TO statement, and assigned format specifiers\n* H edit descriptor.\n\nAn important supplement to Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally known as the Allocatable TR.  This specification defined enhanced use of ALLOCATABLE arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers.  Such uses include ALLOCATABLE arrays as derived type components, in procedure dummy argument lists, and as function return values.  (ALLOCATABLE arrays are preferable to POINTER-based arrays because ALLOCATABLE arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage.  In addition, elements of allocatable arrays are contiguous, and aliasing is not an issue for optimization of array references, allowing compilers to generate faster code than in the case of pointers.)\n\nAnother important supplement to Fortran 95 was the ISO technical report TR-15580: Floating-point exception handling, informally known as the IEEE TR.  This specification defined support for IEEE floating-point arithmetic and floating point exception handling.\n\nConditional compilation and varying length strings\n\nIn addition to the mandatory \"Base language\"\n(defined in ISO/IEC 1539-1 : 1997),\nthe Fortran 95 language also includes two optional modules:\n* Varying length character strings (ISO/IEC 1539-2 : 2000)\n* Conditional compilation (ISO/IEC 1539-3 : 1998)\nwhich, together, compose the multi-part International Standard (ISO/IEC 1539).\n\nAccording to the standards developers, \"the optional parts describe self-contained features which have been requested by a substantial body of users and/or implementors, but which are not deemed to be of sufficient generality for them to be required in all standard-conforming Fortran compilers.\" Nevertheless, if a standard-conforming Fortran does provide such options, then they \"must be provided in accordance with the description of those facilities in the appropriate Part of the Standard\".\n\nFortran 2003\n\nFortran 2003, officially published as ISO/IEC 1539-1:2004, is a major revision introducing many new features. A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (ISO/IEC JTC1/SC22/WG5) official Web site.[http://www.nag.co.uk/sc22wg5/ Fortran Working Group (WG5)]. It may also be downloaded as a [https://wg5-fortran.org/N1551-N1600/N1579.pdf PDF file], FTP.nag.co.uk\n\nFrom that article, the major enhancements for this revision include:\n\n* Derived type enhancements: parameterized derived types, improved control of accessibility, improved structure constructors, and finalizers\n* Object-oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures, providing complete support for abstract data types\n* Data manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, VOLATILE attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures\n* Input/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the FLUSH statement, regularization of keywords, and access to error messages\n* Procedure pointers\n* Support for IEEE floating-point arithmetic and floating point exception handling (incorporating TR 15580)\n* Interoperability with the C programming language\n* Support for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output\n* Enhanced integration with the host operating system: access to command line arguments, environment variables, and processor error messages\n\nAn important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran.  This report provided sub-modules, which make Fortran modules more similar to Modula-2 modules.  They are similar to Ada private child sub-units.  This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades.\n\nFortran 2008\n\nThe most recent standard, ISO/IEC 1539-1:2010, informally known as Fortran 2008, was approved in September 2010.N1836, Summary of Voting/Table of Replies on ISO/IEC FDIS 1539-1, Information technology – Programming languages – Fortran – Part 1: Base language [https://wg5-fortran.org/N1801-N1850/N1836.pdf]   As with Fortran 95, this is a minor upgrade, incorporating clarifications and corrections to Fortran 2003, as well as introducing a select few new capabilities.  The new capabilities include:\n\n* Sub-modules – additional structuring facilities for modules; supersedes ISO/IEC TR 19767:2005\n* Coarray Fortran – a parallel execution model\n* The DO CONCURRENT construct – for loop iterations with no interdependencies\n* The CONTIGUOUS attribute – to specify storage layout restrictions\n* The BLOCK construct – can contain declarations of objects with construct scope\n* Recursive allocatable components – as an alternative to recursive pointers in derived types\n\nThe Final Draft international Standard (FDIS) is available as document N1830.N1830, Information technology – Programming languages – Fortran – Part 1: Base language [ftp://ftp.nag.co.uk/sc22wg5/N1801-N1850/N1830.pdf]\n\nAn important supplement to Fortran 2008 is the ISO Technical Specification (TS) 29113 on Further Interoperability of Fortran with C,ISO page to [http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=45136 ISO/IEC DTS 29113, Further Interoperability of Fortran with C][https://wg5-fortran.org/N1901-N1950/N1917.pdf Draft of the Technical Specification (TS) 29113] which has been submitted to ISO in May 2012 for approval. The specification adds support for accessing the array descriptor from C and allows ignoring the type and rank of arguments.\n\nFortran 2018\n\nThe next revision of the language (Fortran 2018) was earlier referred to as Fortran 2015. It is a significant revision and is planned for release in mid-2018.\n\nFortran 2018 incorporates two previously published Technical Specifications:\n* ISO/IEC TS 29113:2012 Further Interoperability with C\n* ISO/IEC TS 18508:2015 Additional Parallel Features in Fortran\n\nAdditional changes and new features include support for ISO/IEC/IEEE 60559:2011, hexadecimal input/output, IMPLICIT NONE enhancements and other changes[http://j3-fortran.org/doc/year/18/18-007.pdf Fortran 2018 Draft], 28 December 2017\n\nScience and engineering\n\nAlthough a 1968 journal article by the authors of BASIC already described FORTRAN as \"old-fashioned\", since Fortran has been in use for several decades there is a vast body of Fortran software in daily use throughout the scientific and engineering communities. Jay Pasachoff wrote in 1984 that \"physics and astronomy students simply have to learn FORTRAN. So much exists in FORTRAN that it seems unlikely that scientists will change to Pascal, Modula-2, or whatever.\" In 1993, Cecil E. Leith called FORTRAN the \"mother tongue of scientific computing\" adding that its replacement by any other possible language \"may remain a forlorn hope\".  \n\nIt is the primary language for some of the most intensive super-computing tasks, such as astronomy, weather and climate modeling, numerical linear algebra (LAPACK), numerical libraries (IMSL and NAG), structural engineering, hydrological modeling, optimization, satellite simulation and data analysis, computational fluid dynamics, computational chemistry, computational economics and computational physics. Many of the floating-point benchmarks to gauge the performance of new computer processors such as [http://www.spec.org/cpu2006/CFP2006/ CFP2006], the floating-point component of the SPEC [http://www.spec.org/cpu2006/ CPU2006] benchmarks are written in Fortran.\n\nOn the other hand, more modern code generally uses large program libraries such as PETSc or Trilinos for linear algebra capabilities, METIS for graph partitioning, deal.II or FEniCS for mesh and finite element support, and other generic libraries. Since the late 1990s, almost all of the most widely used support libraries have been written in C and, more often, C++. Consequently, a growing fraction of scientific code is also written in these languages.  For this reason, facilities for inter-operation with C were added to Fortran 2003, and enhanced by ISO/IEC technical specification 29113, which will be incorporated into Fortran 2018. This shift is also evident in the selection of applications between the SPEC CPU 2000 and SPEC CPU 2006 floating point benchmarks.\n\nSoftware for NASA probes Voyager 1 and Voyager 2 was originally written in FORTRAN 5, and later ported to FORTRAN 77.  some of the software is still in Fortran and some has been ported to C.\n\nLanguage features\n\nThe precise characteristics and syntax of Fortran 95 are discussed in Fortran 95 language features.\n\nPortability\n\nPortability was a problem in the early days because there was no agreed standard not even IBM's reference manual and computer companies vied to differentiate their offerings from others by providing incompatible features.  Standards have improved portability.  The 1966 standard provided a reference syntax and semantics, but vendors continued to provide incompatible extensions.  Although careful programmers were coming to realize that use of incompatible extensions caused expensive portability problems, and were therefore using programs such as The PFORT Verifier, it was not until after the 1977 standard, when the National Bureau of Standards (now NIST) published FIPS PUB 69, that processors purchased by the U.S. Government were required to diagnose extensions of the standard.  Rather than offer two processors, essentially every compiler eventually had at least an option to diagnose extensions.\n\nIncompatible extensions were not the only portability problem.  For numerical calculations, it is important to take account of the characteristics of the arithmetic.  This was addressed by Fox et al. in the context of the 1966 standard by the PORT library.  The ideas therein became widely used, and were eventually incorporated into the 1990 standard by way of intrinsic inquiry functions.  The widespread (now almost universal) adoption of the IEEE 754 standard for binary floating-point arithmetic has essentially removed this problem.\n\nAccess to the computing environment (e.g., the program's command line, environment variables, textual explanation of error conditions) remained a problem until it was addressed by the 2003 standard.\n\nLarge collections of library software that could be described as being loosely related to engineering and scientific calculations, such as graphics libraries, have been written in C, and therefore access to them presented a portability problem.  This has been addressed by incorporation of C interoperability into the 2003 standard.\n\nIt is now possible (and relatively easy) to write an entirely portable program in Fortran, even without recourse to a preprocessor.\n\nVariants\n\nFortran 5\n\nFortran 5 was marketed by Data General Corp in the late 1970s and early 1980s, for the Nova, Eclipse, and MV line of computers.  It had an optimizing compiler that was quite good for minicomputers of its time.  The language most closely resembles FORTRAN 66.  The name is a pun on the earlier FORTRAN IV.\n\nFORTRAN V\n\nFORTRAN V was distributed by Control Data Corporation in 1968 for the CDC 6600 series. The language was based upon FORTRAN IV.\n\nUnivac also offered a compiler for the 1100 series known as FORTRAN V.  A spinoff of Univac Fortran V was Athena FORTRAN.\n\nFortran 6\n\nFortran 6 or Visual Fortran 2001 was licensed to Compaq by Microsoft. They have licensed Compaq Visual Fortran and have provided the Visual Studio 5 environment interface for Compaq v6 up to v6.1.\n\nSpecific variants\n\nVendors of high-performance scientific computers (e.g., Burroughs, Control Data Corporation (CDC), Cray, Honeywell, IBM, Texas Instruments, and UNIVAC) added extensions to Fortran to take advantage of special hardware features such as instruction cache, CPU pipelines, and vector arrays.  For example, one of IBM's FORTRAN compilers (H Extended IUP) had a level of optimization which reordered the machine code instructions to keep multiple internal arithmetic units busy simultaneously.  Another example is CFD, a special variant of FORTRAN designed specifically for the ILLIAC IV supercomputer, running at NASA's Ames Research Center.\nIBM Research Labs also developed an extended FORTRAN-based language called VECTRAN for processing vectors and matrices.\n\nObject-Oriented Fortran was an object-oriented extension of Fortran, in which data items can be grouped into objects, which can be instantiated and executed in parallel.  It was available for Sun, Iris, iPSC, and nCUBE, but is no longer supported.\n\nSuch machine-specific extensions have either disappeared over time or have had elements incorporated into the main standards. The major remaining extension is OpenMP, which is a cross-platform extension for shared memory programming.  One new extension, Coarray Fortran, is intended to support parallel programming.\n\nFOR TRANSIT for the IBM 650\n\nFOR TRANSIT was the name of a reduced version of the IBM 704 FORTRAN language,\nwhich was implemented for the IBM 650, using a translator program developed\nat Carnegie in the late 1950s.\"Internal Translator (IT) A Compiler for the IBM 650\",\nby A. J. Perlis, J. W. Smith, and H. R. Van Zoeren, Computation Center,\nCarnegie Institute of Technology\n\nThe following comment appears in the IBM Reference Manual (FOR TRANSIT Automatic Coding System C28-4038, Copyright 1957, 1959 by IBM):\nThe FORTRAN system was designed for a more complex machine than the 650, and consequently some of the 32 statements found in the FORTRAN Programmer's Reference Manual are not acceptable to the FOR TRANSIT system.  In addition, certain restrictions to the FORTRAN language have been added.  However, none of these restrictions make a source program written for FOR TRANSIT incompatible with the FORTRAN system for the 704.\n\nThe permissible statements were:\n\n* Arithmetic assignment statements, e.g., \n* \n* GO TO (n1, n2, ..., nm), i\n* IF (a) n1, n2, n3\n* \n* \n* DO n i = m1, m2\n* \n* \n* \n* \n* \n* \n\nUp to ten subroutines could be used in one program.\n\nFOR TRANSIT statements were limited to columns 7 through 56, only.\nPunched cards were used for input and output on the IBM 650.  Three passes were required to translate source code to the \"IT\" language, then to compile the IT statements into SOAP assembly language, and finally to produce the object program, which could then be loaded into the machine to run the program (using punched cards for data input, and outputting results onto punched cards).\n\nTwo versions existed for the 650s with a 2000 word memory drum:  FOR TRANSIT I (S) and FOR TRANSIT II, the latter for machines equipped with indexing registers and automatic floating point decimal (bi-quinary) arithmetic.  Appendix A of the manual included wiring diagrams for the IBM 533 card reader/punch control panel.\n\nFortran-based languages\n\nPrior to FORTRAN 77, a number of preprocessors were commonly used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler.  These preprocessors would typically support structured programming, variable names longer than six characters, additional data types, conditional compilation, and even macro capabilities.  Popular preprocessors included FLECS, iftran, MORTRAN, SFtran, S-Fortran, Ratfor, and Ratfiv.  Ratfor and Ratfiv, for example, implemented a C-like language, outputting preprocessed code in standard FORTRAN 66.  Despite advances in the Fortran language, preprocessors continue to be used for conditional compilation and macro substitution.\n\nOne of the earliest versions of FORTRAN, introduced in the '60s, was popularly used in colleges and universities.  Developed, supported, and distributed by the University of Waterloo, WATFOR was based largely on FORTRAN IV.  A student using WATFOR could submit their batch FORTRAN job and, if there were no syntax errors, the program would move straight to execution.  This simplification allowed students to concentrate on their program's syntax and semantics, or execution logic flow, rather than dealing with submission Job Control Language (JCL), the compile/link-edit/execution successive process(es), or other complexities of the mainframe/minicomputer environment.  A down side to this simplified environment was that WATFOR was not a good choice for programmers needing the expanded abilities of their host processor(s), e.g., WATFOR typically had very limited access to I/O devices. WATFOR was succeeded by WATFIV and its later versions.\n\n  (line programming)\n\nLRLTRAN was developed at the Lawrence Radiation Laboratory to provide support for vector arithmetic and dynamic storage, among other extensions to support systems programming.  The distribution included the LTSS operating system.\n\nThe Fortran-95 Standard includes an optional Part 3 which defines an optional conditional compilation capability.  This capability is often referred to as \"CoCo\".\n\nMany Fortran compilers have integrated subsets of the C preprocessor into their systems.\n\nSIMSCRIPT is an application specific Fortran preprocessor for modeling and simulating large discrete systems.\n\nThe F programming language was designed to be a clean subset of Fortran 95 that attempted to remove the redundant, unstructured, and deprecated features of Fortran, such as the EQUIVALENCE statement.  F retains the array features added in Fortran 90, and removes control statements that were made obsolete by structured programming constructs added to both FORTRAN 77 and Fortran 90.  F is described by its creators as \"a compiled, structured, array programming language especially well suited to education and scientific computing\".\n\nLahey and Fujitsu teamed up to create Fortran for the Microsoft .NET Framework. Silverfrost FTN95 is also capable of creating .NET code.\n\nCode examples\n\nThe following program illustrates dynamic memory allocation and array-based operations, two features introduced with Fortran 90.  Particularly noteworthy is the absence of DO loops and IF/THEN statements in manipulating the array; mathematical operations are applied to the array as a whole.  Also apparent is the use of descriptive variable names and general code formatting that conform with contemporary programming style.  This example computes an average over data entered interactively.\n\nprogram average\n\n  ! Read in some numbers and take the average\n  ! As written, if there are no data points, an average of zero is returned\n  ! While this may not be desired behavior, it keeps this example simple\n\n  implicit none\n\n  real, dimension(:), allocatable :: points\n  integer                         :: number_of_points\n  real                            :: average_points0., positive_average\n0., negative_average=0.\n\n  write (*,*) \"Input number of points to average:\"\n  read  (*,*) number_of_points\n\n  allocate (points(number_of_points))\n\n  write (*,*) \"Enter the points to average:\"\n  read  (*,*) points\n\n  ! Take the average by summing points and dividing by number_of_points\n  if (number_of_points > 0) average_points = sum(points) / number_of_points\n\n  ! Now form average over positive and negative points only\n  if (count(points > 0.) > 0) then\n     positive_average = sum(points, points > 0.) / count(points > 0.)\n  end if\n\n  if (count(points  0) then\n     negative_average = sum(points, points \n\nHumor\n\nDuring the same FORTRAN standards committee meeting at which the name \"FORTRAN 77\" was chosen, a satirical technical proposal was incorporated into the official distribution bearing the title \"Letter O Considered Harmful\".  This proposal purported to address the confusion that sometimes arises between the letter \"O\" and the numeral zero, by eliminating the letter from allowable variable names.  However, the method proposed was to eliminate the letter from the character set entirely (thereby retaining 48 as the number of lexical characters, which the colon had increased to 49).  This was considered beneficial in that it would promote structured programming, by making it impossible to use the notorious GO TO statement as before. (Troublesome FORMAT statements would also be eliminated.)  It was noted that this \"might invalidate some existing programs\" but that most of these \"probably were non-conforming, anyway\".X3J3 post-meeting distribution for meeting held at Brookhaven National Laboratory in November 1976.\"The obliteration of O\", Computer Weekly, 3 March 1977.\n\nDuring the standards committee battle over whether the \"minimum trip count\" for the FORTRAN 77 DO statement should be zero (allowing no execution of the block) or one (the \"plunge-ahead\" DO), another facetious alternative was proposed (by Loren Meissner) to have the minimum be two since there is no need for a loop if it is only executed once.\n\nWhen assumed-length arrays were being added, there was a dispute as to the appropriate character to separate upper and lower bounds.\nIn a comment examining these arguments, Dr. Walt Brainerd penned an article entitled \"Astronomy vs. Gastroenterology\"\nbecause some proponents had suggested using the star or asterisk (\"*\"), while others favored the colon (\":\").\n\nIn Fortran 77, variable names beginning with the letters I–N had a default type of integer, while variables starting with any other letters defaulted to real, although programmers could override the defaults with an explicit declaration. This led to the joke: \"In Fortran, GOD is REAL (unless declared INTEGER).\". Fortran. http://en.wikipedia.org/?curid=11168."
  }
}
