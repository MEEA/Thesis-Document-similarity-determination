{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=15189",
  "eid" : "1a863720-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778553746,
  "textBody" : "IEEE 754-1985 was an industry standard for representing floating-point numbers in computers, officially adopted in 1985 and superseded in 2008 by IEEE 754-2008. During its 23 years, it was the most widely used format for floating-point computation. It was implemented in software, in the form of floating-point libraries, and in hardware, in the instructions of many CPUs and FPUs. The first integrated circuit to implement the draft of what was to become IEEE 754-1985 was the Intel 8087.\n\nIEEE 754-1985 represents numbers in binary, providing definitions for four levels of precision, of which the two most commonly used are:\n\nThe standard also defines representations for positive and negative infinity, a \"negative zero\", five exceptions to handle invalid results like division by zero, special values called NaNs for representing those exceptions, denormal numbers to represent numbers smaller than shown above, and four rounding modes.\n\nRepresentation of numbers \n\nFloating-point numbers in IEEE 754 format consist of three fields: a sign bit, a biased exponent, and a fraction. The following example illustrates the meaning of each.\n\nThe decimal number 0.1562510 represented in binary is 0.001012 (that is, 1/8 + 1/32). (Subscripts indicate the number base.) Analogous to scientific notation, where numbers are written to have a single non-zero digit to the left of the decimal point, we rewrite this number so it has a single 1 bit to the left of the \"binary point\". We simply multiply by the appropriate power of 2 to compensate for shifting the bits left by three positions:\n\n0.00101_2 = 1.01_2 \\times 2^{-3}\n\nNow we can read off the fraction and the exponent: the fraction is .012 and the exponent is −3.\n\nAs illustrated in the pictures, the three fields in the IEEE 754 representation of this number are:\n\nsign = 0, because the number is positive. (1 indicates negative.)\nbiased exponent = −3 + the \"bias\". In single precision, the bias is 127, so in this example the biased exponent is 124; in double precision, the bias is 1023, so the biased exponent in this example is 1020.\nfraction = .01000…2.\n\nIEEE 754 adds a bias to the exponent so that numbers can in many cases be compared conveniently by the same hardware that compares signed 2's-complement integers. Using a biased exponent, the lesser of two positive floating-point numbers will come out \"less than\" the greater following the same ordering as for sign and magnitude integers. If two floating-point numbers have different signs, the sign-and-magnitude comparison also works with biased exponents. However, if both biased-exponent floating-point numbers are negative, then the ordering must be reversed. If the exponent were represented as, say, a 2's-complement number, comparison to see which of two numbers is greater would not be as convenient.\n\nThe leading 1 bit is omitted since all numbers except zero start with a leading 1; the leading 1 is implicit and doesn't actually need to be stored which gives an extra bit of precision for \"free.\"\n\nZero \n\nThe number zero is represented specially:\n\nsign = 0 for positive zero, 1 for negative zero.\nbiased exponent = 0.\nfraction = 0.\n\nDenormalized numbers \n\nThe number representations described above are called normalized, meaning that the implicit leading binary digit is a 1. To reduce the loss of precision when an underflow occurs, IEEE 754 includes the ability to represent fractions smaller than are possible in the normalized representation, by making the implicit leading digit a 0. Such numbers are called denormal. They don't include as many significant digits as a normalized number, but they enable a gradual loss of precision when the result of an arithmetic operation is not exactly zero but is too close to zero to be represented by a normalized number.\n\nA denormal number is represented with a biased exponent of all 0 bits, which represents an exponent of −126 in single precision (not −127), or −1022 in double precision (not −1023). In contrast, the smallest biased exponent representing a normal number is 1 (see examples below).\n\nRepresentation of non-numbers \n\nThe biased-exponent field is filled with all 1 bits to indicate either infinity or an invalid result of a computation.\n\nPositive and negative infinity \n\nPositive and negative infinity are represented thus:\n\nsign = 0 for positive infinity, 1 for negative infinity.\nbiased exponent = all 1 bits.\nfraction = all 0 bits.\n\nNaN \n\nSome operations of floating-point arithmetic are invalid, such as taking the square root of a negative number. The act of reaching an invalid result is called a floating-point exception. An exceptional result is represented by a special code called a NaN, for \"Not a Number\". All NaNs in IEEE 754-1985 have this format:\n\nsign = either 0 or 1.\nbiased exponent = all 1 bits.\nfraction = anything except all 0 bits (since all 0 bits represents infinity).\n\nRange and precision \n\nPrecision is defined as the minimum difference between two successive mantissa representations; thus it is a function only in the mantissa; while the gap is defined as the difference between two successive numbers.\n\nSingle precision \n\nSingle-precision numbers occupy 32 bits. In single precision:\n* The positive and negative numbers closest to zero (represented by the denormalized value with all 0s in the exponent field and the binary value 1 in the fraction field) are\n*: ±2−149 ≈ ±1.40130\n* The positive and negative normalized numbers closest to zero (represented with the binary value 1 in the exponent field and 0 in the fraction field) are\n*: ±2−126 ≈ ±1.17549\n* The finite positive and finite negative numbers furthest from zero (represented by the value with 254 in the exponent field and all 1s in the fraction field) are\n*: ±(1−2−24) × 2128 ≈ ±3.40282\n\nSome example range and gap values for given exponents in single precision:\n\nAs an example, 16,777,217 can not be encoded as a 32-bit float as it will be rounded to 16,777,216. This shows why floating point arithmetic is unsuitable for accounting software.  However, all integers within the representable range that are a power of 2 can be stored in a 32-bit float without rounding.\n\nDouble precision \n\nDouble-precision numbers occupy 64 bits. In double precision:\n* The positive and negative numbers closest to zero (represented by the denormalized value with all 0s in the Exp field and the binary value 1 in the Fraction field) are\n*: ±2−1074 ≈ ±4.94066\n* The positive and negative normalized numbers closest to zero (represented with the binary value 1 in the Exp field and 0 in the fraction field) are\n*: ±2−1022 ≈ ±2.22507\n* The finite positive and finite negative numbers furthest from zero (represented by the value with 2046 in the Exp field and all 1s in the fraction field) are\n*: ±(1−2−53) × 21024 ≈ ±1.79769\n\nSome example range and gap values for given exponents in double precision:\n\nExtended formats \n\nThe standard also recommends extended format(s) to be used to perform internal computations at a higher precision than that required for the final result, to minimise round-off errors: the standard only specifies minimum precision and exponent requirements for such formats. The x87 80-bit extended format is the most commonly implemented extended format that meets these requirements.\n\nExamples \n\nHere are some examples of single-precision IEEE 754 representations:\n\nComparing floating-point numbers\n\nEvery possible bit combination is either a NaN or a number with a unique value in the affinely extended real number system with its associated order, except for the two bit combinations negative zero and positive zero, which sometimes require special attention (see below).  The binary representation has the special property that, excluding NaNs, any two numbers can be compared as sign and magnitude integers (endianness issues apply).  When comparing as 2's-complement integers:  If the sign bits differ, the negative number precedes the positive number, so 2's complement gives the correct result (except that negative zero and positive zero should be considered equal).  If both values are positive, the 2's complement comparison again gives the correct result.  Otherwise (two negative numbers), the correct FP ordering is the opposite of the 2's complement ordering.\n\nRounding errors inherent in floating point calculations often make comparison of results for exact equality not useful.  Choosing an acceptable range is a complex topic.\n\nAlthough negative zero and positive zero are generally considered equal for comparison purposes, some programming language relational operators and similar constructs might or do treat them as distinct. According to the Java Language Specification, comparison and equality operators treat them as equal, but Math.min() and Math.max() distinguish them (officially starting with Java version 1.1 but actually with 1.1.1), as do the comparison methods equals(), compareTo() and even compare() of classes Float and Double.\n\nRounding floating-point numbers\n\nThe IEEE standard has four different rounding modes; the first is the default; the others are called directed roundings.\n\n* Round to Nearest – rounds to the nearest value; if the number falls midway it is rounded to the nearest value with an even (zero) least significant bit, which occurs 50% of the time (in IEEE 754-2008 this mode is called roundTiesToEven to distinguish it from another round-to-nearest mode)\n* Round toward 0 – directed rounding towards zero\n* Round toward +∞ – directed rounding towards positive infinity\n* Round toward −∞ – directed rounding towards negative infinity.\n\nExtending the real numbers\n\nThe IEEE standard employs (and extends) the affinely extended real number system, with separate positive and negative infinities. During drafting, there was a proposal for the standard to incorporate the projectively extended real number system, with a single unsigned infinity, by providing programmers with a mode selection option. In the interest of reducing the complexity of the final standard, the projective mode was dropped, however. The Intel 8087 and Intel 80287 floating point co-processors both support this projective mode.\n\nFunctions and predicates\n\nStandard operations\n\nThe following functions must be provided:\n*Add, subtract, multiply, divide\n*Square root\n*Floating point remainder. This is not like a normal modulo operation, it can be negative for two positive numbers. It returns the exact value of .\n*Round to nearest integer. For undirected rounding when halfway between two integers the even integer is chosen.\n*Comparison operations. Besides the more obvious results, IEEE 754 defines that −∞  −∞, +∞ \n +∞ and x ≠ NaN for any x (including NaN).\n\nRecommended functions and predicates\n\n* copysign(x,y) returns x with the sign of y, so abs(x) equals copysign(x,1.0). This is one of the few operations which operates on a NaN in a way resembling arithmetic. The function copysign is new in the C99 standard.\n* −x returns x with the sign reversed. This is different from 0−x in some cases, notably when x is 0. So −(0) is −0, but the sign of 0−0 depends on the rounding mode.\n* scalb(y, N)\n* logb(x)\n* finite(x) a predicate for \"x is a finite value\", equivalent to −Inf isnan(x) a predicate for \"x is a NaN\", equivalent to \"x ≠ x\"\n* x <> y which turns out to have different exception behavior than NOT(x = y).\n* unordered(x, y) is true when \"x is unordered with y\", i.e., either x or y is a NaN.\n* class(x)\n* nextafter(x,y) returns the next representable value from x in the direction towards y\n\nHistory\n\nIn 1976 Intel began planning to produce a floating point coprocessor. John Palmer, the manager of the effort, persuaded them that they should try to develop a standard for all their floating point operations. William Kahan was hired as a consultant; he had helped improve the accuracy of Hewlett-Packard's calculators.  Kahan initially recommended that the floating point base be decimalW. Kahan 2003, pers. comm. to Mike Cowlishaw and others after an IEEE 754 meeting but the hardware design of the coprocessor was too far along to make that change.\n\nThe work within Intel worried other vendors, who set up a standardization effort to ensure a 'level playing field'. Kahan attended the second IEEE 754 standards working group meeting, held in November 1977. Here, he received permission from Intel to put forward a draft proposal based on the standard arithmetic part of their design for a coprocessor. The arguments over gradual underflow lasted until 1981 when an expert hired by DEC to assess it sided against the dissenters.\n\nEven before it was approved, the draft standard had been implemented by a number of manufacturers. The Intel 8087, which was announced in 1980, was the first chip to implement the draft standard.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "IEEE 754-1985" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=15189" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "IEEE 754-1985 was an industry standard for representing floating-point numbers in computers, officially adopted in 1985 and superseded in 2008 by IEEE 754-2008. During its 23 years, it was the most widely used format for floating-point computation. It was implemented in software, in the form of floating-point libraries, and in hardware, in the instructions of many CPUs and FPUs. The first integrated circuit to implement the draft of what was to become IEEE 754-1985 was the Intel 8087.\n\nIEEE 754-1985 represents numbers in binary, providing definitions for four levels of precision, of which the two most commonly used are:\n\nThe standard also defines representations for positive and negative infinity, a \"negative zero\", five exceptions to handle invalid results like division by zero, special values called NaNs for representing those exceptions, denormal numbers to represent numbers smaller than shown above, and four rounding modes.\n\nRepresentation of numbers \n\nFloating-point numbers in IEEE 754 format consist of three fields: a sign bit, a biased exponent, and a fraction. The following example illustrates the meaning of each.\n\nThe decimal number 0.1562510 represented in binary is 0.001012 (that is, 1/8 + 1/32). (Subscripts indicate the number base.) Analogous to scientific notation, where numbers are written to have a single non-zero digit to the left of the decimal point, we rewrite this number so it has a single 1 bit to the left of the \"binary point\". We simply multiply by the appropriate power of 2 to compensate for shifting the bits left by three positions:\n\n0.00101_2 = 1.01_2 \\times 2^{-3}\n\nNow we can read off the fraction and the exponent: the fraction is .012 and the exponent is −3.\n\nAs illustrated in the pictures, the three fields in the IEEE 754 representation of this number are:\n\nsign = 0, because the number is positive. (1 indicates negative.)\nbiased exponent = −3 + the \"bias\". In single precision, the bias is 127, so in this example the biased exponent is 124; in double precision, the bias is 1023, so the biased exponent in this example is 1020.\nfraction = .01000…2.\n\nIEEE 754 adds a bias to the exponent so that numbers can in many cases be compared conveniently by the same hardware that compares signed 2's-complement integers. Using a biased exponent, the lesser of two positive floating-point numbers will come out \"less than\" the greater following the same ordering as for sign and magnitude integers. If two floating-point numbers have different signs, the sign-and-magnitude comparison also works with biased exponents. However, if both biased-exponent floating-point numbers are negative, then the ordering must be reversed. If the exponent were represented as, say, a 2's-complement number, comparison to see which of two numbers is greater would not be as convenient.\n\nThe leading 1 bit is omitted since all numbers except zero start with a leading 1; the leading 1 is implicit and doesn't actually need to be stored which gives an extra bit of precision for \"free.\"\n\nZero \n\nThe number zero is represented specially:\n\nsign = 0 for positive zero, 1 for negative zero.\nbiased exponent = 0.\nfraction = 0.\n\nDenormalized numbers \n\nThe number representations described above are called normalized, meaning that the implicit leading binary digit is a 1. To reduce the loss of precision when an underflow occurs, IEEE 754 includes the ability to represent fractions smaller than are possible in the normalized representation, by making the implicit leading digit a 0. Such numbers are called denormal. They don't include as many significant digits as a normalized number, but they enable a gradual loss of precision when the result of an arithmetic operation is not exactly zero but is too close to zero to be represented by a normalized number.\n\nA denormal number is represented with a biased exponent of all 0 bits, which represents an exponent of −126 in single precision (not −127), or −1022 in double precision (not −1023). In contrast, the smallest biased exponent representing a normal number is 1 (see examples below).\n\nRepresentation of non-numbers \n\nThe biased-exponent field is filled with all 1 bits to indicate either infinity or an invalid result of a computation.\n\nPositive and negative infinity \n\nPositive and negative infinity are represented thus:\n\nsign = 0 for positive infinity, 1 for negative infinity.\nbiased exponent = all 1 bits.\nfraction = all 0 bits.\n\nNaN \n\nSome operations of floating-point arithmetic are invalid, such as taking the square root of a negative number. The act of reaching an invalid result is called a floating-point exception. An exceptional result is represented by a special code called a NaN, for \"Not a Number\". All NaNs in IEEE 754-1985 have this format:\n\nsign = either 0 or 1.\nbiased exponent = all 1 bits.\nfraction = anything except all 0 bits (since all 0 bits represents infinity).\n\nRange and precision \n\nPrecision is defined as the minimum difference between two successive mantissa representations; thus it is a function only in the mantissa; while the gap is defined as the difference between two successive numbers.\n\nSingle precision \n\nSingle-precision numbers occupy 32 bits. In single precision:\n* The positive and negative numbers closest to zero (represented by the denormalized value with all 0s in the exponent field and the binary value 1 in the fraction field) are\n*: ±2−149 ≈ ±1.40130\n* The positive and negative normalized numbers closest to zero (represented with the binary value 1 in the exponent field and 0 in the fraction field) are\n*: ±2−126 ≈ ±1.17549\n* The finite positive and finite negative numbers furthest from zero (represented by the value with 254 in the exponent field and all 1s in the fraction field) are\n*: ±(1−2−24) × 2128 ≈ ±3.40282\n\nSome example range and gap values for given exponents in single precision:\n\nAs an example, 16,777,217 can not be encoded as a 32-bit float as it will be rounded to 16,777,216. This shows why floating point arithmetic is unsuitable for accounting software.  However, all integers within the representable range that are a power of 2 can be stored in a 32-bit float without rounding.\n\nDouble precision \n\nDouble-precision numbers occupy 64 bits. In double precision:\n* The positive and negative numbers closest to zero (represented by the denormalized value with all 0s in the Exp field and the binary value 1 in the Fraction field) are\n*: ±2−1074 ≈ ±4.94066\n* The positive and negative normalized numbers closest to zero (represented with the binary value 1 in the Exp field and 0 in the fraction field) are\n*: ±2−1022 ≈ ±2.22507\n* The finite positive and finite negative numbers furthest from zero (represented by the value with 2046 in the Exp field and all 1s in the fraction field) are\n*: ±(1−2−53) × 21024 ≈ ±1.79769\n\nSome example range and gap values for given exponents in double precision:\n\nExtended formats \n\nThe standard also recommends extended format(s) to be used to perform internal computations at a higher precision than that required for the final result, to minimise round-off errors: the standard only specifies minimum precision and exponent requirements for such formats. The x87 80-bit extended format is the most commonly implemented extended format that meets these requirements.\n\nExamples \n\nHere are some examples of single-precision IEEE 754 representations:\n\nComparing floating-point numbers\n\nEvery possible bit combination is either a NaN or a number with a unique value in the affinely extended real number system with its associated order, except for the two bit combinations negative zero and positive zero, which sometimes require special attention (see below).  The binary representation has the special property that, excluding NaNs, any two numbers can be compared as sign and magnitude integers (endianness issues apply).  When comparing as 2's-complement integers:  If the sign bits differ, the negative number precedes the positive number, so 2's complement gives the correct result (except that negative zero and positive zero should be considered equal).  If both values are positive, the 2's complement comparison again gives the correct result.  Otherwise (two negative numbers), the correct FP ordering is the opposite of the 2's complement ordering.\n\nRounding errors inherent in floating point calculations often make comparison of results for exact equality not useful.  Choosing an acceptable range is a complex topic.\n\nAlthough negative zero and positive zero are generally considered equal for comparison purposes, some programming language relational operators and similar constructs might or do treat them as distinct. According to the Java Language Specification, comparison and equality operators treat them as equal, but Math.min() and Math.max() distinguish them (officially starting with Java version 1.1 but actually with 1.1.1), as do the comparison methods equals(), compareTo() and even compare() of classes Float and Double.\n\nRounding floating-point numbers\n\nThe IEEE standard has four different rounding modes; the first is the default; the others are called directed roundings.\n\n* Round to Nearest – rounds to the nearest value; if the number falls midway it is rounded to the nearest value with an even (zero) least significant bit, which occurs 50% of the time (in IEEE 754-2008 this mode is called roundTiesToEven to distinguish it from another round-to-nearest mode)\n* Round toward 0 – directed rounding towards zero\n* Round toward +∞ – directed rounding towards positive infinity\n* Round toward −∞ – directed rounding towards negative infinity.\n\nExtending the real numbers\n\nThe IEEE standard employs (and extends) the affinely extended real number system, with separate positive and negative infinities. During drafting, there was a proposal for the standard to incorporate the projectively extended real number system, with a single unsigned infinity, by providing programmers with a mode selection option. In the interest of reducing the complexity of the final standard, the projective mode was dropped, however. The Intel 8087 and Intel 80287 floating point co-processors both support this projective mode.\n\nFunctions and predicates\n\nStandard operations\n\nThe following functions must be provided:\n*Add, subtract, multiply, divide\n*Square root\n*Floating point remainder. This is not like a normal modulo operation, it can be negative for two positive numbers. It returns the exact value of .\n*Round to nearest integer. For undirected rounding when halfway between two integers the even integer is chosen.\n*Comparison operations. Besides the more obvious results, IEEE 754 defines that −∞  −∞, +∞ \n +∞ and x ≠ NaN for any x (including NaN).\n\nRecommended functions and predicates\n\n* copysign(x,y) returns x with the sign of y, so abs(x) equals copysign(x,1.0). This is one of the few operations which operates on a NaN in a way resembling arithmetic. The function copysign is new in the C99 standard.\n* −x returns x with the sign reversed. This is different from 0−x in some cases, notably when x is 0. So −(0) is −0, but the sign of 0−0 depends on the rounding mode.\n* scalb(y, N)\n* logb(x)\n* finite(x) a predicate for \"x is a finite value\", equivalent to −Inf isnan(x) a predicate for \"x is a NaN\", equivalent to \"x ≠ x\"\n* x <> y which turns out to have different exception behavior than NOT(x = y).\n* unordered(x, y) is true when \"x is unordered with y\", i.e., either x or y is a NaN.\n* class(x)\n* nextafter(x,y) returns the next representable value from x in the direction towards y\n\nHistory\n\nIn 1976 Intel began planning to produce a floating point coprocessor. John Palmer, the manager of the effort, persuaded them that they should try to develop a standard for all their floating point operations. William Kahan was hired as a consultant; he had helped improve the accuracy of Hewlett-Packard's calculators.  Kahan initially recommended that the floating point base be decimalW. Kahan 2003, pers. comm. to Mike Cowlishaw and others after an IEEE 754 meeting but the hardware design of the coprocessor was too far along to make that change.\n\nThe work within Intel worried other vendors, who set up a standardization effort to ensure a 'level playing field'. Kahan attended the second IEEE 754 standards working group meeting, held in November 1977. Here, he received permission from Intel to put forward a draft proposal based on the standard arithmetic part of their design for a coprocessor. The arguments over gradual underflow lasted until 1981 when an expert hired by DEC to assess it sided against the dissenters.\n\nEven before it was approved, the draft standard had been implemented by a number of manufacturers. The Intel 8087, which was announced in 1980, was the first chip to implement the draft standard. IEEE 754-1985. http://en.wikipedia.org/?curid=15189."
  }
}
