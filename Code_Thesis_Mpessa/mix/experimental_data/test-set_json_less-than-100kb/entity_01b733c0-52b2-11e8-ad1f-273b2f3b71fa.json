{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=12323",
  "eid" : "01b733c0-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778512124,
  "textBody" : "The GNU Compiler Collection (GCC) is a compiler system produced by the GNU Project supporting various programming languages. GCC is a key component of the GNU toolchain and the standard compiler for most Unix-like operating systems. The Free Software Foundation (FSF) distributes GCC under the GNU General Public License (GNU GPL). GCC has played an important role in the growth of free software, as both a tool and an example.\n\nOriginally named the GNU C Compiler, when it only handled the C programming language, GCC 1.0 was released in 1987. It was extended to compile C++ in December of that year. Front ends were later developed for Objective-C, Objective-C++, Fortran, Java, Ada, and Go among others.\n\nVersion 4.5 of the OpenMP specification is now supported in the C and C++ compilers and a \"much improved\" implementation of the OpenACC 2.0a specification is also supported.  By default, the current version supports gnu++14, a superset of C++14 and gnu11, a superset of C11, with strict standard support also available. It also provides experimental support for C++17 and later.\n\nGCC has been ported to a wide variety of instruction set architectures, and is widely deployed as a tool in the development of both free and proprietary software. GCC is also available for most embedded systems, including ARM-based; AMCC, and Freescale Power Architecture-based chips. The compiler can target a wide variety of platforms.\n\nAs well as being the official compiler of the GNU operating system, GCC has been adopted as the standard compiler by many other modern Unix-like computer operating systems, including Linux and the BSD family, although FreeBSD and macOS have moved to the LLVM system.http://llvm.org/Users.html Versions are also available for Microsoft Windows and other operating systems; GCC can compile code for Android and iOS.\n\nHistory \n\nIn an effort to bootstrap the GNU operating system, Richard Stallman asked Andrew S. Tanenbaum, the author of the Amsterdam Compiler Kit (also known as the Free University Compiler Kit) if he could use that software for GNU. When Tanenbaum told him that while the Free University was free, the compiler was not, Stallman decided to write his own. Stallman's initial plan was to rewrite an existing compiler from Lawrence Livermore Laboratory from Pastel to C with some help from Len Tower and others. Stallman wrote a new C front end for the Livermore compiler, but then realized that it required megabytes of stack space, an impossibility on a 68000 Unix system with only 64 KB, and concluded he would have to write a new compiler from scratch. None of the Pastel compiler code ended up in GCC, though Stallman did use the C front end he had written.\n\nGCC was first released March 22, 1987, available by FTP from MIT. Stallman was listed as the author but cited others for their contributions, including Jack Davidson and Christopher Fraser for the idea of using RTL as an intermediate language, Paul Rubin for writing most of the preprocessor and Leonard Tower for \"parts of the parser, RTL generator, RTL definitions, and of the Vax machine description.\" Described as the \"first free software hit\" by Salus, the GNU compiler arrived just at the time when Sun Microsystems was unbundling its development tools from its operating system, selling them separately at a higher combined price than the previous bundle, which led many of Sun's users to buy or download GCC instead of the vendor's tools. By 1990, GCC supported thirteen computer architectures, was outperforming several vendor compilers, was shipped by Data General and NeXT with their workstations and was used by Lotus Development Corporation.\n\nAs GCC was licensed under the GPL, programmers wanting to work in other directions—particularly those writing interfaces for languages other than C—were free to develop their own fork of the compiler, provided they meet the GPL's terms, including its requirements to distribute source code. Multiple forks proved inefficient and unwieldy, however, and the difficulty in getting work accepted by the official GCC project was greatly frustrating for many. The FSF kept such close control on what was added to the official version of GCC 2.x that GCC was used as one example of the \"cathedral\" development model in Eric S. Raymond's essay The Cathedral and the Bazaar.\n\nIn 1997, a group of developers formed Experimental/Enhanced GNU Compiler System (EGCS) to merge several experimental forks into a single project. The basis of the merger was a GCC development snapshot taken between the 2.7 and 2.81 releases. Projects merged included g77 (Fortran), PGCC (P5 Pentium-optimized GCC), many C++ improvements, and many new architectures and operating system variants. EGCS development proved considerably more vigorous than GCC development, so much so that the FSF officially halted development on their GCC 2.x compiler, blessed EGCS as the official version of GCC and appointed the EGCS project as the GCC maintainers in April 1999. With the release of GCC 2.95 in July 1999 the two projects were once again united.\n\nGCC has since been maintained by a varied group of programmers from around the world under the direction of a steering committee. It has been ported to more kinds of processors and operating systems than any other compiler.\n\nGCC has been ported to a wide variety of instruction set architectures, and is widely deployed as a tool in the development of both free and proprietary software. GCC is also available for most embedded systems, including Symbian (called gcce), ARM-based; AMCC, and Freescale Power Architecture-based chips. The compiler can target a wide variety of platforms, including video game consoles such as the PlayStation 2, Cell SPE of PlayStation 3https://gcc.gnu.org/wiki/CompileFarm and Dreamcast.\n\nDesign \n\nGCC's external interface follows Unix conventions. Users invoke a language-specific driver program (gcc for C, g++ for C++, etc.), which interprets command arguments, calls the actual compiler, runs the assembler on the output, and then optionally runs the linker to produce a complete executable binary.\n\nEach of the language compilers is a separate program that reads source code and outputs machine code. All have a common internal structure. A per-language front end parses the source code in that language and produces an abstract syntax tree (\"tree\" for short).\n\nThese are, if necessary, converted to the middle end's input representation, called GENERIC form; the middle end then gradually transforms the program towards its final form. Compiler optimizations and static code analysis techniques (such as FORTIFY_SOURCE, a compiler directive that attempts to discover some buffer overflows) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent RTL representation. Finally, machine code is produced using architecture-specific pattern matching originally based on an algorithm of Jack Davidson and Chris Fraser.\n\nGCC was written primarily in C except for parts of the Ada front end. The distribution includes the standard libraries for Ada, C++, and Java whose code is mostly written in those languages. On some platforms, the distribution also includes a low-level runtime library, libgcc, written in a combination of machine-independent C and processor-specific machine code, designed primarily to handle arithmetic operations that the target processor cannot perform directly.\n\nIn May 2010, the GCC steering committee decided to allow use of a C++ compiler to compile GCC. The compiler was intended to be written in C plus a subset of features from C++. In particular, this was decided so that GCC's developers could use the destructors and generics features of C++.\n\nIn August 2012, the GCC steering committee announced that GCC now uses C++ as its implementation language. This means that to build GCC from sources, a C++ compiler is required that understands ISO/IEC C++03 standard.\n\nFront ends \n\nEach front end uses a parser to produce the abstract syntax tree of a given source file. Due to the syntax tree abstraction, source files of any of the different supported languages can be processed by the same back end. GCC started out using LALR parsers generated with Bison, but gradually switched to hand-written recursive-descent parsers; for C++ in 2004, and for C and Objective-C in 2006. Currently all front ends use hand-written recursive-descent parsers.\n\nUntil recently, the tree representation of the program was not fully independent of the processor being targeted.\n\nThe meaning of a tree was somewhat different for different language front ends, and front ends could provide their own tree codes. This was simplified with the introduction of GENERIC and GIMPLE, two new forms of language-independent trees that were introduced with the advent of GCC 4.0. GENERIC is more complex, based on the GCC 3.x Java front end's intermediate representation. GIMPLE is a simplified GENERIC, in which various constructs are lowered to multiple GIMPLE instructions. The C, C++ and Java front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC.\n\nIn either case, the so-called \"gimplifier\" then converts this more complex form into the simpler SSA-based GIMPLE form that is the common language for a large number of powerful language- and architecture-independent global (function scope) optimizations.\n\nGENERIC and GIMPLE \n\nGENERIC is an intermediate representation language used as a \"middle end\" while compiling source code into executable binaries. A subset, called GIMPLE, is targeted by all the front ends of GCC.\n\nThe middle stage of GCC does all of the code analysis and optimization, working independently of both the compiled language and the target architecture, starting from the GENERIC representation and expanding it to register transfer language (RTL). The GENERIC representation contains only the subset of the imperative programming constructs optimized by the middle end.\n\nIn transforming the source code to GIMPLE, complex expressions are split into a three-address code using temporary variables. This representation was inspired by the SIMPLE representation proposed in the McCAT compiler by Laurie J. Hendren for simplifying the analysis and optimization of imperative programs.\n\nOptimization \n\nOptimization can occur during any phase of compilation; however, the bulk of optimizations are performed after the syntax and semantic analysis of the front end and before the code generation of the back end; thus a common, even though somewhat contradictory, name for this part of the compiler is the \"middle end.\"\n\nThe exact set of GCC optimizations varies from release to release as it develops, but includes the standard algorithms, such as loop optimization, jump threading, common subexpression elimination, instruction scheduling, and so forth. The RTL optimizations are of less importance with the addition of global SSA-based optimizations on GIMPLE trees, as RTL optimizations have a much more limited scope, and have less high-level information.\n\nSome of these optimizations performed at this level include dead code elimination, partial redundancy elimination, global value numbering, sparse conditional constant propagation, and scalar replacement of aggregates. Array dependence based optimizations such as automatic vectorization and automatic parallelization are also performed. Profile-guided optimization is also possible.\n\nBack end \n\nThe behavior of GCC's back end is partly specified by preprocessor macros and functions specific to a target architecture, for instance to define its endianness, word size, and calling conventions. The front part of the back end uses these to help decide RTL generation, so although GCC's RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have to comply with the machine description of the target architecture.\n\nThe machine description file contains RTL patterns, along with operand constraints, and code snippets to output the final assembly. The constraints indicate that a particular RTL pattern might only apply (for example) to certain hardware registers, or (for example) allow immediate operand offsets of only a limited size (e.g. 12, 16, 24, … bit offsets, etc.). During RTL generation, the constraints for the given target architecture are checked. In order to issue a given snippet of RTL, it must match one (or more) of the RTL patterns in the machine description file, and satisfy the constraints for that pattern; otherwise, it would be impossible to convert the final RTL into machine code.\n\nTowards the end of compilation, valid RTL is reduced to a strict form in which each instruction refers to real machine registers and a pattern from the target's machine description file. Forming strict RTL is a complicated task; an important step is register allocation, where real hardware registers are chosen to replace the initially assigned pseudo-registers. This is followed by a \"reloading\" phase; any pseudo-registers that were not assigned a real hardware register are 'spilled' to the stack, and RTL to perform this spilling is generated. Likewise, offsets that are too large to fit into an actual instruction must be broken up and replaced by RTL sequences that will obey the offset constraints.\n\nIn the final phase, the machine code is built by calling a small snippet of code, associated with each pattern, to generate the real instructions from the target's instruction set, using the final registers, offsets, and addresses chosen during the reload phase. The assembly-generation snippet may be just a string, in which case a simple string substitution of the registers, offsets, and/or addresses into the string is performed. The assembly-generation snippet may also be a short block of C code, performing some additional work, but ultimately returning a string containing the valid assembly code.\n\nFeatures \n\nSome features of GCC include:\n\n* Link-time optimization optimizes across object file boundaries to directly improve the linked binary. Link-time optimization relies on an intermediate file containing the serialization of some Gimple representation included in the object file. The file is generated alongside the object file during source compilation. Each source compilation generates a separate object file and link-time helper file. When the object files are linked, the compiler is executed again and uses the helper files to optimize code across the separately compiled object files.\n* Plugins can extend the GCC compiler directly. Plugins allow a stock compiler to be tailored to specific needs by external code loaded as plugins. For example, plugins can add, replace, or even remove middle-end passes operating on Gimple representations. Several GCC plugins have already been published, notably the GCC Python plugin, which links against libpython, and allows one to invoke arbitrary Python scripts from inside the compiler. The aim is to allow GCC plugins to be written in Python. The MELT plugin provides a high-level Lisp-like language to extend GCC.\n* \"C++ transactional memory when compiling with -fgnu-tm.\"\n\nLanguages \n\nThe standard compiler releases since 4.6 include front ends for C (gcc), C++ (g++), Objective-C, Objective-C++, Fortran (gfortran), Java (gcj), Ada (GNAT), and Go (gccgo). A popular parallel language extension, OpenMP, is also supported. Version 5.0 added support for Cilk Plus, and since version 5.1, there is preliminary support for OpenACC.\n\nThe Fortran front end was g77 before version 4.0, which only supports FORTRAN 77. In newer versions, g77 is dropped in favor of the new GNU Fortran front end (retaining most of g77's language extensions) that supports Fortran 95 and large parts of Fortran 2003 and Fortran 2008 as well. A front-end for CHILL was dropped due to a lack of maintenance.\n\nThird-party front ends exist for Pascal (gpc), Modula-2, Modula-3, PL/I, D (gdc), and VHDL (ghdl).\n\nA few experimental branches exist to support additional languages, such as the GCC UPC compiler for Unified Parallel C.\n\nArchitectures \n\nGCC target processor families as of version 4.3 include:\n\n* Alpha\n* ARM\n* AVR\n* Blackfin\n* Epiphany (GCC 4.8)\n* H8/300\n* HC12\n* IA-32 (x86)\n* IA-64 (Intel Itanium)\n* MIPS\n* Motorola 68000\n* PA-RISC\n* PDP-11\n* PowerPC\n* R8C / M16C / M32C\n* SPARC\n* SPU\n* SuperH\n* System/390 / zSeries\n* VAX\n* x86-64\n\nLesser-known target processors supported in the standard release have included:\n\n* 68HC11\n* A29K\n* CR16\n* C6x\n* D30V\n* DSP16xx\n* ETRAX CRIS\n* FR-30\n* FR-V\n* Intel i960\n* IP2000\n* M32R\n* MCORE\n* MIL-STD-1750A\n* MMIX\n* MN10200\n* MN10300\n* Motorola 88000\n* NS32K\n* ROMP\n* RL78\n* Stormy16\n* V850\n* Xtensa\n\nAdditional processors have been supported by GCC versions maintained separately from the FSF version:\n\n* Cortus APS3\n* ARC\n* AVR32\n* C166 and C167\n* D10V\n* EISC\n* eSi-RISC\n* Hexagon\n* LatticeMico32\n* LatticeMico8\n* MeP\n* MicroBlaze\n* Motorola 6809\n* MSP430\n* NEC SX architecture\n* Nios II and Nios\n* OpenRISC\n* PDP-10\n* PIC24/dsPIC\n* PIC32\n* Propeller\n* RISC-V\n* Saturn (HP48XGCC)\n* System/370\n* TIGCC (m68k variant)\n* TriCore\n* Z8000\n* ZPU\n\nThe gcj Java compiler can target either a native machine language architecture or the Java virtual machine's Java bytecode. When retargeting GCC to a new platform, bootstrapping is often used.\n\nDevelopment \n\nThe current stable version of GCC is 7.3, which was released on January 25, 2018.https://www.gnu.org/software/gcc/releases.html\n\nAs of version 4.8, GCC is implemented in C++.\n\nGCC 4.6 supports many new Objective-C features, such as declared and synthesized properties, dot syntax, fast enumeration, optional protocol methods, method/protocol/class attributes, class extensions and a new GNU Objective-C runtime API. It also supports the Go programming language and includes the libquadmath library, which provides quadruple-precision mathematical functions on targets supporting the __float128 datatype. The library is used to provide the REAL(16) type in GNU Fortran on such targets.\n\nGCC uses many standard tools in its build, including Perl, Flex, Bison, and other common tools. In addition it currently requires three additional libraries to be present in order to build: GMP, MPC, and MPFR.\n\nThe trunk concentrates the major part of the development efforts, where new features are implemented and tested.\n\nLicense \n\nThe GCC runtime exception permits compilation of proprietary and free software programs with GCC and usage of free software plugins. The availability of this exception does not imply any general presumption that third-party software is unaffected by the copyleft requirements of the license of GCC.\n\nUses \n\nSeveral companies make a business out of supplying and supporting GCC ports to various platforms.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "GNU Compiler Collection" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=12323" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "The GNU Compiler Collection (GCC) is a compiler system produced by the GNU Project supporting various programming languages. GCC is a key component of the GNU toolchain and the standard compiler for most Unix-like operating systems. The Free Software Foundation (FSF) distributes GCC under the GNU General Public License (GNU GPL). GCC has played an important role in the growth of free software, as both a tool and an example.\n\nOriginally named the GNU C Compiler, when it only handled the C programming language, GCC 1.0 was released in 1987. It was extended to compile C++ in December of that year. Front ends were later developed for Objective-C, Objective-C++, Fortran, Java, Ada, and Go among others.\n\nVersion 4.5 of the OpenMP specification is now supported in the C and C++ compilers and a \"much improved\" implementation of the OpenACC 2.0a specification is also supported.  By default, the current version supports gnu++14, a superset of C++14 and gnu11, a superset of C11, with strict standard support also available. It also provides experimental support for C++17 and later.\n\nGCC has been ported to a wide variety of instruction set architectures, and is widely deployed as a tool in the development of both free and proprietary software. GCC is also available for most embedded systems, including ARM-based; AMCC, and Freescale Power Architecture-based chips. The compiler can target a wide variety of platforms.\n\nAs well as being the official compiler of the GNU operating system, GCC has been adopted as the standard compiler by many other modern Unix-like computer operating systems, including Linux and the BSD family, although FreeBSD and macOS have moved to the LLVM system.http://llvm.org/Users.html Versions are also available for Microsoft Windows and other operating systems; GCC can compile code for Android and iOS.\n\nHistory \n\nIn an effort to bootstrap the GNU operating system, Richard Stallman asked Andrew S. Tanenbaum, the author of the Amsterdam Compiler Kit (also known as the Free University Compiler Kit) if he could use that software for GNU. When Tanenbaum told him that while the Free University was free, the compiler was not, Stallman decided to write his own. Stallman's initial plan was to rewrite an existing compiler from Lawrence Livermore Laboratory from Pastel to C with some help from Len Tower and others. Stallman wrote a new C front end for the Livermore compiler, but then realized that it required megabytes of stack space, an impossibility on a 68000 Unix system with only 64 KB, and concluded he would have to write a new compiler from scratch. None of the Pastel compiler code ended up in GCC, though Stallman did use the C front end he had written.\n\nGCC was first released March 22, 1987, available by FTP from MIT. Stallman was listed as the author but cited others for their contributions, including Jack Davidson and Christopher Fraser for the idea of using RTL as an intermediate language, Paul Rubin for writing most of the preprocessor and Leonard Tower for \"parts of the parser, RTL generator, RTL definitions, and of the Vax machine description.\" Described as the \"first free software hit\" by Salus, the GNU compiler arrived just at the time when Sun Microsystems was unbundling its development tools from its operating system, selling them separately at a higher combined price than the previous bundle, which led many of Sun's users to buy or download GCC instead of the vendor's tools. By 1990, GCC supported thirteen computer architectures, was outperforming several vendor compilers, was shipped by Data General and NeXT with their workstations and was used by Lotus Development Corporation.\n\nAs GCC was licensed under the GPL, programmers wanting to work in other directions—particularly those writing interfaces for languages other than C—were free to develop their own fork of the compiler, provided they meet the GPL's terms, including its requirements to distribute source code. Multiple forks proved inefficient and unwieldy, however, and the difficulty in getting work accepted by the official GCC project was greatly frustrating for many. The FSF kept such close control on what was added to the official version of GCC 2.x that GCC was used as one example of the \"cathedral\" development model in Eric S. Raymond's essay The Cathedral and the Bazaar.\n\nIn 1997, a group of developers formed Experimental/Enhanced GNU Compiler System (EGCS) to merge several experimental forks into a single project. The basis of the merger was a GCC development snapshot taken between the 2.7 and 2.81 releases. Projects merged included g77 (Fortran), PGCC (P5 Pentium-optimized GCC), many C++ improvements, and many new architectures and operating system variants. EGCS development proved considerably more vigorous than GCC development, so much so that the FSF officially halted development on their GCC 2.x compiler, blessed EGCS as the official version of GCC and appointed the EGCS project as the GCC maintainers in April 1999. With the release of GCC 2.95 in July 1999 the two projects were once again united.\n\nGCC has since been maintained by a varied group of programmers from around the world under the direction of a steering committee. It has been ported to more kinds of processors and operating systems than any other compiler.\n\nGCC has been ported to a wide variety of instruction set architectures, and is widely deployed as a tool in the development of both free and proprietary software. GCC is also available for most embedded systems, including Symbian (called gcce), ARM-based; AMCC, and Freescale Power Architecture-based chips. The compiler can target a wide variety of platforms, including video game consoles such as the PlayStation 2, Cell SPE of PlayStation 3https://gcc.gnu.org/wiki/CompileFarm and Dreamcast.\n\nDesign \n\nGCC's external interface follows Unix conventions. Users invoke a language-specific driver program (gcc for C, g++ for C++, etc.), which interprets command arguments, calls the actual compiler, runs the assembler on the output, and then optionally runs the linker to produce a complete executable binary.\n\nEach of the language compilers is a separate program that reads source code and outputs machine code. All have a common internal structure. A per-language front end parses the source code in that language and produces an abstract syntax tree (\"tree\" for short).\n\nThese are, if necessary, converted to the middle end's input representation, called GENERIC form; the middle end then gradually transforms the program towards its final form. Compiler optimizations and static code analysis techniques (such as FORTIFY_SOURCE, a compiler directive that attempts to discover some buffer overflows) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent RTL representation. Finally, machine code is produced using architecture-specific pattern matching originally based on an algorithm of Jack Davidson and Chris Fraser.\n\nGCC was written primarily in C except for parts of the Ada front end. The distribution includes the standard libraries for Ada, C++, and Java whose code is mostly written in those languages. On some platforms, the distribution also includes a low-level runtime library, libgcc, written in a combination of machine-independent C and processor-specific machine code, designed primarily to handle arithmetic operations that the target processor cannot perform directly.\n\nIn May 2010, the GCC steering committee decided to allow use of a C++ compiler to compile GCC. The compiler was intended to be written in C plus a subset of features from C++. In particular, this was decided so that GCC's developers could use the destructors and generics features of C++.\n\nIn August 2012, the GCC steering committee announced that GCC now uses C++ as its implementation language. This means that to build GCC from sources, a C++ compiler is required that understands ISO/IEC C++03 standard.\n\nFront ends \n\nEach front end uses a parser to produce the abstract syntax tree of a given source file. Due to the syntax tree abstraction, source files of any of the different supported languages can be processed by the same back end. GCC started out using LALR parsers generated with Bison, but gradually switched to hand-written recursive-descent parsers; for C++ in 2004, and for C and Objective-C in 2006. Currently all front ends use hand-written recursive-descent parsers.\n\nUntil recently, the tree representation of the program was not fully independent of the processor being targeted.\n\nThe meaning of a tree was somewhat different for different language front ends, and front ends could provide their own tree codes. This was simplified with the introduction of GENERIC and GIMPLE, two new forms of language-independent trees that were introduced with the advent of GCC 4.0. GENERIC is more complex, based on the GCC 3.x Java front end's intermediate representation. GIMPLE is a simplified GENERIC, in which various constructs are lowered to multiple GIMPLE instructions. The C, C++ and Java front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC.\n\nIn either case, the so-called \"gimplifier\" then converts this more complex form into the simpler SSA-based GIMPLE form that is the common language for a large number of powerful language- and architecture-independent global (function scope) optimizations.\n\nGENERIC and GIMPLE \n\nGENERIC is an intermediate representation language used as a \"middle end\" while compiling source code into executable binaries. A subset, called GIMPLE, is targeted by all the front ends of GCC.\n\nThe middle stage of GCC does all of the code analysis and optimization, working independently of both the compiled language and the target architecture, starting from the GENERIC representation and expanding it to register transfer language (RTL). The GENERIC representation contains only the subset of the imperative programming constructs optimized by the middle end.\n\nIn transforming the source code to GIMPLE, complex expressions are split into a three-address code using temporary variables. This representation was inspired by the SIMPLE representation proposed in the McCAT compiler by Laurie J. Hendren for simplifying the analysis and optimization of imperative programs.\n\nOptimization \n\nOptimization can occur during any phase of compilation; however, the bulk of optimizations are performed after the syntax and semantic analysis of the front end and before the code generation of the back end; thus a common, even though somewhat contradictory, name for this part of the compiler is the \"middle end.\"\n\nThe exact set of GCC optimizations varies from release to release as it develops, but includes the standard algorithms, such as loop optimization, jump threading, common subexpression elimination, instruction scheduling, and so forth. The RTL optimizations are of less importance with the addition of global SSA-based optimizations on GIMPLE trees, as RTL optimizations have a much more limited scope, and have less high-level information.\n\nSome of these optimizations performed at this level include dead code elimination, partial redundancy elimination, global value numbering, sparse conditional constant propagation, and scalar replacement of aggregates. Array dependence based optimizations such as automatic vectorization and automatic parallelization are also performed. Profile-guided optimization is also possible.\n\nBack end \n\nThe behavior of GCC's back end is partly specified by preprocessor macros and functions specific to a target architecture, for instance to define its endianness, word size, and calling conventions. The front part of the back end uses these to help decide RTL generation, so although GCC's RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have to comply with the machine description of the target architecture.\n\nThe machine description file contains RTL patterns, along with operand constraints, and code snippets to output the final assembly. The constraints indicate that a particular RTL pattern might only apply (for example) to certain hardware registers, or (for example) allow immediate operand offsets of only a limited size (e.g. 12, 16, 24, … bit offsets, etc.). During RTL generation, the constraints for the given target architecture are checked. In order to issue a given snippet of RTL, it must match one (or more) of the RTL patterns in the machine description file, and satisfy the constraints for that pattern; otherwise, it would be impossible to convert the final RTL into machine code.\n\nTowards the end of compilation, valid RTL is reduced to a strict form in which each instruction refers to real machine registers and a pattern from the target's machine description file. Forming strict RTL is a complicated task; an important step is register allocation, where real hardware registers are chosen to replace the initially assigned pseudo-registers. This is followed by a \"reloading\" phase; any pseudo-registers that were not assigned a real hardware register are 'spilled' to the stack, and RTL to perform this spilling is generated. Likewise, offsets that are too large to fit into an actual instruction must be broken up and replaced by RTL sequences that will obey the offset constraints.\n\nIn the final phase, the machine code is built by calling a small snippet of code, associated with each pattern, to generate the real instructions from the target's instruction set, using the final registers, offsets, and addresses chosen during the reload phase. The assembly-generation snippet may be just a string, in which case a simple string substitution of the registers, offsets, and/or addresses into the string is performed. The assembly-generation snippet may also be a short block of C code, performing some additional work, but ultimately returning a string containing the valid assembly code.\n\nFeatures \n\nSome features of GCC include:\n\n* Link-time optimization optimizes across object file boundaries to directly improve the linked binary. Link-time optimization relies on an intermediate file containing the serialization of some Gimple representation included in the object file. The file is generated alongside the object file during source compilation. Each source compilation generates a separate object file and link-time helper file. When the object files are linked, the compiler is executed again and uses the helper files to optimize code across the separately compiled object files.\n* Plugins can extend the GCC compiler directly. Plugins allow a stock compiler to be tailored to specific needs by external code loaded as plugins. For example, plugins can add, replace, or even remove middle-end passes operating on Gimple representations. Several GCC plugins have already been published, notably the GCC Python plugin, which links against libpython, and allows one to invoke arbitrary Python scripts from inside the compiler. The aim is to allow GCC plugins to be written in Python. The MELT plugin provides a high-level Lisp-like language to extend GCC.\n* \"C++ transactional memory when compiling with -fgnu-tm.\"\n\nLanguages \n\nThe standard compiler releases since 4.6 include front ends for C (gcc), C++ (g++), Objective-C, Objective-C++, Fortran (gfortran), Java (gcj), Ada (GNAT), and Go (gccgo). A popular parallel language extension, OpenMP, is also supported. Version 5.0 added support for Cilk Plus, and since version 5.1, there is preliminary support for OpenACC.\n\nThe Fortran front end was g77 before version 4.0, which only supports FORTRAN 77. In newer versions, g77 is dropped in favor of the new GNU Fortran front end (retaining most of g77's language extensions) that supports Fortran 95 and large parts of Fortran 2003 and Fortran 2008 as well. A front-end for CHILL was dropped due to a lack of maintenance.\n\nThird-party front ends exist for Pascal (gpc), Modula-2, Modula-3, PL/I, D (gdc), and VHDL (ghdl).\n\nA few experimental branches exist to support additional languages, such as the GCC UPC compiler for Unified Parallel C.\n\nArchitectures \n\nGCC target processor families as of version 4.3 include:\n\n* Alpha\n* ARM\n* AVR\n* Blackfin\n* Epiphany (GCC 4.8)\n* H8/300\n* HC12\n* IA-32 (x86)\n* IA-64 (Intel Itanium)\n* MIPS\n* Motorola 68000\n* PA-RISC\n* PDP-11\n* PowerPC\n* R8C / M16C / M32C\n* SPARC\n* SPU\n* SuperH\n* System/390 / zSeries\n* VAX\n* x86-64\n\nLesser-known target processors supported in the standard release have included:\n\n* 68HC11\n* A29K\n* CR16\n* C6x\n* D30V\n* DSP16xx\n* ETRAX CRIS\n* FR-30\n* FR-V\n* Intel i960\n* IP2000\n* M32R\n* MCORE\n* MIL-STD-1750A\n* MMIX\n* MN10200\n* MN10300\n* Motorola 88000\n* NS32K\n* ROMP\n* RL78\n* Stormy16\n* V850\n* Xtensa\n\nAdditional processors have been supported by GCC versions maintained separately from the FSF version:\n\n* Cortus APS3\n* ARC\n* AVR32\n* C166 and C167\n* D10V\n* EISC\n* eSi-RISC\n* Hexagon\n* LatticeMico32\n* LatticeMico8\n* MeP\n* MicroBlaze\n* Motorola 6809\n* MSP430\n* NEC SX architecture\n* Nios II and Nios\n* OpenRISC\n* PDP-10\n* PIC24/dsPIC\n* PIC32\n* Propeller\n* RISC-V\n* Saturn (HP48XGCC)\n* System/370\n* TIGCC (m68k variant)\n* TriCore\n* Z8000\n* ZPU\n\nThe gcj Java compiler can target either a native machine language architecture or the Java virtual machine's Java bytecode. When retargeting GCC to a new platform, bootstrapping is often used.\n\nDevelopment \n\nThe current stable version of GCC is 7.3, which was released on January 25, 2018.https://www.gnu.org/software/gcc/releases.html\n\nAs of version 4.8, GCC is implemented in C++.\n\nGCC 4.6 supports many new Objective-C features, such as declared and synthesized properties, dot syntax, fast enumeration, optional protocol methods, method/protocol/class attributes, class extensions and a new GNU Objective-C runtime API. It also supports the Go programming language and includes the libquadmath library, which provides quadruple-precision mathematical functions on targets supporting the __float128 datatype. The library is used to provide the REAL(16) type in GNU Fortran on such targets.\n\nGCC uses many standard tools in its build, including Perl, Flex, Bison, and other common tools. In addition it currently requires three additional libraries to be present in order to build: GMP, MPC, and MPFR.\n\nThe trunk concentrates the major part of the development efforts, where new features are implemented and tested.\n\nLicense \n\nThe GCC runtime exception permits compilation of proprietary and free software programs with GCC and usage of free software plugins. The availability of this exception does not imply any general presumption that third-party software is unaffected by the copyleft requirements of the license of GCC.\n\nUses \n\nSeveral companies make a business out of supplying and supporting GCC ports to various platforms. GNU Compiler Collection. http://en.wikipedia.org/?curid=12323."
  }
}
