{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=18155",
  "eid" : "313b8240-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778591844,
  "textBody" : "In programming language theory, lazy evaluation, or call-by-need is an evaluation strategy which delays the evaluation of an expression until its value is needed (non-strict evaluation) and which also avoids repeated evaluations (sharing). The sharing can reduce the running time of certain functions by an exponential factor over other non-strict evaluation strategies, such as call-by-name.\n\nThe benefits of lazy evaluation include: \n* The ability to define control flow (structures) as abstractions instead of primitives.\n* The ability to define potentially infinite data structures. This allows for more straightforward implementation of some algorithms.\n* Performance increases by avoiding needless calculations, and error conditions in evaluating compound expressions.\n\nLazy evaluation is often combined with memoization, as described in Jon Bentley's Writing Efficient Programs.Bentley, Jon Louis. Writing Efficient Programs. Prentice-Hall, 1985.  After a function's value is computed for that parameter or set of parameters, the result is stored in a lookup table that is indexed by the values of those parameters; the next time the function is called, the table is consulted to determine whether the result for that combination of parameter values is already available. If so, the stored result is simply returned. If not, the function is evaluated and another entry is added to the lookup table for reuse.\n\nLazy evaluation can lead to reduction in memory footprint, since values are created when needed. However, lazy evaluation is difficult to combine with imperative features such as exception handling and input/output, because the order of operations becomes indeterminate. Lazy evaluation can introduce space leaks.Edward Z. Yang. [http://blog.ezyang.com/2011/05/space-leak-zoo/ \"Space leak zoo\"].\n\nThe opposite of lazy evaluation is eager evaluation, sometimes known as strict evaluation. Eager evaluation is the evaluation strategy employed in most programming languages.\n\nHistory \n\nLazy evaluation was introduced for lambda calculus by Christopher Wadsworth. For programming languages, it was independently introduced by Peter Henderson and James H. Morris and by Daniel P. Friedman and David S. Wise.\n\nApplications \n\nDelayed evaluation is used particularly in functional programming languages. When using delayed evaluation, an expression is not evaluated as soon as it gets bound to a variable, but when the evaluator is forced to produce the expression's value. That is, a statement such as x expression; (i.e. the assignment of the result of an expression to a variable) clearly calls for the expression to be evaluated and the result placed in x, but what actually is in x is irrelevant until there is a need for its value via a reference to x in some later expression whose evaluation could itself be deferred, though eventually the rapidly growing tree of dependencies would be pruned to produce some symbol rather than another for the outside world to see.\n\nDelayed evaluation has the advantage of being able to create calculable infinite lists without infinite loops or size matters interfering in computation. For example, one could create a function that creates an infinite list (often called a stream) of Fibonacci numbers. The calculation of the n-th Fibonacci number would be merely the extraction of that element from the infinite list, forcing the evaluation of only the first n members of the list.\n\nFor example, in the Haskell programming language, the list of all Fibonacci numbers can be written as:\n\n fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n\nIn Haskell syntax, \":\" prepends an element to a list, tail returns a list without its first element, and zipWith uses a specified function (in this case addition) to combine corresponding elements of two lists to produce a third.\n\nProvided the programmer is careful, only the values that are required to produce a particular result are evaluated. However, certain calculations may result in the program attempting to evaluate an infinite number of elements; for example, requesting the length of the list or trying to sum the elements of the list with a fold operation would result in the program either failing to terminate or running out of memory.\n\nControl structures\n\nIn almost all common \"eager\" languages, if statements evaluate in a lazy fashion.\n if a then b else c\nevaluates (a), then if and only if (a) evaluates to true does it evaluate (b), otherwise it evaluates (c). That is, either (b) or (c) will not be evaluated. Conversely, in an eager language the expected behavior is that\n define f(x, y) = 2 * x\n set k = f(d, e)\nwill still evaluate (e) when computing the value of f(d, e) even though (e) is unused in function f. However, user-defined control structures depend on exact syntax, so for example\n define g(a, b, c) = if a then b else c\n l = g(h, i, j)\n(i) and (j) would both be evaluated in an eager language.  While in a lazy language,\n l' = if h then i else j\n(i) or (j) would be evaluated, but never both.\n\nLazy evaluation allows control structures to be defined normally, and not as primitives or compile-time techniques. If (i) or (j) have side effects or introduce run time errors, the subtle differences between (l) and (l') can be complex. It is usually possible to introduce user-defined lazy control structures in eager languages as functions, though they may depart from the language's syntax for eager evaluation: Often the involved code bodies (like (i) and (j)) need to be wrapped in a function value, so that they are executed only when called.\n\nShort-circuit evaluation of Boolean control structures is sometimes called lazy.\n\nWorking with infinite data structures \n\nMany languages offer the notion of infinite data-structures. These allow definitions of data to be given in terms of infinite ranges, or unending recursion, but the actual values are only computed when needed. Take for example this trivial program in Haskell:\n\nnumberFromInfiniteList :: Int -> Int\nnumberFromInfiniteList n =  infinity !! n - 1\n    where infinity = [1..]\n\nmain = print $ numberFromInfiniteList 4\n\nIn the function numberFromInfiniteList, the value of infinity is an infinite range, but until an actual value (or more specifically, a specific value at a certain index) is needed, the list is not evaluated, and even then it is only evaluated as needed (that is, until the desired index.)\n\nList-of-successes pattern \n\nOther uses\n\nIn computer windowing systems, the painting of information to the screen is driven by expose events which drive the display code at the last possible moment. By doing this, windowing systems avoid computing unnecessary display content updates.[http://research.microsoft.com/en-us/um/people/blampson/slides/lazyandspeculative.ppt Lazy and Speculative Execution] Butler Lampson Microsoft Research OPODIS, Bordeaux, France 12 December 2006\n\nAnother example of laziness in modern computer systems is copy-on-write page allocation or demand paging, where memory is allocated only when a value stored in that memory is changed.\n\nLaziness can be useful for high performance scenarios. An example is the Unix mmap function, which provides demand driven loading of pages from disk, so that only those pages actually touched are loaded into memory, and unneeded memory is not allocated.\n\nMATLAB implements copy on edit, where arrays which are copied have their actual memory storage replicated only when their content is changed, possibly leading to an out of memory error when updating an element afterwards instead of during the copy operation.\n\nImplementation\n\nSome programming languages delay evaluation of expressions by default, and some others provide functions or special syntax to delay evaluation. In Miranda and Haskell, evaluation of function arguments is delayed by default. In many other languages, evaluation can be delayed by explicitly suspending the computation using special syntax (as with Scheme's \"delay\" and \"force\" and OCaml's \"lazy\" and \"Lazy.force\") or, more generally, by wrapping the expression in a thunk. The object representing such an explicitly delayed evaluation is called a lazy future. Perl 6 uses lazy evaluation of lists, so one can assign infinite lists to variables and use them as arguments to functions, but unlike Haskell and Miranda, Perl 6 doesn't use lazy evaluation of arithmetic operators and functions by default.\n\nLaziness and eagerness \n\nControlling eagerness in lazy languages\n\nIn lazy programming languages such as Haskell, although the default is to evaluate expressions only when they are demanded, it is possible in some cases to make code more eager—or conversely, to make it more lazy again after it has been made more eager. This can be done by explicitly coding something which forces evaluation (which may make the code more eager) or avoiding such code (which may make the code more lazy). Strict evaluation usually implies eagerness, but they are technically different concepts.\n\nHowever, there is an optimisation implemented in some compilers called strictness analysis, which, in some cases, allows the compiler to infer that a value will always be used. In such cases, this may render the programmer's choice of whether to force that particular value or not, irrelevant, because strictness analysis will force strict evaluation.\n\nIn Haskell, marking constructor fields strict means that their values will always be demanded immediately. The seq function can also be used to demand a value immediately and then pass it on, which is useful if a constructor field should generally be lazy. However, neither of these techniques implements recursive strictness—for that, a function called deepSeq was invented.\n\nAlso, pattern matching in Haskell 98 is strict by default, so the ~ qualifier has to be used to make it lazy. \n\nSimulating laziness in eager languages \n\nPython\n\nIn Python 2.x the range() function computes a list of integers. The entire list is stored in memory when the first assignment statement is evaluated, so this is an example of eager or immediate evaluation:\n\n >>> r = range(10)\n >>> print r\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n >>> print r[3]\n 3\n\nIn Python 3.x the range() function returns a special range object which computes elements of the list on demand. Elements of the range object are only generated when they are needed (e.g., when print(r[3]) is evaluated in the following example), so this is an example of lazy or deferred evaluation:\n\n >>> r = range(10)\n >>> print(r)\n range(0, 10)\n >>> print(r[3])\n 3\n\nThis change to lazy evaluation saves execution time for large ranges which may never be fully referenced and memory usage for large ranges where only one or a few elements are needed at any time.\n\nIn Python 2.x is possible to use a function called xrange() which returns an object that generates the numbers in the range on demand. The advantage of xrange is that generated object will always take the same amount of memory.\n\n>>> r = xrange(10)\n>>> print(r)\nxrange(10)\n>>> lst = [x for x in r]\n>>> print(lst)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nFrom version 2.2 forward, Python manifests lazy evaluation by implementing iterators (lazy sequences) unlike tuple or list sequences. For instance (Python 2):\n\n >>> numbers = range(10)\n >>> iterator = iter(numbers)\n >>> print numbers\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n >>> print iterator\n \n >>> print iterator.next()\n 0\n\nThe above example shows that lists are evaluated when called, but in case of iterator, the first element '0' is printed when need arises.\n\n.NET Framework\n\nIn the .NET Framework it is possible to do lazy evaluation using the class System.Lazy. The class can be easily exploited in F# using the lazy keyword, while the force method will force the evaluation. There are also specialized collections like Microsoft.FSharp.Collections.Seq that provide built-in support for lazy evaluation. \n\nlet fibonacci = Seq.unfold (fun (x, y) -> Some(x, (y, x + y))) (0I,1I)\nfibonacci |> Seq.nth 1000\n\nIn C# and VB.NET, the class System.Lazy is directly used. \n\npublic int Sum()\n{\n    int a = 0;\n    int b = 0; \n    Lazy x new Lazy(() \n> a + b);\n    a = 3;\n    b = 5;\n    return x.Value; // returns 8\n}\n\nOr with a more practical example: \n\n// recursive calculation of the n'th fibonacci number\npublic int Fib(int n)\n{\n   return (n 1)? 1 : (n \n 2)? 1 : Fib(n-1) + Fib(n-2);\n}\n\npublic void Main()\n{\n    Console.WriteLine(\"Which Fibonacci number do you want to calculate?\");\n    int n = Int32.Parse(Console.ReadLine()); \n    Lazy fib new Lazy(() \n> Fib(n)); // function is prepared, but not executed\n    bool execute; \n    if(n > 100)\n    {\n        Console.WriteLine(\"This can take some time. Do you really want to calculate this large number? [y/n]\");\n        execute (Console.ReadLine() \n \"y\"); \n    }\n    else execute = true;\n    \n    if(execute) Console.WriteLine(fib.Value); // number is only calculated if needed\n}\n\nAnother way is to use the yield keyword: \n\n// eager evaluation \npublic IEnumerable Fibonacci(int x)\n{\n    IList fibs = new List();\n\n    int prev = -1;\n    int next = 1;\n    for (int i = 0; i  LazyFibonacci(int x)\n{\n    int prev = -1;\n    int next = 1;\n    for (int i = 0; i",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Lazy evaluation" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=18155" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In programming language theory, lazy evaluation, or call-by-need is an evaluation strategy which delays the evaluation of an expression until its value is needed (non-strict evaluation) and which also avoids repeated evaluations (sharing). The sharing can reduce the running time of certain functions by an exponential factor over other non-strict evaluation strategies, such as call-by-name.\n\nThe benefits of lazy evaluation include: \n* The ability to define control flow (structures) as abstractions instead of primitives.\n* The ability to define potentially infinite data structures. This allows for more straightforward implementation of some algorithms.\n* Performance increases by avoiding needless calculations, and error conditions in evaluating compound expressions.\n\nLazy evaluation is often combined with memoization, as described in Jon Bentley's Writing Efficient Programs.Bentley, Jon Louis. Writing Efficient Programs. Prentice-Hall, 1985.  After a function's value is computed for that parameter or set of parameters, the result is stored in a lookup table that is indexed by the values of those parameters; the next time the function is called, the table is consulted to determine whether the result for that combination of parameter values is already available. If so, the stored result is simply returned. If not, the function is evaluated and another entry is added to the lookup table for reuse.\n\nLazy evaluation can lead to reduction in memory footprint, since values are created when needed. However, lazy evaluation is difficult to combine with imperative features such as exception handling and input/output, because the order of operations becomes indeterminate. Lazy evaluation can introduce space leaks.Edward Z. Yang. [http://blog.ezyang.com/2011/05/space-leak-zoo/ \"Space leak zoo\"].\n\nThe opposite of lazy evaluation is eager evaluation, sometimes known as strict evaluation. Eager evaluation is the evaluation strategy employed in most programming languages.\n\nHistory \n\nLazy evaluation was introduced for lambda calculus by Christopher Wadsworth. For programming languages, it was independently introduced by Peter Henderson and James H. Morris and by Daniel P. Friedman and David S. Wise.\n\nApplications \n\nDelayed evaluation is used particularly in functional programming languages. When using delayed evaluation, an expression is not evaluated as soon as it gets bound to a variable, but when the evaluator is forced to produce the expression's value. That is, a statement such as x expression; (i.e. the assignment of the result of an expression to a variable) clearly calls for the expression to be evaluated and the result placed in x, but what actually is in x is irrelevant until there is a need for its value via a reference to x in some later expression whose evaluation could itself be deferred, though eventually the rapidly growing tree of dependencies would be pruned to produce some symbol rather than another for the outside world to see.\n\nDelayed evaluation has the advantage of being able to create calculable infinite lists without infinite loops or size matters interfering in computation. For example, one could create a function that creates an infinite list (often called a stream) of Fibonacci numbers. The calculation of the n-th Fibonacci number would be merely the extraction of that element from the infinite list, forcing the evaluation of only the first n members of the list.\n\nFor example, in the Haskell programming language, the list of all Fibonacci numbers can be written as:\n\n fibs = 0 : 1 : zipWith (+) fibs (tail fibs)\n\nIn Haskell syntax, \":\" prepends an element to a list, tail returns a list without its first element, and zipWith uses a specified function (in this case addition) to combine corresponding elements of two lists to produce a third.\n\nProvided the programmer is careful, only the values that are required to produce a particular result are evaluated. However, certain calculations may result in the program attempting to evaluate an infinite number of elements; for example, requesting the length of the list or trying to sum the elements of the list with a fold operation would result in the program either failing to terminate or running out of memory.\n\nControl structures\n\nIn almost all common \"eager\" languages, if statements evaluate in a lazy fashion.\n if a then b else c\nevaluates (a), then if and only if (a) evaluates to true does it evaluate (b), otherwise it evaluates (c). That is, either (b) or (c) will not be evaluated. Conversely, in an eager language the expected behavior is that\n define f(x, y) = 2 * x\n set k = f(d, e)\nwill still evaluate (e) when computing the value of f(d, e) even though (e) is unused in function f. However, user-defined control structures depend on exact syntax, so for example\n define g(a, b, c) = if a then b else c\n l = g(h, i, j)\n(i) and (j) would both be evaluated in an eager language.  While in a lazy language,\n l' = if h then i else j\n(i) or (j) would be evaluated, but never both.\n\nLazy evaluation allows control structures to be defined normally, and not as primitives or compile-time techniques. If (i) or (j) have side effects or introduce run time errors, the subtle differences between (l) and (l') can be complex. It is usually possible to introduce user-defined lazy control structures in eager languages as functions, though they may depart from the language's syntax for eager evaluation: Often the involved code bodies (like (i) and (j)) need to be wrapped in a function value, so that they are executed only when called.\n\nShort-circuit evaluation of Boolean control structures is sometimes called lazy.\n\nWorking with infinite data structures \n\nMany languages offer the notion of infinite data-structures. These allow definitions of data to be given in terms of infinite ranges, or unending recursion, but the actual values are only computed when needed. Take for example this trivial program in Haskell:\n\nnumberFromInfiniteList :: Int -> Int\nnumberFromInfiniteList n =  infinity !! n - 1\n    where infinity = [1..]\n\nmain = print $ numberFromInfiniteList 4\n\nIn the function numberFromInfiniteList, the value of infinity is an infinite range, but until an actual value (or more specifically, a specific value at a certain index) is needed, the list is not evaluated, and even then it is only evaluated as needed (that is, until the desired index.)\n\nList-of-successes pattern \n\nOther uses\n\nIn computer windowing systems, the painting of information to the screen is driven by expose events which drive the display code at the last possible moment. By doing this, windowing systems avoid computing unnecessary display content updates.[http://research.microsoft.com/en-us/um/people/blampson/slides/lazyandspeculative.ppt Lazy and Speculative Execution] Butler Lampson Microsoft Research OPODIS, Bordeaux, France 12 December 2006\n\nAnother example of laziness in modern computer systems is copy-on-write page allocation or demand paging, where memory is allocated only when a value stored in that memory is changed.\n\nLaziness can be useful for high performance scenarios. An example is the Unix mmap function, which provides demand driven loading of pages from disk, so that only those pages actually touched are loaded into memory, and unneeded memory is not allocated.\n\nMATLAB implements copy on edit, where arrays which are copied have their actual memory storage replicated only when their content is changed, possibly leading to an out of memory error when updating an element afterwards instead of during the copy operation.\n\nImplementation\n\nSome programming languages delay evaluation of expressions by default, and some others provide functions or special syntax to delay evaluation. In Miranda and Haskell, evaluation of function arguments is delayed by default. In many other languages, evaluation can be delayed by explicitly suspending the computation using special syntax (as with Scheme's \"delay\" and \"force\" and OCaml's \"lazy\" and \"Lazy.force\") or, more generally, by wrapping the expression in a thunk. The object representing such an explicitly delayed evaluation is called a lazy future. Perl 6 uses lazy evaluation of lists, so one can assign infinite lists to variables and use them as arguments to functions, but unlike Haskell and Miranda, Perl 6 doesn't use lazy evaluation of arithmetic operators and functions by default.\n\nLaziness and eagerness \n\nControlling eagerness in lazy languages\n\nIn lazy programming languages such as Haskell, although the default is to evaluate expressions only when they are demanded, it is possible in some cases to make code more eager—or conversely, to make it more lazy again after it has been made more eager. This can be done by explicitly coding something which forces evaluation (which may make the code more eager) or avoiding such code (which may make the code more lazy). Strict evaluation usually implies eagerness, but they are technically different concepts.\n\nHowever, there is an optimisation implemented in some compilers called strictness analysis, which, in some cases, allows the compiler to infer that a value will always be used. In such cases, this may render the programmer's choice of whether to force that particular value or not, irrelevant, because strictness analysis will force strict evaluation.\n\nIn Haskell, marking constructor fields strict means that their values will always be demanded immediately. The seq function can also be used to demand a value immediately and then pass it on, which is useful if a constructor field should generally be lazy. However, neither of these techniques implements recursive strictness—for that, a function called deepSeq was invented.\n\nAlso, pattern matching in Haskell 98 is strict by default, so the ~ qualifier has to be used to make it lazy. \n\nSimulating laziness in eager languages \n\nPython\n\nIn Python 2.x the range() function computes a list of integers. The entire list is stored in memory when the first assignment statement is evaluated, so this is an example of eager or immediate evaluation:\n\n >>> r = range(10)\n >>> print r\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n >>> print r[3]\n 3\n\nIn Python 3.x the range() function returns a special range object which computes elements of the list on demand. Elements of the range object are only generated when they are needed (e.g., when print(r[3]) is evaluated in the following example), so this is an example of lazy or deferred evaluation:\n\n >>> r = range(10)\n >>> print(r)\n range(0, 10)\n >>> print(r[3])\n 3\n\nThis change to lazy evaluation saves execution time for large ranges which may never be fully referenced and memory usage for large ranges where only one or a few elements are needed at any time.\n\nIn Python 2.x is possible to use a function called xrange() which returns an object that generates the numbers in the range on demand. The advantage of xrange is that generated object will always take the same amount of memory.\n\n>>> r = xrange(10)\n>>> print(r)\nxrange(10)\n>>> lst = [x for x in r]\n>>> print(lst)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nFrom version 2.2 forward, Python manifests lazy evaluation by implementing iterators (lazy sequences) unlike tuple or list sequences. For instance (Python 2):\n\n >>> numbers = range(10)\n >>> iterator = iter(numbers)\n >>> print numbers\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n >>> print iterator\n \n >>> print iterator.next()\n 0\n\nThe above example shows that lists are evaluated when called, but in case of iterator, the first element '0' is printed when need arises.\n\n.NET Framework\n\nIn the .NET Framework it is possible to do lazy evaluation using the class System.Lazy. The class can be easily exploited in F# using the lazy keyword, while the force method will force the evaluation. There are also specialized collections like Microsoft.FSharp.Collections.Seq that provide built-in support for lazy evaluation. \n\nlet fibonacci = Seq.unfold (fun (x, y) -> Some(x, (y, x + y))) (0I,1I)\nfibonacci |> Seq.nth 1000\n\nIn C# and VB.NET, the class System.Lazy is directly used. \n\npublic int Sum()\n{\n    int a = 0;\n    int b = 0; \n    Lazy x new Lazy(() \n> a + b);\n    a = 3;\n    b = 5;\n    return x.Value; // returns 8\n}\n\nOr with a more practical example: \n\n// recursive calculation of the n'th fibonacci number\npublic int Fib(int n)\n{\n   return (n 1)? 1 : (n \n 2)? 1 : Fib(n-1) + Fib(n-2);\n}\n\npublic void Main()\n{\n    Console.WriteLine(\"Which Fibonacci number do you want to calculate?\");\n    int n = Int32.Parse(Console.ReadLine()); \n    Lazy fib new Lazy(() \n> Fib(n)); // function is prepared, but not executed\n    bool execute; \n    if(n > 100)\n    {\n        Console.WriteLine(\"This can take some time. Do you really want to calculate this large number? [y/n]\");\n        execute (Console.ReadLine() \n \"y\"); \n    }\n    else execute = true;\n    \n    if(execute) Console.WriteLine(fib.Value); // number is only calculated if needed\n}\n\nAnother way is to use the yield keyword: \n\n// eager evaluation \npublic IEnumerable Fibonacci(int x)\n{\n    IList fibs = new List();\n\n    int prev = -1;\n    int next = 1;\n    for (int i = 0; i  LazyFibonacci(int x)\n{\n    int prev = -1;\n    int next = 1;\n    for (int i = 0; i. Lazy evaluation. http://en.wikipedia.org/?curid=18155."
  }
}
