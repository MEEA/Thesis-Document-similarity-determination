{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=6600",
  "eid" : "dc516150-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778449381,
  "textBody" : "In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. Currying is related to, but not the same as, partial application.\n\nCurrying is useful in both practical and theoretical settings. In functional programming languages, and many others, it provides a way of automatically managing how arguments are passed to functions and exceptions. In theoretical computer science, it provides a way to study functions with multiple arguments in simpler theoretical models which provide only one argument. The most general setting for the strict notion of currying and uncurrying is in the closed monoidal categories; this is interesting because it underpins a vast generalization of the Curry–Howard correspondence of proofs and programs to a correspondence with many other structures, including quantum mechanics, cobordisms and string theory.  It was introduced by Gottlob Frege,Willard Van Orman Quine, introduction to \"Bausteine der mathematischen Logik\", pp. 305–316. Translated by Stefan Bauer-Mengelberg as \"On the building blocks of mathematical logic\" in Jean van Heijenoort (1967), A Source Book in Mathematical Logic, 1879–1931. Harvard University Press, pp. 355–66. developed by Moses Schönfinkel, (Reprinted lecture notes from 1967.)Kenneth Slonneger and Barry L. Kurtz. Formal Syntax and Semantics of Programming Languages. 1995. p. 144.\nand further developed by Haskell Curry.Henk Barendregt, Erik Barendsen, \"[ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf Introduction to Lambda Calculus]\", March 2000, page 8.\n\nUncurrying is the dual transformation to currying, and can be seen as a form of defunctionalization.  It takes a function f whose return value is another function g, and yields a new function f′ that takes as parameters the arguments for both f and g, and returns, as a result, the application of f and subsequently, g, to those arguments.  The process can be iterated.\n\nMotivation\n\nCurrying provides a way for working with functions that take multiple arguments, and using them in frameworks where functions might take only one argument. For example, some analytical techniques can only be applied to functions with a single argument. Practical functions frequently take more arguments than this. Frege showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying. All \"ordinary\" functions that might typically be encountered in mathematical analysis or in computer programming can be curried.  However, there are categories in which currying is not possible; the most general category which does allow currying is the closed monoidal category.\n\nSome programming languages almost always use curried functions to achieve multiple arguments; notable examples are ML and Haskell, where in both cases all functions have exactly one argument. This property is inherited from lambda calculus, where multi-argument functions are usually represented in curried form.\n\nCurrying is related to, but not the same as partial application. In practice, the programming technique of closures can be used to perform partial application and a kind of currying, by hiding arguments in an environment that travels with the curried function.\n\nPartial application\n\nCurrying resembles the process of evaluating a function of multiple variables, when done by hand, on paper, being careful to show all of the steps.\n\nFor example, given the function f(x,y) = y / x:\nTo evaluate f(2,3), first replace x with 2\n\nSince the result is a function of y, this new function g(y) can be defined as g(y) f(2,y) \n y/2\n\nNext, replace the y argument with 3, producing g(3) f(2,3) \n 3/2\n\nOn paper, using classical notation, this is usually done all in one step. However, each argument can be replaced sequentially as well. Each replacement results in a function taking exactly one argument.\n\nThis example is somewhat flawed, in that currying, while similar to partial function application, is not the same (see below).\n\nIllustration \n\nCurrying is a method for producing a chain of functions, each taking exactly one argument.  The construction is achieved by \"hiding\" all but one argument in another, new, curried function, whose job it is to return functions of the remaining arguments.  This is explicitly (but informally) illustrated next.\n\nGiven a function f that takes two arguments x and y, that is,\nf(x,y)\none may then construct a new function hx, related to the original f.  This form takes only one argument, y, and, given that argument, hx(y) returns f(x,y).  That is,\nh_x(y) = f(x,y).\nHere, it should be clear that the subscript x on h is a notational device used to hide or salt away one of the arguments, putting it to the side, so that one gets to work with a function having only one argument. Currying formulates a functional abstraction, for such a notational trick.\n\nTo complete such a trick, a map or function constructor must then be devised using the common notation \\mapsto, that signifies actual abstract action. Notation such as y \\mapsto z then denotes a function, mapping an argument y to a result z.\n\nThereafter, consider erasing the subscript x from the representative notation hx. Such action yields a curried representative notation h; thereby being a function given an x, is able to return as its \"value\", a different function hx; which then happens to be a function constructor, whose map is notationally represented with the statement y \\mapsto f(x,y). Alternatively, described as a function mapping an argument y to a result z. That is,\nh_x = (y \\mapsto f(x,y)),\nseen with different (but equivalent) representative notation, \nh(x) = (y \\mapsto f(x,y))\nThe function h itself, can now be represented in a notationally similar fashion with hx, and written as\nh = (x \\mapsto (y \\mapsto f(x,y)))\n\ncapable of accounting for, and acting upon, all of the initially stated, to be involved functional arguments. Given the above, the act of currying can be recognized as a function that, given some arbitrary f, that is to be involved with related h functionality, is then able to produce, the stated functionality of h; involving said f.  That is,\n\\text{curry} = (f \\mapsto h)\nor, equivalently\n\\text{curry}(f) = h\n\nThis illustrates the fundamental, essential nature of currying: it is a mechanism for relocating an argument, by bundling it into a function that returns another related function involved with the argument f.  That is, given a function f that returns a \"value\", one \"constructs\" a new function h that returns a function involving f.  A different way of understanding currying is to realize that it is just an algebraic game, a syntactic rearranging of symbols. One does not ask what the \"meaning\" of the symbols are; one only agrees to the rules for their rearrangement.  To see this, note that the original function f itself may be written as\n\nf = ((x,y) \\mapsto f(x,y))\n\nComparing to the function h above, one sees that the two forms involve a re-arrangement of parenthesis, together with the conversion of a comma into an arrow.\n\nReturning to the earlier example,\nf(x,y) = \\frac{y}{x}\none then has that,\ng h_2 \n h(2) = (y \\mapsto f(2,y))\nas the curried equivalent of the example above.  Adding an argument to g then gives\ng(y) h_2(y) \n h(2)(y) f(2,y) \n \\frac{y}{2}\nand\ng(3) h_2(3) \n h(2)(3) f(2,3) \n \\frac{3}{2} .\n\nThe peeling away of arguments might be better understood by considering a function of, say, four arguments:\nf(x,y,z,w)\nProceeding as above, one is led to the form\nh_x = ((y,z,w) \\mapsto f(x,y,z,w))\nwhich can be applied to a triple to get\nh_x(y,z,w) = f(x,y,z,w).\nThe curried form is then properly written as\nh = (x \\mapsto ((y,z,w) \\mapsto f(x,y,z,w)))\nBy continuing to play the algebraic game of re-arranging symbols, one is eventually led to the fully curried form\nx \\mapsto (y \\mapsto (z \\mapsto (w \\mapsto f(x,y,z,w))))\nIt is commonly understood that the arrow operator is right-associative, and so most of the parenthesis above are superfluous, and can be removed without altering the meaning. Thus, it is common to write\nx \\mapsto y \\mapsto z \\mapsto w \\mapsto f(x,y,z,w)\nfor the fully curried form of f.\n\nHistory \n\nThe name \"currying\", coined by Christopher Strachey in 1967, is a reference to logician Haskell Curry.  The alternative name \"Schönfinkelisation\" has been proposed as a reference to Moses Schönfinkel.I. Heim and A. Kratzer (1998). Semantics in Generative Grammar. Blackwell.  In the mathematical context, the principle can be traced back to work in 1893 by Frege.\n\nDefinition \n\nCurrying is most easily understood by starting with an informal definition, which can then be molded to fit many different domains. First, there is some notation to be established. Let f \\colon X \\to Y  denote a function f from X to Y. The notation X \\to Y  then denotes all functions from X to Y.  Here, X and Y may be sets, or they may be types, or they may be other kinds of objects, as explored below. Let X \\times Y denote ordered pairs, that is, the Cartesian product.\n\nGiven a function f of type f \\colon (X \\times Y) \\to Z , currying constructs or makes a new function \\text{curry}(f) \\colon X \\to (Y \\to Z) . That is, \\text{curry}(f)  takes an argument of type X and returns a function of type Y \\to Z. Uncurrying is the reverse transformation, and is most easily understood in terms of its right adjoint, apply.\n\nSet theory \n\nIn set theory, the notation Y^X is used to denote the set of functions from the set X to the set Y. Currying is the natural correspondence between the set A^{B\\times C} of functions from B\\times C to A, and the set \\left(A^C\\right)^B of functions from B to the set of functions from C to A.  Indeed, it is this natural correspondence that justifies the exponential notation for the set of functions. In the category of sets, the object Y^X is called the exponential object.\n\nFunction spaces \n\nIn the theory of function spaces, such as in functional analysis or homotopy theory, one is commonly interested in continuous functions between topological spaces. One writes \\text{Hom}(X,Y) (the Hom functor) for the set of all functions from X to Y, and uses the notation Y^X to denote the subset of continuous functions. Here, \\text{curry} is the bijection\n\n\\text{curry}:\\text{Hom}(X\\times Y, Z) \\to \\text{Hom}(X, \\text{Hom}(Y,Z)) ,\n\nwhile uncurrying is the inverse map. If the set Y^X of continuous functions from X to Y is given the compact-open topology, and if the space Y is locally compact Hausdorff, then \\text{curry} is a continuous function, and is a homeomorphism.  This is also the case when X, Y and Y^X are kaonized,J.P. May, [http://www.math.uchicago.edu/~may/CONCISE/ConciseRevised.pdf A Concise Course in Algebraic Topology], (1999) Chicago Lectures in Mathematics  although there are more cases.P. I. Booth and J. Tillotson, \"[http://msp.org/pjm/1980/88-1/pjm-v88-n1-p03-s.pdf Monoidal closed, Cartesian closed and convenient categories of topological spaces]\", Pacific Journal of Mathematics, 88 (1980) pp.33-53.\n\nThis result motivates the exponential notation\n\n\\text{curry}:Z^{X\\times Y} \\to (Z^Y)^X\n\nwhich is sometimes called the exponential law.  One useful corollary is that a function is continuous if and only if its curried form is continuous.  Another important result is that the application map, usually called \"evaluation\" in this context, is continuous (note that eval is a strictly different concept in computer science.) That is,\n\n\\begin{align} &&\\text{eval}:Y^X \\times X \\to Y \\\\\n                     && (f,x) \\mapsto f(x) \\end{align}\n\nis continuous when Y^X is compact-open and Y locally compact Hausdorff.Joseph J. Rotman, An Introduction to Algebraic Topology (1988) Springer-Verlag  (See Chapter 11 for proof.) These two results are central for establishing the continuity of homotopy, i.e. when X is the unit interval I, so that Z^{I\\times Y} \\cong (Z^Y)^I can the thought of as either a homotopy of two functions from Y to Z, or, equivalently, a single (continuous) path in Z^Y.\n\nAlgebraic topology \n\nIn algebraic topology, currying serves as an example of Eckmann–Hilton duality, and, as such, plays an important role in a variety of different settings. For example, loop space is adjoint to reduced suspensions; this is commonly written as\n[\\Sigma X,Z] \\approxeq [X, \\Omega Z]\nwhere [A,B] is the set of homotopy classes of maps A \\rightarrow B, and \\Sigma A is the suspension of A, and \\Omega A is the loop space of A.  In essence, the suspension \\Sigma X can be seen as the cartesian product of X with the unit interval, modulo an equivalence relation to turn the interval into a loop.  The curried form then maps the space X to the space of functions from loops into Z, that is, from X into \\Omega Z. Then \\text{curry} is the adjoint functor that maps suspensions to loop spaces, and uncurrying is the dual.\n\nThe duality between the mapping cone and the mapping fiber (cofibration and fibration) can be understood as a form of currying, which in turn leads to the duality of the long exact and coexact Puppe sequences.\n\nIn homological algebra, the relationship between currying and uncurrying is known as tensor-hom adjunction.  Here, an interesting twist arises: the Hom functor and the tensor product functor might not lift to an exact sequence; this leads to the definition of the Ext functor and the Tor functor.\n\nDomain theory \n\nIn order theory, that is, the theory of lattices of partially ordered sets, \\text{curry} is a continuous function when the lattice is given the Scott topology. (See theorems 1.2.13, 1.2.14) Scott-continuous functions were first investigated in the attempt to provide a semantics for lambda calculus (as ordinary set theory is inadequate to do this).  More generally, Scott-continuous functions are now studied in domain theory, which encompasses the study of denotational semantics of computer algorithms. Note that the Scott topology is quite different than many common topologies one might encounter in the category of topological spaces; the Scott topology is typically finer, and is not sober.\n\nThe notion of continuity makes its appearance in homotopy type theory, where, roughly speaking, two computer programs can be considered to be homotopic, i.e. compute the same results, if they can be \"continuously\" refactored from one to the other.\n\nLambda calculi \n\nIn theoretical computer science, currying provides a way to study functions with multiple arguments in very simple theoretical models, such as the lambda calculus, in which functions only take a single argument. Consider a function f(x,y) taking two arguments, and having the type (X \\times Y)\\to Z, which should be understood to mean that x must have the type X, y must have the type Y, and the function itself returns the type Z. The curried form of f is defined as\n\n\\text{curry}(f) = \\lambda x.(\\lambda y.(f(x,y)))\n\nwhere \\lambda is the abstractor of lambda calculus. Since curry takes, as input, functions with the type (X\\times Y)\\to Z, one concludes that the type of curry itself is\n\n\\text{curry}:((X \\times Y)\\to Z) \\to (X \\to (Y \\to Z))\n\nThe → operator is often considered right-associative, so the curried function type X \\to (Y \\to Z) is often written as X \\to Y \\to Z.  Conversely,  function application is considered to be left-associative, so that f(x, y) is equivalent to\n\n((\\text{curry}(f) \\; x) \\;y) = \\text{curry}(f) \\; x \\;y.\n\nThat is, the parenthesis are not required to disambiguate the order of the application.\n\nCurried functions may be used in any programming language that supports closures; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.\n\nType theory \n\nIn type theory, the general idea of a type system in computer science is formalized into a specific algebra of types. For example, when writing f \\colon X \\to Y , the intent is that X and Y are types, while the arrow \\to is a type constructor, specifically, the function type or arrow type.  Similarly, the Cartesian product X \\times Y of types is constructed by the product type constructor \\times.\n\nThe type-theoretical approach is expressed in programming languages such as ML and the languages derived from and inspired by it: CaML, Haskell and F#.\n\nThe type-theoretical approach provides a natural complement to the language of category theory, as discussed below. This is because categories, and specifically, monoidal categories, have an internal language, with simply-typed lambda calculus being the most prominent example of such a language.  It is important in this context, because it can be built from a single type constructor, the arrow type.  Currying then endows the language with a natural product type. The correspondence between objects in categories and types then allows programming languages to be re-interpreted as logics (via Curry–Howard correspondence), and as other types of mathematical systems, as explored further, below.\n\nLogic \n\nUnder the Curry–Howard correspondence, the existence of currying and uncurrying is equivalent to the logical theorem (A \\and B) \\to C \\Leftrightarrow A \\to (B \\to C), as tuples (product type) corresponds to conjunction in logic, and function type corresponds to implication.\n\nCategory theory \n\nThe above notions of currying and uncurrying find their most general, abstract statement in category theory. Currying is a universal property of an exponential object, and gives rise to an adjunction in cartesian closed categories. That is, there is a natural isomorphism between the morphisms from a binary product f \\colon (X \\times Y) \\to Z  and the morphisms to an exponential object g \\colon X \\to Z^Y . This generalizes to a broader result that the tensor product and the Hom functor are adjoint in closed monoidal categories. Currying is the statement that the tensor product and the internal Hom are adjoint functors; that is, there is a natural transformation: \n \\hom(A\\otimes B, C) \\cong \\hom(A, B\\Rightarrow C) .\nHere, hom is written lower case, to indicate that it is the internal hom functor, distinguishing it from the external (upper-case) Hom. For the category of sets, the two are the same. When the product is the cartesian product, then the internal hom B\\Rightarrow C becomes the exponential object C^B.\n\nThe setting of cartesian closed categories is sufficient for the discussion of classical logic; the more general setting of closed monoidal categories is suitable for quantum computation.Samson Abramsky and Bob Coecke, \"[https://arxiv.org/abs/quantph/0402130/ A Categorical Semantics for Quantum Protocols].\"\n\nThe difference between these two is that the product for cartesian categories (such as the category of sets, complete partial orders or Heyting algebras) is just the Cartesian product; it is interpreted as an ordered pair of items (or a list).  Simply typed lambda calculus is the internal language of cartesian closed categories; and it is for this reason that pairs and lists are the primary types in the type theory of LISP, scheme and many functional programming languages.\n\nBy contrast, the product for monoidal categories (such as Hilbert space and the vector spaces of functional analysis) is the tensor product. The internal language of such categories is linear logic, a form of quantum logic; the corresponding type system is the linear type system. Such categories are suitable for describing entangled quantum states, and, more generally, allow a vast generalization of the Curry–Howard correspondence to quantum mechanics, to cobordisms in algebraic topology, and to string theory.John C. Baez and Mike Stay, \"[http://math.ucr.edu/home/baez/rosetta/rose3.pdf Physics, Topology, Logic and Computation: A Rosetta Stone]\", (2009) [https://arxiv.org/abs/0903.0340/ ArXiv 0903.0340] in New Structures for Physics, ed. Bob Coecke, Lecture Notes in Physics vol. 813, Springer, Berlin, 2011, pp. 95-174.  The linear type system, and linear logic are useful for describing synchronization primitives, such as mutual exclusion locks, and the operation of vending machines.\n\nContrast with partial function application \n\nCurrying and partial function application are often conflated. (Reference is a blog). One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose arity is greater than two.\n\nGiven a function of type f \\colon (X \\times Y \\times Z) \\to N , currying produces \\text{curry}(f) \\colon X \\to (Y \\to (Z \\to N)) .  That is, while an evaluation of the first function might be represented as f(1, 2, 3), evaluation of the curried function would be represented as f_\\text{curried}(1)(2)(3), applying each argument in turn to a single-argument function returned by the previous invocation.  Note that after calling f_\\text{curried}(1), we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.\n\nIn contrast, partial function application refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.  Given the definition of f above, we might fix (or 'bind') the first argument, producing a function of type \\text{partial}(f) \\colon (Y \\times Z) \\to N.  Evaluation of this function might be represented as f_\\text{partial}(2, 3).  Note that the result of partial function application in this case is a function that takes two arguments.\n\nIntuitively, partial function application says \"if you fix the first argument of the function, you get a function of the remaining arguments\". For example, if function div stands for the division operation x/y, then div with the parameter x fixed at 1 (i.e., div 1) is another function: the same as the function inv that returns the multiplicative inverse of its argument, defined by inv(y) = 1/y.\n\nThe practical motivation for partial application is that very often the functions obtained by supplying some but not all of the arguments to a function are useful; for example, many languages have a function or operator similar to plus_one. Partial application makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.\n\nPartial application can be seen as evaluating a curried function at a fixed point, e.g. given f \\colon (X \\times Y \\times Z) \\to N  and a \\in X then \\text{curry}(\\text{partial}(f)_a)(y)(z) \\text{curry}(f)(a)(y)(z)  or simply \\text{partial}(f)_a \n \\text{curry}_1(f)(a)  where \\text{curry}_1 curries f's first parameter. \n\nThus, partial application is reduced to a curried function at a fixed point. Further, a curried function at a fixed point is (trivially), a partial application.  Thus, by reduction, a curried function at a fixed point is a partial application.  For further evidence, note that, given any function f(x,y), a function g(y,x) may be defined such that g(y,x) = f(x,y).  Thus, any partial application may be reduced to a single curry operation.  As such, curry is more suitably defined as an operation which, in many theoretical cases, is often applied recursively, but which is theoretically indistinguishable (when considered as an operation) from a partial application.\n\nSo, a partial application can be defined as the objective result of a single application of the curry operator on some ordering of the inputs of some function.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Currying" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=6600" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. Currying is related to, but not the same as, partial application.\n\nCurrying is useful in both practical and theoretical settings. In functional programming languages, and many others, it provides a way of automatically managing how arguments are passed to functions and exceptions. In theoretical computer science, it provides a way to study functions with multiple arguments in simpler theoretical models which provide only one argument. The most general setting for the strict notion of currying and uncurrying is in the closed monoidal categories; this is interesting because it underpins a vast generalization of the Curry–Howard correspondence of proofs and programs to a correspondence with many other structures, including quantum mechanics, cobordisms and string theory.  It was introduced by Gottlob Frege,Willard Van Orman Quine, introduction to \"Bausteine der mathematischen Logik\", pp. 305–316. Translated by Stefan Bauer-Mengelberg as \"On the building blocks of mathematical logic\" in Jean van Heijenoort (1967), A Source Book in Mathematical Logic, 1879–1931. Harvard University Press, pp. 355–66. developed by Moses Schönfinkel, (Reprinted lecture notes from 1967.)Kenneth Slonneger and Barry L. Kurtz. Formal Syntax and Semantics of Programming Languages. 1995. p. 144.\nand further developed by Haskell Curry.Henk Barendregt, Erik Barendsen, \"[ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf Introduction to Lambda Calculus]\", March 2000, page 8.\n\nUncurrying is the dual transformation to currying, and can be seen as a form of defunctionalization.  It takes a function f whose return value is another function g, and yields a new function f′ that takes as parameters the arguments for both f and g, and returns, as a result, the application of f and subsequently, g, to those arguments.  The process can be iterated.\n\nMotivation\n\nCurrying provides a way for working with functions that take multiple arguments, and using them in frameworks where functions might take only one argument. For example, some analytical techniques can only be applied to functions with a single argument. Practical functions frequently take more arguments than this. Frege showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying. All \"ordinary\" functions that might typically be encountered in mathematical analysis or in computer programming can be curried.  However, there are categories in which currying is not possible; the most general category which does allow currying is the closed monoidal category.\n\nSome programming languages almost always use curried functions to achieve multiple arguments; notable examples are ML and Haskell, where in both cases all functions have exactly one argument. This property is inherited from lambda calculus, where multi-argument functions are usually represented in curried form.\n\nCurrying is related to, but not the same as partial application. In practice, the programming technique of closures can be used to perform partial application and a kind of currying, by hiding arguments in an environment that travels with the curried function.\n\nPartial application\n\nCurrying resembles the process of evaluating a function of multiple variables, when done by hand, on paper, being careful to show all of the steps.\n\nFor example, given the function f(x,y) = y / x:\nTo evaluate f(2,3), first replace x with 2\n\nSince the result is a function of y, this new function g(y) can be defined as g(y) f(2,y) \n y/2\n\nNext, replace the y argument with 3, producing g(3) f(2,3) \n 3/2\n\nOn paper, using classical notation, this is usually done all in one step. However, each argument can be replaced sequentially as well. Each replacement results in a function taking exactly one argument.\n\nThis example is somewhat flawed, in that currying, while similar to partial function application, is not the same (see below).\n\nIllustration \n\nCurrying is a method for producing a chain of functions, each taking exactly one argument.  The construction is achieved by \"hiding\" all but one argument in another, new, curried function, whose job it is to return functions of the remaining arguments.  This is explicitly (but informally) illustrated next.\n\nGiven a function f that takes two arguments x and y, that is,\nf(x,y)\none may then construct a new function hx, related to the original f.  This form takes only one argument, y, and, given that argument, hx(y) returns f(x,y).  That is,\nh_x(y) = f(x,y).\nHere, it should be clear that the subscript x on h is a notational device used to hide or salt away one of the arguments, putting it to the side, so that one gets to work with a function having only one argument. Currying formulates a functional abstraction, for such a notational trick.\n\nTo complete such a trick, a map or function constructor must then be devised using the common notation \\mapsto, that signifies actual abstract action. Notation such as y \\mapsto z then denotes a function, mapping an argument y to a result z.\n\nThereafter, consider erasing the subscript x from the representative notation hx. Such action yields a curried representative notation h; thereby being a function given an x, is able to return as its \"value\", a different function hx; which then happens to be a function constructor, whose map is notationally represented with the statement y \\mapsto f(x,y). Alternatively, described as a function mapping an argument y to a result z. That is,\nh_x = (y \\mapsto f(x,y)),\nseen with different (but equivalent) representative notation, \nh(x) = (y \\mapsto f(x,y))\nThe function h itself, can now be represented in a notationally similar fashion with hx, and written as\nh = (x \\mapsto (y \\mapsto f(x,y)))\n\ncapable of accounting for, and acting upon, all of the initially stated, to be involved functional arguments. Given the above, the act of currying can be recognized as a function that, given some arbitrary f, that is to be involved with related h functionality, is then able to produce, the stated functionality of h; involving said f.  That is,\n\\text{curry} = (f \\mapsto h)\nor, equivalently\n\\text{curry}(f) = h\n\nThis illustrates the fundamental, essential nature of currying: it is a mechanism for relocating an argument, by bundling it into a function that returns another related function involved with the argument f.  That is, given a function f that returns a \"value\", one \"constructs\" a new function h that returns a function involving f.  A different way of understanding currying is to realize that it is just an algebraic game, a syntactic rearranging of symbols. One does not ask what the \"meaning\" of the symbols are; one only agrees to the rules for their rearrangement.  To see this, note that the original function f itself may be written as\n\nf = ((x,y) \\mapsto f(x,y))\n\nComparing to the function h above, one sees that the two forms involve a re-arrangement of parenthesis, together with the conversion of a comma into an arrow.\n\nReturning to the earlier example,\nf(x,y) = \\frac{y}{x}\none then has that,\ng h_2 \n h(2) = (y \\mapsto f(2,y))\nas the curried equivalent of the example above.  Adding an argument to g then gives\ng(y) h_2(y) \n h(2)(y) f(2,y) \n \\frac{y}{2}\nand\ng(3) h_2(3) \n h(2)(3) f(2,3) \n \\frac{3}{2} .\n\nThe peeling away of arguments might be better understood by considering a function of, say, four arguments:\nf(x,y,z,w)\nProceeding as above, one is led to the form\nh_x = ((y,z,w) \\mapsto f(x,y,z,w))\nwhich can be applied to a triple to get\nh_x(y,z,w) = f(x,y,z,w).\nThe curried form is then properly written as\nh = (x \\mapsto ((y,z,w) \\mapsto f(x,y,z,w)))\nBy continuing to play the algebraic game of re-arranging symbols, one is eventually led to the fully curried form\nx \\mapsto (y \\mapsto (z \\mapsto (w \\mapsto f(x,y,z,w))))\nIt is commonly understood that the arrow operator is right-associative, and so most of the parenthesis above are superfluous, and can be removed without altering the meaning. Thus, it is common to write\nx \\mapsto y \\mapsto z \\mapsto w \\mapsto f(x,y,z,w)\nfor the fully curried form of f.\n\nHistory \n\nThe name \"currying\", coined by Christopher Strachey in 1967, is a reference to logician Haskell Curry.  The alternative name \"Schönfinkelisation\" has been proposed as a reference to Moses Schönfinkel.I. Heim and A. Kratzer (1998). Semantics in Generative Grammar. Blackwell.  In the mathematical context, the principle can be traced back to work in 1893 by Frege.\n\nDefinition \n\nCurrying is most easily understood by starting with an informal definition, which can then be molded to fit many different domains. First, there is some notation to be established. Let f \\colon X \\to Y  denote a function f from X to Y. The notation X \\to Y  then denotes all functions from X to Y.  Here, X and Y may be sets, or they may be types, or they may be other kinds of objects, as explored below. Let X \\times Y denote ordered pairs, that is, the Cartesian product.\n\nGiven a function f of type f \\colon (X \\times Y) \\to Z , currying constructs or makes a new function \\text{curry}(f) \\colon X \\to (Y \\to Z) . That is, \\text{curry}(f)  takes an argument of type X and returns a function of type Y \\to Z. Uncurrying is the reverse transformation, and is most easily understood in terms of its right adjoint, apply.\n\nSet theory \n\nIn set theory, the notation Y^X is used to denote the set of functions from the set X to the set Y. Currying is the natural correspondence between the set A^{B\\times C} of functions from B\\times C to A, and the set \\left(A^C\\right)^B of functions from B to the set of functions from C to A.  Indeed, it is this natural correspondence that justifies the exponential notation for the set of functions. In the category of sets, the object Y^X is called the exponential object.\n\nFunction spaces \n\nIn the theory of function spaces, such as in functional analysis or homotopy theory, one is commonly interested in continuous functions between topological spaces. One writes \\text{Hom}(X,Y) (the Hom functor) for the set of all functions from X to Y, and uses the notation Y^X to denote the subset of continuous functions. Here, \\text{curry} is the bijection\n\n\\text{curry}:\\text{Hom}(X\\times Y, Z) \\to \\text{Hom}(X, \\text{Hom}(Y,Z)) ,\n\nwhile uncurrying is the inverse map. If the set Y^X of continuous functions from X to Y is given the compact-open topology, and if the space Y is locally compact Hausdorff, then \\text{curry} is a continuous function, and is a homeomorphism.  This is also the case when X, Y and Y^X are kaonized,J.P. May, [http://www.math.uchicago.edu/~may/CONCISE/ConciseRevised.pdf A Concise Course in Algebraic Topology], (1999) Chicago Lectures in Mathematics  although there are more cases.P. I. Booth and J. Tillotson, \"[http://msp.org/pjm/1980/88-1/pjm-v88-n1-p03-s.pdf Monoidal closed, Cartesian closed and convenient categories of topological spaces]\", Pacific Journal of Mathematics, 88 (1980) pp.33-53.\n\nThis result motivates the exponential notation\n\n\\text{curry}:Z^{X\\times Y} \\to (Z^Y)^X\n\nwhich is sometimes called the exponential law.  One useful corollary is that a function is continuous if and only if its curried form is continuous.  Another important result is that the application map, usually called \"evaluation\" in this context, is continuous (note that eval is a strictly different concept in computer science.) That is,\n\n\\begin{align} &&\\text{eval}:Y^X \\times X \\to Y \\\\\n                     && (f,x) \\mapsto f(x) \\end{align}\n\nis continuous when Y^X is compact-open and Y locally compact Hausdorff.Joseph J. Rotman, An Introduction to Algebraic Topology (1988) Springer-Verlag  (See Chapter 11 for proof.) These two results are central for establishing the continuity of homotopy, i.e. when X is the unit interval I, so that Z^{I\\times Y} \\cong (Z^Y)^I can the thought of as either a homotopy of two functions from Y to Z, or, equivalently, a single (continuous) path in Z^Y.\n\nAlgebraic topology \n\nIn algebraic topology, currying serves as an example of Eckmann–Hilton duality, and, as such, plays an important role in a variety of different settings. For example, loop space is adjoint to reduced suspensions; this is commonly written as\n[\\Sigma X,Z] \\approxeq [X, \\Omega Z]\nwhere [A,B] is the set of homotopy classes of maps A \\rightarrow B, and \\Sigma A is the suspension of A, and \\Omega A is the loop space of A.  In essence, the suspension \\Sigma X can be seen as the cartesian product of X with the unit interval, modulo an equivalence relation to turn the interval into a loop.  The curried form then maps the space X to the space of functions from loops into Z, that is, from X into \\Omega Z. Then \\text{curry} is the adjoint functor that maps suspensions to loop spaces, and uncurrying is the dual.\n\nThe duality between the mapping cone and the mapping fiber (cofibration and fibration) can be understood as a form of currying, which in turn leads to the duality of the long exact and coexact Puppe sequences.\n\nIn homological algebra, the relationship between currying and uncurrying is known as tensor-hom adjunction.  Here, an interesting twist arises: the Hom functor and the tensor product functor might not lift to an exact sequence; this leads to the definition of the Ext functor and the Tor functor.\n\nDomain theory \n\nIn order theory, that is, the theory of lattices of partially ordered sets, \\text{curry} is a continuous function when the lattice is given the Scott topology. (See theorems 1.2.13, 1.2.14) Scott-continuous functions were first investigated in the attempt to provide a semantics for lambda calculus (as ordinary set theory is inadequate to do this).  More generally, Scott-continuous functions are now studied in domain theory, which encompasses the study of denotational semantics of computer algorithms. Note that the Scott topology is quite different than many common topologies one might encounter in the category of topological spaces; the Scott topology is typically finer, and is not sober.\n\nThe notion of continuity makes its appearance in homotopy type theory, where, roughly speaking, two computer programs can be considered to be homotopic, i.e. compute the same results, if they can be \"continuously\" refactored from one to the other.\n\nLambda calculi \n\nIn theoretical computer science, currying provides a way to study functions with multiple arguments in very simple theoretical models, such as the lambda calculus, in which functions only take a single argument. Consider a function f(x,y) taking two arguments, and having the type (X \\times Y)\\to Z, which should be understood to mean that x must have the type X, y must have the type Y, and the function itself returns the type Z. The curried form of f is defined as\n\n\\text{curry}(f) = \\lambda x.(\\lambda y.(f(x,y)))\n\nwhere \\lambda is the abstractor of lambda calculus. Since curry takes, as input, functions with the type (X\\times Y)\\to Z, one concludes that the type of curry itself is\n\n\\text{curry}:((X \\times Y)\\to Z) \\to (X \\to (Y \\to Z))\n\nThe → operator is often considered right-associative, so the curried function type X \\to (Y \\to Z) is often written as X \\to Y \\to Z.  Conversely,  function application is considered to be left-associative, so that f(x, y) is equivalent to\n\n((\\text{curry}(f) \\; x) \\;y) = \\text{curry}(f) \\; x \\;y.\n\nThat is, the parenthesis are not required to disambiguate the order of the application.\n\nCurried functions may be used in any programming language that supports closures; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.\n\nType theory \n\nIn type theory, the general idea of a type system in computer science is formalized into a specific algebra of types. For example, when writing f \\colon X \\to Y , the intent is that X and Y are types, while the arrow \\to is a type constructor, specifically, the function type or arrow type.  Similarly, the Cartesian product X \\times Y of types is constructed by the product type constructor \\times.\n\nThe type-theoretical approach is expressed in programming languages such as ML and the languages derived from and inspired by it: CaML, Haskell and F#.\n\nThe type-theoretical approach provides a natural complement to the language of category theory, as discussed below. This is because categories, and specifically, monoidal categories, have an internal language, with simply-typed lambda calculus being the most prominent example of such a language.  It is important in this context, because it can be built from a single type constructor, the arrow type.  Currying then endows the language with a natural product type. The correspondence between objects in categories and types then allows programming languages to be re-interpreted as logics (via Curry–Howard correspondence), and as other types of mathematical systems, as explored further, below.\n\nLogic \n\nUnder the Curry–Howard correspondence, the existence of currying and uncurrying is equivalent to the logical theorem (A \\and B) \\to C \\Leftrightarrow A \\to (B \\to C), as tuples (product type) corresponds to conjunction in logic, and function type corresponds to implication.\n\nCategory theory \n\nThe above notions of currying and uncurrying find their most general, abstract statement in category theory. Currying is a universal property of an exponential object, and gives rise to an adjunction in cartesian closed categories. That is, there is a natural isomorphism between the morphisms from a binary product f \\colon (X \\times Y) \\to Z  and the morphisms to an exponential object g \\colon X \\to Z^Y . This generalizes to a broader result that the tensor product and the Hom functor are adjoint in closed monoidal categories. Currying is the statement that the tensor product and the internal Hom are adjoint functors; that is, there is a natural transformation: \n \\hom(A\\otimes B, C) \\cong \\hom(A, B\\Rightarrow C) .\nHere, hom is written lower case, to indicate that it is the internal hom functor, distinguishing it from the external (upper-case) Hom. For the category of sets, the two are the same. When the product is the cartesian product, then the internal hom B\\Rightarrow C becomes the exponential object C^B.\n\nThe setting of cartesian closed categories is sufficient for the discussion of classical logic; the more general setting of closed monoidal categories is suitable for quantum computation.Samson Abramsky and Bob Coecke, \"[https://arxiv.org/abs/quantph/0402130/ A Categorical Semantics for Quantum Protocols].\"\n\nThe difference between these two is that the product for cartesian categories (such as the category of sets, complete partial orders or Heyting algebras) is just the Cartesian product; it is interpreted as an ordered pair of items (or a list).  Simply typed lambda calculus is the internal language of cartesian closed categories; and it is for this reason that pairs and lists are the primary types in the type theory of LISP, scheme and many functional programming languages.\n\nBy contrast, the product for monoidal categories (such as Hilbert space and the vector spaces of functional analysis) is the tensor product. The internal language of such categories is linear logic, a form of quantum logic; the corresponding type system is the linear type system. Such categories are suitable for describing entangled quantum states, and, more generally, allow a vast generalization of the Curry–Howard correspondence to quantum mechanics, to cobordisms in algebraic topology, and to string theory.John C. Baez and Mike Stay, \"[http://math.ucr.edu/home/baez/rosetta/rose3.pdf Physics, Topology, Logic and Computation: A Rosetta Stone]\", (2009) [https://arxiv.org/abs/0903.0340/ ArXiv 0903.0340] in New Structures for Physics, ed. Bob Coecke, Lecture Notes in Physics vol. 813, Springer, Berlin, 2011, pp. 95-174.  The linear type system, and linear logic are useful for describing synchronization primitives, such as mutual exclusion locks, and the operation of vending machines.\n\nContrast with partial function application \n\nCurrying and partial function application are often conflated. (Reference is a blog). One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose arity is greater than two.\n\nGiven a function of type f \\colon (X \\times Y \\times Z) \\to N , currying produces \\text{curry}(f) \\colon X \\to (Y \\to (Z \\to N)) .  That is, while an evaluation of the first function might be represented as f(1, 2, 3), evaluation of the curried function would be represented as f_\\text{curried}(1)(2)(3), applying each argument in turn to a single-argument function returned by the previous invocation.  Note that after calling f_\\text{curried}(1), we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.\n\nIn contrast, partial function application refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.  Given the definition of f above, we might fix (or 'bind') the first argument, producing a function of type \\text{partial}(f) \\colon (Y \\times Z) \\to N.  Evaluation of this function might be represented as f_\\text{partial}(2, 3).  Note that the result of partial function application in this case is a function that takes two arguments.\n\nIntuitively, partial function application says \"if you fix the first argument of the function, you get a function of the remaining arguments\". For example, if function div stands for the division operation x/y, then div with the parameter x fixed at 1 (i.e., div 1) is another function: the same as the function inv that returns the multiplicative inverse of its argument, defined by inv(y) = 1/y.\n\nThe practical motivation for partial application is that very often the functions obtained by supplying some but not all of the arguments to a function are useful; for example, many languages have a function or operator similar to plus_one. Partial application makes it easy to define these functions, for example by creating a function that represents the addition operator with 1 bound as its first argument.\n\nPartial application can be seen as evaluating a curried function at a fixed point, e.g. given f \\colon (X \\times Y \\times Z) \\to N  and a \\in X then \\text{curry}(\\text{partial}(f)_a)(y)(z) \\text{curry}(f)(a)(y)(z)  or simply \\text{partial}(f)_a \n \\text{curry}_1(f)(a)  where \\text{curry}_1 curries f's first parameter. \n\nThus, partial application is reduced to a curried function at a fixed point. Further, a curried function at a fixed point is (trivially), a partial application.  Thus, by reduction, a curried function at a fixed point is a partial application.  For further evidence, note that, given any function f(x,y), a function g(y,x) may be defined such that g(y,x) = f(x,y).  Thus, any partial application may be reduced to a single curry operation.  As such, curry is more suitably defined as an operation which, in many theoretical cases, is often applied recursively, but which is theoretically indistinguishable (when considered as an operation) from a partial application.\n\nSo, a partial application can be defined as the objective result of a single application of the curry operator on some ordering of the inputs of some function. Currying. http://en.wikipedia.org/?curid=6600."
  }
}
