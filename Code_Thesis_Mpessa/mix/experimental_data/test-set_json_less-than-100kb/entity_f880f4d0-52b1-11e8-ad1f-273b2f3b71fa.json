{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=10931",
  "eid" : "f880f4d0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778496669,
  "textBody" : "A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.  It is an abstract machine that can be in exactly one of a finite number of states at any given time.  The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.\n\nThe behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.\n\nThe finite state machine has less computational power than some other models of computation such as the Turing machine.  The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM's memory is limited by the number of states it has.  FSMs are studied in the more general field of automata theory.\n\nExample: coin-operated turnstile \n\nAn example of a simple mechanism that can be modeled by a state machine is a turnstile.  A turnstile, used to control access to subways and amusement park rides, is a gate with three rotating arms at waist height, one across the entryway.  Initially the arms are locked, blocking the entry, preventing patrons from passing through.  Depositing a coin or token in a slot on the turnstile unlocks the arms, allowing a single customer to push through.  After the customer passes through, the arms are locked again until another coin is inserted.\n\nConsidered as a state machine, the turnstile has two possible states: Locked and Unlocked.  There are two possible inputs that affect its state: putting a coin in the slot (coin) and pushing the arm (push).  In the locked state, pushing on the arm has no effect; no matter how many times the input push is given, it stays in the locked state.  Putting a coin in – that is, giving the machine a coin input – shifts the state from Locked to Unlocked.  In the unlocked state, putting additional coins in has no effect; that is, giving additional coin inputs does not change the state.  However, a customer pushing through the arms, giving a push input, shifts the state back to Locked.\n\nThe turnstile state machine can be represented by a state transition table, showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input:\n:\nThe turnstile state machine can also be represented by a directed graph called a state diagram (above).  Each state is represented by a node (circle).  Edges (arrows) show the transitions from one state to another.  Each arrow is labeled with the input that triggers that transition.  An input that doesn't cause a change of state (such as a coin input in the Unlocked state) is represented by a circular arrow returning to the original state.  The arrow into the Locked node from the black dot indicates it is the initial state.\n\nConcepts and terminology \n\nA state is a description of the status of a system that is waiting to execute a transition. A transition is a set of actions to be executed when a condition is fulfilled or when an event is received.\nFor example, when using an audio system to listen to the radio (the system is in the \"radio\" state), receiving a \"next\" stimulus results in moving to the next station. When the system is in the \"CD\" state, the \"next\" stimulus results in moving to the next track. Identical stimuli trigger different actions depending on the current state.\n\nIn some finite-state machine representations, it is also possible to associate actions with a state:\n* an entry action: performed when entering the state, and\n* an exit action: performed when exiting the state.\n\nRepresentations \n\nState/Event table \n\nSeveral state transition table types are used. The most common representation is shown below: the combination of current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes. A FSM definition including the full actions information is possible using state tables (see also virtual finite-state machine).\n\nUML state machines \n\nThe Unified Modeling Language has a notation for describing state machines. UML state machines overcome the limitations of traditional finite state machines while retaining their main benefits. UML state machines introduce the new concepts of hierarchically nested states and orthogonal regions, while extending the notion of actions. UML state machines have the characteristics of both Mealy machines and Moore machines. They support actions that depend on both the state of the system and the triggering event, as in Mealy machines, as well as entry and exit actions, which are associated with states rather than transitions, as in Moore machines.\n\nSDL state machines \n\nThe Specification and Description Language is a standard from ITU that includes graphical symbols to describe actions in the transition:\n* send an event\n* receive an event\n* start a timer\n* cancel a timer\n* start another concurrent state machine\n* decision\nSDL embeds basic data types called \"Abstract Data Types\", an action language, and an execution semantic in order to make the finite state machine executable.\n\nOther state diagrams \n\nThere are a large number of variants to represent an FSM such as the one in figure 3.\n\nUsage \n\nIn addition to their use in modeling reactive systems presented here, finite state machines are significant in many different areas, including electrical engineering, linguistics, computer science, philosophy, biology, mathematics, and logic. Finite state machines are a class of automata studied in automata theory and the theory of computation.\nIn computer science, finite state machines are widely used in modeling of application behavior, design of hardware digital systems, software engineering, compilers, network protocols, and the study of computation and languages.\n\nClassification \n\nFinite state machines can be subdivided into transducers, acceptors, classifiers and sequencers.\n\nAcceptors and recognizers \n\nAcceptors, also called recognizers and sequence detectors, produce binary output, indicating whether or not the received input is accepted. Each state of an FSM is either \"accepting\" or \"not accepting\". Once all input has been received, if the current state is an accepting state, the input is accepted; otherwise it is rejected. As a rule, input is a sequence of symbols (characters); actions are not used. The example in figure 4 shows a finite state machine that accepts the string \"nice\". In this FSM, the only accepting state is state 7.\n\nA (possibly infinite) set of symbol sequences, aka. formal language, is called a regular language if there is some Finite State Machine that accepts exactly that set. For example, the set of binary strings with an even number of zeroes is a regular language (cf. Fig. 5), while the set of all strings whose length is a prime number is not.\n\nA machine could also be described as defining a language, that would contain every string accepted by the machine but none of the rejected ones; that language is \"accepted\" by the machine. By definition, the languages accepted by FSMs are the regular languages—; a language is regular if there is some FSM that accepts it.\n\nThe problem of determining the language accepted by a given finite state acceptor is an instance of the algebraic path problem—itself a generalization of the shortest path problem to graphs with edges weighted by the elements of an (arbitrary) semiring., p. 34\n\nThe start state can also be an accepting state, in which case the automaton accepts the empty string.\n\nAn example of an accepting state appears in Fig.5: a deterministic finite automaton (DFA) that detects whether the binary input string contains an even number of 0s.\n\nS1 (which is also the start state) indicates the state at which an even number of 0s has been input. S1 is therefore an accepting state. This machine will finish in an accept state, if the binary string contains an even number of 0s (including any binary string containing no 0s). Examples of strings accepted by this DFA are ε (the empty string), 1, 11, 11…, 00, 010, 1010, 10110, etc.\n\nClassifiers\n\nA classifier is a generalization of a finite state machine that, similar to an acceptor, produces a single output on termination but has more than two terminal states.\n\nTransducers \n\nTransducers generate output based on a given input and/or a state using actions. They are used for control applications and in the field of computational linguistics.\n\nIn control applications, two types are distinguished:\n\n;Moore machine: The FSM uses only entry actions, i.e., output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: \"command_open\" and \"command_close\", which trigger state changes. The entry action (E:) in state \"Opening\" starts a motor opening the door, the entry action in state \"Closing\" starts a motor in the other direction closing the door. States \"Opened\" and \"Closed\" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: \"door is open\" or \"door is closed\".\n\n;Mealy machine: The FSM also uses input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in figure 7 shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for virtual FSM but not for event-driven FSM). There are two input actions (I:): \"start motor to close the door if command_close arrives\" and \"start motor in the other direction to open the door if command_open arrives\". The \"opening\" and \"closing\" intermediate states are not shown.\n\nGenerators \n\nSequencers, or generators, are a subclass of the acceptor and transducer types that have a single-letter input alphabet. They produce only one sequence which can be seen as an output sequence of acceptor or transducer outputs.\n\nDeterminism \n\nA further distinction is between deterministic (DFA) and non-deterministic (NFA, GNFA) automata. In a deterministic automaton, every state has exactly one transition for each possible input. In a non-deterministic automaton, an input can lead to one, more than one, or no transition for a given state. The powerset construction algorithm can transform any nondeterministic automaton into a (usually more complex) deterministic automaton with identical functionality.\n\nA finite state machine with only one state is called a \"combinatorial FSM\". It only allows actions upon transition into a state. This concept is useful in cases where a number of finite state machines are required to work together, and when it is convenient to consider a purely combinatorial part as a form of FSM to suit the design tools.Brutscheck, M., Berger, S., Franke, M., Schwarzbacher, A., Becker, S.: Structural Division Procedure for Efficient IC Analysis. IET Irish\nSignals and Systems Conference, (ISSC 2008), pp.18-23. Galway, Ireland, 18–19 June 2008. [http://arrow.dit.ie/engschececon/2/]\n\nAlternative semantics \n\nThere are other sets of semantics available to represent state machines.  For example, there are tools for modeling and designing logic for embedded controllers.[http://www.csl.sri.com/users/tiwari/papers/stateflow.pdf Tiwari, A. (2002). Formal Semantics and Analysis Methods for Simulink Stateflow Models.] They combine hierarchical state machines (which usually have more than one current state), flow graphs, and truth tables into one language, resulting in a different formalism and set of semantics.    These charts, like Harel's original state machines,[http://www.fceia.unr.edu.ar/asist/harel01.pdf Harel, D. (1987). A Visual Formalism for Complex Systems. Science of Computer Programming, 231–274.] support hierarchically nested states, orthogonal regions, state actions, and transition actions.[http://drona.csa.iisc.ernet.in/~kanade/publications/symbolic_analysis_for_improving_simulation_coverage_of_simulink_stateflow_models.pdf Alur, R., Kanade, A., Ramesh, S., & Shashidhar, K. C. (2008). Symbolic analysis for improving simulation coverage of Simulink/Stateflow models. International Conference on Embedded Software (pp. 89–98). Atlanta, GA: ACM.]\n\nMathematical model \n\nIn accordance with the general classification, the following formal definitions are found:\n* A deterministic finite state machine or acceptor deterministic finite state machine is a quintuple (\\Sigma, S, s_0, \\delta, F), where:\n**\\Sigma is the input alphabet (a finite, non-empty set of symbols).\n**S is a finite, non-empty set of states.\n**s_0 is an initial state, an element of S.\n**\\delta is the state-transition function: \\delta: S \\times \\Sigma \\rightarrow S (in a nondeterministic finite automaton it would be \\delta: S \\times \\Sigma \\rightarrow \\mathcal{P}(S), i.e., \\delta would return a set of states).\n**F is the set of final states, a (possibly empty) subset of S.\n\nFor both deterministic and non-deterministic FSMs, it is conventional to allow \\delta to be a partial function, i.e. \\delta(q,x) does not have to be defined for every combination of q \\isin S and x \\isin \\Sigma. If an FSM M is in a state q, the next symbol is x and \\delta(q,x) is not defined, then M can announce an error (i.e. reject the input). This is useful in definitions of general state machines, but less useful when transforming the machine. Some algorithms in their default form may require total functions.\n\nA finite state machine has the same computational power as a Turing machine that is restricted such that its head may only perform \"read\" operations, and always has to move from left to right. That is, each formal language accepted by a finite state machine is accepted by such a kind of restricted Turing machine, and vice versa.\n\n* A finite state transducer is a sextuple (\\Sigma, \\Gamma, S, s_0, \\delta, \\omega), where:\n** \\Sigma is the input alphabet (a finite non-empty set of symbols).\n** \\Gamma is the output alphabet (a finite, non-empty set of symbols).\n** S is a finite, non-empty set of states.\n** s_0 is the initial state, an element of S. In a nondeterministic finite automaton, s_0 is a set of initial states.\n** \\delta is the state-transition function: \\delta: S \\times \\Sigma \\rightarrow S.\n** \\omega is the output function.\n\nIf the output function is a function of a state and input alphabet (\\omega: S \\times \\Sigma \\rightarrow \\Gamma) that definition corresponds to the Mealy model, and can be modelled as a Mealy machine. If the output function depends only on a state (\\omega: S \\rightarrow \\Gamma) that definition corresponds to the Moore model, and can be modelled as a Moore machine. A finite-state machine with no output function at all is known as a semiautomaton or transition system.\n\nIf we disregard the first output symbol of a Moore machine, \\omega (s_0), then it can be readily converted to an output-equivalent Mealy machine by setting the output function of every Mealy transition (i.e. labeling every edge) with the output symbol given of the destination Moore state. The converse transformation is less straightforward because a Mealy machine state may have different output labels on its incoming transitions (edges). Every such state needs to be split in multiple Moore machine states, one for every incident output symbol.\n\nOptimization \n\nOptimizing an FSM means finding a machine with the minimum number of states that performs the same function. The fastest known algorithm doing this is the Hopcroft minimization algorithm. Other techniques include using an implication table, or the Moore reduction procedure. Additionally, acyclic FSAs can be minimized in linear time.\n\nImplementation \n\nHardware applications \n\nIn a digital circuit, an FSM may be built using a programmable logic device, a programmable logic controller, logic gates and flip flops or relays. More specifically, a hardware implementation requires a register to store state variables, a block of combinational logic that determines the state transition, and a second block of combinational logic that determines the output of an FSM. One of the classic hardware implementations is the Richards controller.\n\nIn a Medvedev machine, the output is directly connected to the state flip-flops minimizing the time delay between flip-flops and output.[http://users.etech.haw-hamburg.de/users/Schwarz/En/Lecture/Ds/Notes/DigSys1.pdf Slides], Synchronous Finite State Machines; Design and Behaviour, University of Applied Sciences Hamburg, p.18\n\nThrough state encoding for low power state machines may be optimized to minimize power consumption.\n\nSoftware applications \n\nThe following concepts are commonly used to build software applications with finite state machines:\n*Automata-based programming\n*Event-driven finite-state machine\n*Virtual finite-state machine\n*State design pattern\n\nFinite state machines and compilers \n\nFinite automata are often used in the frontend of programming language compilers. Such a frontend may comprise several finite state machines that implement a lexical analyzer and a parser.\nStarting from a sequence of characters, the lexical analyzer builds a sequence of language tokens (such as reserved words, literals, and identifiers) from which the parser builds a syntax tree. The lexical analyzer and the parser handle the regular and context-free parts of the programming language's grammar.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Finite-state machine" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=10931" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation.  It is an abstract machine that can be in exactly one of a finite number of states at any given time.  The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition.\n\nThe behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.\n\nThe finite state machine has less computational power than some other models of computation such as the Turing machine.  The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM's memory is limited by the number of states it has.  FSMs are studied in the more general field of automata theory.\n\nExample: coin-operated turnstile \n\nAn example of a simple mechanism that can be modeled by a state machine is a turnstile.  A turnstile, used to control access to subways and amusement park rides, is a gate with three rotating arms at waist height, one across the entryway.  Initially the arms are locked, blocking the entry, preventing patrons from passing through.  Depositing a coin or token in a slot on the turnstile unlocks the arms, allowing a single customer to push through.  After the customer passes through, the arms are locked again until another coin is inserted.\n\nConsidered as a state machine, the turnstile has two possible states: Locked and Unlocked.  There are two possible inputs that affect its state: putting a coin in the slot (coin) and pushing the arm (push).  In the locked state, pushing on the arm has no effect; no matter how many times the input push is given, it stays in the locked state.  Putting a coin in – that is, giving the machine a coin input – shifts the state from Locked to Unlocked.  In the unlocked state, putting additional coins in has no effect; that is, giving additional coin inputs does not change the state.  However, a customer pushing through the arms, giving a push input, shifts the state back to Locked.\n\nThe turnstile state machine can be represented by a state transition table, showing for each possible state, the transitions between them (based upon the inputs given to the machine) and the outputs resulting from each input:\n:\nThe turnstile state machine can also be represented by a directed graph called a state diagram (above).  Each state is represented by a node (circle).  Edges (arrows) show the transitions from one state to another.  Each arrow is labeled with the input that triggers that transition.  An input that doesn't cause a change of state (such as a coin input in the Unlocked state) is represented by a circular arrow returning to the original state.  The arrow into the Locked node from the black dot indicates it is the initial state.\n\nConcepts and terminology \n\nA state is a description of the status of a system that is waiting to execute a transition. A transition is a set of actions to be executed when a condition is fulfilled or when an event is received.\nFor example, when using an audio system to listen to the radio (the system is in the \"radio\" state), receiving a \"next\" stimulus results in moving to the next station. When the system is in the \"CD\" state, the \"next\" stimulus results in moving to the next track. Identical stimuli trigger different actions depending on the current state.\n\nIn some finite-state machine representations, it is also possible to associate actions with a state:\n* an entry action: performed when entering the state, and\n* an exit action: performed when exiting the state.\n\nRepresentations \n\nState/Event table \n\nSeveral state transition table types are used. The most common representation is shown below: the combination of current state (e.g. B) and input (e.g. Y) shows the next state (e.g. C). The complete action's information is not directly described in the table and can only be added using footnotes. A FSM definition including the full actions information is possible using state tables (see also virtual finite-state machine).\n\nUML state machines \n\nThe Unified Modeling Language has a notation for describing state machines. UML state machines overcome the limitations of traditional finite state machines while retaining their main benefits. UML state machines introduce the new concepts of hierarchically nested states and orthogonal regions, while extending the notion of actions. UML state machines have the characteristics of both Mealy machines and Moore machines. They support actions that depend on both the state of the system and the triggering event, as in Mealy machines, as well as entry and exit actions, which are associated with states rather than transitions, as in Moore machines.\n\nSDL state machines \n\nThe Specification and Description Language is a standard from ITU that includes graphical symbols to describe actions in the transition:\n* send an event\n* receive an event\n* start a timer\n* cancel a timer\n* start another concurrent state machine\n* decision\nSDL embeds basic data types called \"Abstract Data Types\", an action language, and an execution semantic in order to make the finite state machine executable.\n\nOther state diagrams \n\nThere are a large number of variants to represent an FSM such as the one in figure 3.\n\nUsage \n\nIn addition to their use in modeling reactive systems presented here, finite state machines are significant in many different areas, including electrical engineering, linguistics, computer science, philosophy, biology, mathematics, and logic. Finite state machines are a class of automata studied in automata theory and the theory of computation.\nIn computer science, finite state machines are widely used in modeling of application behavior, design of hardware digital systems, software engineering, compilers, network protocols, and the study of computation and languages.\n\nClassification \n\nFinite state machines can be subdivided into transducers, acceptors, classifiers and sequencers.\n\nAcceptors and recognizers \n\nAcceptors, also called recognizers and sequence detectors, produce binary output, indicating whether or not the received input is accepted. Each state of an FSM is either \"accepting\" or \"not accepting\". Once all input has been received, if the current state is an accepting state, the input is accepted; otherwise it is rejected. As a rule, input is a sequence of symbols (characters); actions are not used. The example in figure 4 shows a finite state machine that accepts the string \"nice\". In this FSM, the only accepting state is state 7.\n\nA (possibly infinite) set of symbol sequences, aka. formal language, is called a regular language if there is some Finite State Machine that accepts exactly that set. For example, the set of binary strings with an even number of zeroes is a regular language (cf. Fig. 5), while the set of all strings whose length is a prime number is not.\n\nA machine could also be described as defining a language, that would contain every string accepted by the machine but none of the rejected ones; that language is \"accepted\" by the machine. By definition, the languages accepted by FSMs are the regular languages—; a language is regular if there is some FSM that accepts it.\n\nThe problem of determining the language accepted by a given finite state acceptor is an instance of the algebraic path problem—itself a generalization of the shortest path problem to graphs with edges weighted by the elements of an (arbitrary) semiring., p. 34\n\nThe start state can also be an accepting state, in which case the automaton accepts the empty string.\n\nAn example of an accepting state appears in Fig.5: a deterministic finite automaton (DFA) that detects whether the binary input string contains an even number of 0s.\n\nS1 (which is also the start state) indicates the state at which an even number of 0s has been input. S1 is therefore an accepting state. This machine will finish in an accept state, if the binary string contains an even number of 0s (including any binary string containing no 0s). Examples of strings accepted by this DFA are ε (the empty string), 1, 11, 11…, 00, 010, 1010, 10110, etc.\n\nClassifiers\n\nA classifier is a generalization of a finite state machine that, similar to an acceptor, produces a single output on termination but has more than two terminal states.\n\nTransducers \n\nTransducers generate output based on a given input and/or a state using actions. They are used for control applications and in the field of computational linguistics.\n\nIn control applications, two types are distinguished:\n\n;Moore machine: The FSM uses only entry actions, i.e., output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. Consider an elevator door. The state machine recognizes two commands: \"command_open\" and \"command_close\", which trigger state changes. The entry action (E:) in state \"Opening\" starts a motor opening the door, the entry action in state \"Closing\" starts a motor in the other direction closing the door. States \"Opened\" and \"Closed\" stop the motor when fully opened or closed. They signal to the outside world (e.g., to other state machines) the situation: \"door is open\" or \"door is closed\".\n\n;Mealy machine: The FSM also uses input actions, i.e., output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in figure 7 shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work, e.g., for virtual FSM but not for event-driven FSM). There are two input actions (I:): \"start motor to close the door if command_close arrives\" and \"start motor in the other direction to open the door if command_open arrives\". The \"opening\" and \"closing\" intermediate states are not shown.\n\nGenerators \n\nSequencers, or generators, are a subclass of the acceptor and transducer types that have a single-letter input alphabet. They produce only one sequence which can be seen as an output sequence of acceptor or transducer outputs.\n\nDeterminism \n\nA further distinction is between deterministic (DFA) and non-deterministic (NFA, GNFA) automata. In a deterministic automaton, every state has exactly one transition for each possible input. In a non-deterministic automaton, an input can lead to one, more than one, or no transition for a given state. The powerset construction algorithm can transform any nondeterministic automaton into a (usually more complex) deterministic automaton with identical functionality.\n\nA finite state machine with only one state is called a \"combinatorial FSM\". It only allows actions upon transition into a state. This concept is useful in cases where a number of finite state machines are required to work together, and when it is convenient to consider a purely combinatorial part as a form of FSM to suit the design tools.Brutscheck, M., Berger, S., Franke, M., Schwarzbacher, A., Becker, S.: Structural Division Procedure for Efficient IC Analysis. IET Irish\nSignals and Systems Conference, (ISSC 2008), pp.18-23. Galway, Ireland, 18–19 June 2008. [http://arrow.dit.ie/engschececon/2/]\n\nAlternative semantics \n\nThere are other sets of semantics available to represent state machines.  For example, there are tools for modeling and designing logic for embedded controllers.[http://www.csl.sri.com/users/tiwari/papers/stateflow.pdf Tiwari, A. (2002). Formal Semantics and Analysis Methods for Simulink Stateflow Models.] They combine hierarchical state machines (which usually have more than one current state), flow graphs, and truth tables into one language, resulting in a different formalism and set of semantics.    These charts, like Harel's original state machines,[http://www.fceia.unr.edu.ar/asist/harel01.pdf Harel, D. (1987). A Visual Formalism for Complex Systems. Science of Computer Programming, 231–274.] support hierarchically nested states, orthogonal regions, state actions, and transition actions.[http://drona.csa.iisc.ernet.in/~kanade/publications/symbolic_analysis_for_improving_simulation_coverage_of_simulink_stateflow_models.pdf Alur, R., Kanade, A., Ramesh, S., & Shashidhar, K. C. (2008). Symbolic analysis for improving simulation coverage of Simulink/Stateflow models. International Conference on Embedded Software (pp. 89–98). Atlanta, GA: ACM.]\n\nMathematical model \n\nIn accordance with the general classification, the following formal definitions are found:\n* A deterministic finite state machine or acceptor deterministic finite state machine is a quintuple (\\Sigma, S, s_0, \\delta, F), where:\n**\\Sigma is the input alphabet (a finite, non-empty set of symbols).\n**S is a finite, non-empty set of states.\n**s_0 is an initial state, an element of S.\n**\\delta is the state-transition function: \\delta: S \\times \\Sigma \\rightarrow S (in a nondeterministic finite automaton it would be \\delta: S \\times \\Sigma \\rightarrow \\mathcal{P}(S), i.e., \\delta would return a set of states).\n**F is the set of final states, a (possibly empty) subset of S.\n\nFor both deterministic and non-deterministic FSMs, it is conventional to allow \\delta to be a partial function, i.e. \\delta(q,x) does not have to be defined for every combination of q \\isin S and x \\isin \\Sigma. If an FSM M is in a state q, the next symbol is x and \\delta(q,x) is not defined, then M can announce an error (i.e. reject the input). This is useful in definitions of general state machines, but less useful when transforming the machine. Some algorithms in their default form may require total functions.\n\nA finite state machine has the same computational power as a Turing machine that is restricted such that its head may only perform \"read\" operations, and always has to move from left to right. That is, each formal language accepted by a finite state machine is accepted by such a kind of restricted Turing machine, and vice versa.\n\n* A finite state transducer is a sextuple (\\Sigma, \\Gamma, S, s_0, \\delta, \\omega), where:\n** \\Sigma is the input alphabet (a finite non-empty set of symbols).\n** \\Gamma is the output alphabet (a finite, non-empty set of symbols).\n** S is a finite, non-empty set of states.\n** s_0 is the initial state, an element of S. In a nondeterministic finite automaton, s_0 is a set of initial states.\n** \\delta is the state-transition function: \\delta: S \\times \\Sigma \\rightarrow S.\n** \\omega is the output function.\n\nIf the output function is a function of a state and input alphabet (\\omega: S \\times \\Sigma \\rightarrow \\Gamma) that definition corresponds to the Mealy model, and can be modelled as a Mealy machine. If the output function depends only on a state (\\omega: S \\rightarrow \\Gamma) that definition corresponds to the Moore model, and can be modelled as a Moore machine. A finite-state machine with no output function at all is known as a semiautomaton or transition system.\n\nIf we disregard the first output symbol of a Moore machine, \\omega (s_0), then it can be readily converted to an output-equivalent Mealy machine by setting the output function of every Mealy transition (i.e. labeling every edge) with the output symbol given of the destination Moore state. The converse transformation is less straightforward because a Mealy machine state may have different output labels on its incoming transitions (edges). Every such state needs to be split in multiple Moore machine states, one for every incident output symbol.\n\nOptimization \n\nOptimizing an FSM means finding a machine with the minimum number of states that performs the same function. The fastest known algorithm doing this is the Hopcroft minimization algorithm. Other techniques include using an implication table, or the Moore reduction procedure. Additionally, acyclic FSAs can be minimized in linear time.\n\nImplementation \n\nHardware applications \n\nIn a digital circuit, an FSM may be built using a programmable logic device, a programmable logic controller, logic gates and flip flops or relays. More specifically, a hardware implementation requires a register to store state variables, a block of combinational logic that determines the state transition, and a second block of combinational logic that determines the output of an FSM. One of the classic hardware implementations is the Richards controller.\n\nIn a Medvedev machine, the output is directly connected to the state flip-flops minimizing the time delay between flip-flops and output.[http://users.etech.haw-hamburg.de/users/Schwarz/En/Lecture/Ds/Notes/DigSys1.pdf Slides], Synchronous Finite State Machines; Design and Behaviour, University of Applied Sciences Hamburg, p.18\n\nThrough state encoding for low power state machines may be optimized to minimize power consumption.\n\nSoftware applications \n\nThe following concepts are commonly used to build software applications with finite state machines:\n*Automata-based programming\n*Event-driven finite-state machine\n*Virtual finite-state machine\n*State design pattern\n\nFinite state machines and compilers \n\nFinite automata are often used in the frontend of programming language compilers. Such a frontend may comprise several finite state machines that implement a lexical analyzer and a parser.\nStarting from a sequence of characters, the lexical analyzer builds a sequence of language tokens (such as reserved words, literals, and identifiers) from which the parser builds a syntax tree. The lexical analyzer and the parser handle the regular and context-free parts of the programming language's grammar. Finite-state machine. http://en.wikipedia.org/?curid=10931."
  }
}
