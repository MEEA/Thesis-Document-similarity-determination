{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=19726",
  "eid" : "3d57f130-52b2-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778612163,
  "textBody" : "Mercury is a functional logic programming language made for real-world uses. The first version was developed at the University of Melbourne, Computer Science department, by Fergus Henderson, Thomas Conway, and Zoltan Somogyi, under Somogyi's supervision, and released on April 8, 1995.\n\nMercury is a purely declarative logic programming language. It is related to both Prolog and Haskell.[http://www.mercurylang.org/about/motivation.html The Mercury Project - Motivation] It features a strong, static, polymorphic type system, and a strong mode and determinism system.\n\nThe official implementation, the Melbourne Mercury Compiler, is available for most Unix and Unix-like platforms, including Linux, macOS, and for Windows (32bits only).\n\nOverview \n\nMercury is based on the logic programming language Prolog. It has the same syntax and the same basic concepts such as the SLD resolution algorithm. It can be viewed as a pure subset of Prolog with strong types and modes. As such, it is often compared to its predecessor in features and run-time efficiency.\n\nThe language is designed using software engineering principles. Unlike the original implementations of Prolog, it has a separate compilation phase, rather than being directly interpreted. This allows a much wider range of errors to be detected before running a program. It features a strict static type and mode system and a module system.\n\nBy using information obtained at compile time (such as type and mode), programs written in Mercury typically perform significantly faster than equivalent programs written in Prolog.[http://www.mercurylang.org/about/benchmarks.html The Mercury Project - Benchmarks] Its authors claim that Mercury is the fastest logic language in the world, by a wide margin.\n\nMercury is a purely declarative language, unlike Prolog, since it lacks extra-logical Prolog statements such as cut and imperative input/output (I/O). This enables advanced static program analysis and program optimization, including compile-time garbage collection, but it can make certain programming constructs (such as a switch over a number of options, with a default) harder to express. (While Mercury does allow impure functionality, this serves mainly as a way to call foreign language code. All impure code must be marked explicitly.) Operations which would typically be impure (such as input/output) are expressed using pure constructs in Mercury using linear types, by threading a dummy world value through all relevant code.\n\nNotable programs written in Mercury include the Mercury compiler and the Prince XML formatter.  Software company Mission Critical IT has also been using Mercury since 2000 to develop enterprise applications and its Ontology-Driven software development platform, ODASE.[http://www.missioncriticalit.com/ Mission Critical IT]\n\nBack-ends\n\nMercury has several back-ends, which enable compiling Mercury code into several languages, including:\n\nProduction level\n\n*Low-level C for GNU Compiler Collection (GCC), the original Mercury back-end\n*High-level C\n*Java\n*C#\n*Erlang\n\nPast\n\n*Assembly language via the GCC back-end\n* Aditi, a deductive database system also developed at the University of Melbourne. Mercury-0.12.2 is the last version to support Aditi.\n*Common Intermediate Language (CIL) for the .NET Framework\n\nMercury also features a foreign language interface, allowing code in other languages (depending on the chosen back-end) to be linked with Mercury code. The following foreign languages are possible:\n\nOther languages can then be interfaced to by calling them from these languages.  However, this means that foreign language code may need to be written several times for the different backends, otherwise portability between backends will be lost.\n\nThe most commonly used back-end is the original low-level C back-end.\n\nExamples \n\nHello World:\n\n :- module hello.\n :- interface.\n :- import_module io.\n :- pred main(io::di, io::uo) is det.\n\n :- implementation.\n main(!IO) :-\n \tio.write_string(\"Hello, World!\\n\", !IO).\n\nCalculating the 10th Fibonacci number (in the most obvious way):Adapted from [http://www.mercurylang.org/documentation/papers/book.pdf Ralph Becket's Mercury tutorial]\n\n :- module fib.\n :- interface.\n :- import_module io.\n :- pred main(io::di, io::uo) is det.\n \n :- implementation.\n :- import_module int.\n\n :- func fib(int) = int.\n fib(N) (if N \n\nRelease schedule\n\nReleases are named according to the year and month of release. The current stable release is 14.01.1 (September 2014). Prior releases were numbered 0.12, 0.13, etc., and the time between stable releases can be as long as 3 years.\n\nThere is often also a snapshot release of the day (ROTD) consisting of the latest features and bug fixes added to the last stable release.\n\nIDE and editor support\n\n* Developers provides [https://github.com/Mercury-Language/mercury/tree/master/vim support] for Vim\n* [https://github.com/flycheck/flycheck-mercury Flycheck library] for Emacs\n* A [http://kai.mercury.mind-era.com/ plugin] is available for the Eclipse IDE\n* A [http://opcode.cc/projects_mercury_ide.en.html plugin] is available for the NetBeans IDE",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Mercury (programming language)" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=19726" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "Mercury is a functional logic programming language made for real-world uses. The first version was developed at the University of Melbourne, Computer Science department, by Fergus Henderson, Thomas Conway, and Zoltan Somogyi, under Somogyi's supervision, and released on April 8, 1995.\n\nMercury is a purely declarative logic programming language. It is related to both Prolog and Haskell.[http://www.mercurylang.org/about/motivation.html The Mercury Project - Motivation] It features a strong, static, polymorphic type system, and a strong mode and determinism system.\n\nThe official implementation, the Melbourne Mercury Compiler, is available for most Unix and Unix-like platforms, including Linux, macOS, and for Windows (32bits only).\n\nOverview \n\nMercury is based on the logic programming language Prolog. It has the same syntax and the same basic concepts such as the SLD resolution algorithm. It can be viewed as a pure subset of Prolog with strong types and modes. As such, it is often compared to its predecessor in features and run-time efficiency.\n\nThe language is designed using software engineering principles. Unlike the original implementations of Prolog, it has a separate compilation phase, rather than being directly interpreted. This allows a much wider range of errors to be detected before running a program. It features a strict static type and mode system and a module system.\n\nBy using information obtained at compile time (such as type and mode), programs written in Mercury typically perform significantly faster than equivalent programs written in Prolog.[http://www.mercurylang.org/about/benchmarks.html The Mercury Project - Benchmarks] Its authors claim that Mercury is the fastest logic language in the world, by a wide margin.\n\nMercury is a purely declarative language, unlike Prolog, since it lacks extra-logical Prolog statements such as cut and imperative input/output (I/O). This enables advanced static program analysis and program optimization, including compile-time garbage collection, but it can make certain programming constructs (such as a switch over a number of options, with a default) harder to express. (While Mercury does allow impure functionality, this serves mainly as a way to call foreign language code. All impure code must be marked explicitly.) Operations which would typically be impure (such as input/output) are expressed using pure constructs in Mercury using linear types, by threading a dummy world value through all relevant code.\n\nNotable programs written in Mercury include the Mercury compiler and the Prince XML formatter.  Software company Mission Critical IT has also been using Mercury since 2000 to develop enterprise applications and its Ontology-Driven software development platform, ODASE.[http://www.missioncriticalit.com/ Mission Critical IT]\n\nBack-ends\n\nMercury has several back-ends, which enable compiling Mercury code into several languages, including:\n\nProduction level\n\n*Low-level C for GNU Compiler Collection (GCC), the original Mercury back-end\n*High-level C\n*Java\n*C#\n*Erlang\n\nPast\n\n*Assembly language via the GCC back-end\n* Aditi, a deductive database system also developed at the University of Melbourne. Mercury-0.12.2 is the last version to support Aditi.\n*Common Intermediate Language (CIL) for the .NET Framework\n\nMercury also features a foreign language interface, allowing code in other languages (depending on the chosen back-end) to be linked with Mercury code. The following foreign languages are possible:\n\nOther languages can then be interfaced to by calling them from these languages.  However, this means that foreign language code may need to be written several times for the different backends, otherwise portability between backends will be lost.\n\nThe most commonly used back-end is the original low-level C back-end.\n\nExamples \n\nHello World:\n\n :- module hello.\n :- interface.\n :- import_module io.\n :- pred main(io::di, io::uo) is det.\n\n :- implementation.\n main(!IO) :-\n \tio.write_string(\"Hello, World!\\n\", !IO).\n\nCalculating the 10th Fibonacci number (in the most obvious way):Adapted from [http://www.mercurylang.org/documentation/papers/book.pdf Ralph Becket's Mercury tutorial]\n\n :- module fib.\n :- interface.\n :- import_module io.\n :- pred main(io::di, io::uo) is det.\n \n :- implementation.\n :- import_module int.\n\n :- func fib(int) = int.\n fib(N) (if N \n\nRelease schedule\n\nReleases are named according to the year and month of release. The current stable release is 14.01.1 (September 2014). Prior releases were numbered 0.12, 0.13, etc., and the time between stable releases can be as long as 3 years.\n\nThere is often also a snapshot release of the day (ROTD) consisting of the latest features and bug fixes added to the last stable release.\n\nIDE and editor support\n\n* Developers provides [https://github.com/Mercury-Language/mercury/tree/master/vim support] for Vim\n* [https://github.com/flycheck/flycheck-mercury Flycheck library] for Emacs\n* A [http://kai.mercury.mind-era.com/ plugin] is available for the Eclipse IDE\n* A [http://opcode.cc/projects_mercury_ide.en.html plugin] is available for the NetBeans IDE. Mercury (programming language). http://en.wikipedia.org/?curid=19726."
  }
}
