{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=4266",
  "eid" : "cc585470-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778422583,
  "textBody" : "In computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array; if they are unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. If the search ends with the remaining half being empty, the target is not in the array.\n\nBinary search runs in at worst logarithmic time, making  comparisons, where  is the number of elements in the array, the  is Big O notation, and  is the logarithm. Binary search takes constant () space, meaning that the space taken by the algorithm is the same for any number of elements in the array. Although specialized data structures designed for fast searching—such as hash tables—can be searched more efficiently, binary search applies to a wider range of problems.\n\nAlthough the idea is simple, implementing binary search correctly requires attention to some subtleties about its exit conditions and midpoint calculation.\n\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays, efficiently solving a series of search problems in computational geometry and numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.\n\nAlgorithm \n\nBinary search works on sorted arrays. Binary search begins by comparing the middle element of the array with the target value. If the target value matches the middle element, its position in the array is returned. If the target value is less than or greater than the middle element, the search continues in the lower or upper half of the array, respectively, eliminating the other half from consideration.\n\nProcedure\n\nGiven an array A of n elements with values or records A0, A1, ..., An−1, sorted such that A0 ≤ A1 ≤ ... ≤ An−1, and target value T, the following subroutine uses binary search to find the index of T in A.\n# Set L to 0 and R to n − 1.\n# If L > R, the search terminates as unsuccessful.\n# Set m (the position of the middle element) to the floor (the largest previous integer) of (L + R) / 2.\n# If Am m > T, set R to m − 1 and go to step 2.\n# Now Am = T, the search is done; return m.\n\nThis iterative procedure keeps track of the search boundaries with the two variables. Some implementations may check whether the middle element is equal to the target at the end of the procedure. This results in a faster comparison loop, but requires one more iteration on average. Procedure is described at p. 214 (§43), titled \"Program for Binary Search\".\n\nApproximate matches\n\nThe above procedure only performs exact matches, finding the position of a target value. However, due to the ordered nature of sorted arrays, it is trivial to extend binary search to perform approximate matches. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\n* Rank queries can be performed using a modified version of binary search. By returning m on a successful search, and L on an unsuccessful search, the number of elements less than the target value is returned instead.\n* Predecessor and successor queries can be performed with rank queries. Once the rank of the target value is known, its predecessor is the element at the position given by its rank (as it is the largest element that is smaller than the target value). Its successor is the element after it (if it is present in the array) or at the next position after the predecessor (otherwise). The nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\n* Range queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains keys matching those endpoints.\n\nPerformance\n\nThe performance of binary search can be analyzed by reducing the procedure to a binary comparison tree, where the root node is the middle element of the array. The middle element of the lower half is the left child node of the root and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. This model represents binary search; starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration, representing the successive elimination of elements.\n\nThe worst case is \\lfloor \\log_2 (n) + 1 \\rfloor iterations of the comparison loop, where the \\lfloor \\rfloor notation denotes the floor function that rounds its argument to the next-smallest integer and \\log_2 is the binary logarithm. The worst case is reached when the search reaches the deepest level of the tree, equivalent to a binary search that has reduced to one element and, in each iteration, always eliminates the smaller subarray out of the two if they are not of equal size.\n\nOn average, assuming that each element is equally likely to be searched, the procedure will most likely find the target value the second-deepest level of the tree. This is equivalent to a binary search that completes one iteration before the worst case, reached after \\log_2(n + 1) - 1 iterations. However, the tree may be unbalanced, with the deepest level partially filled. Equivalently, the array may not be divided exactly in half by the search in some iterations, half of the time resulting in the smaller subarray being eliminated. This cannot occur if the size of the array is one less than a power of two, but otherwise the actual number of average iterations is slightly higher, at \\lfloor \\log_2 (n + 1) \\rfloor - \\frac{\\lfloor \\log_2 (n + 1) \\rfloor({\\lfloor \\log_2 (n + 1) \\rfloor} - 1) - 1}{n} iterations. In the best case, where the target value is the middle element of the array, its position is returned after one iteration.\n\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. This is because the comparison tree representing binary search has the fewest levels possible as each level is filled completely with nodes if there are enough. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is affected. This problem is solved by binary search, as dividing the array in half ensures that the size of both subarrays are as similar as possible.\n\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Again assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search, eliminating on average half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers, while guaranteeing that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only \\lfloor \\log_2 (n) + 1 \\rfloor times in the worst case, the slight increase in comparison loop efficiency does not compensate for the extra iteration for all but enormous n.  gives a value of 2^{66} (more than 73 quintillion)Sloane, Neil. [https://oeis.org/A000079/b000079.txt Table of n, 2n for n \n 0..1000]. Part of OEIS [https://oeis.org/A000079 A000079]. Retrieved 30 April 2016. elements for this variation to be faster.\n\nFractional cascading can be used to speed up searches of the same value in multiple arrays. Where k is the number of arrays, searching each array for the target value takes O(k \\log n) time; fractional cascading reduces this to O(k + \\log n).\n\nBinary search versus other schemes \n\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking O(n) time for each such operation, and complicating memory use. Other data structures support much more efficient insertion and deletion, and also fast exact matching. However, binary search applies to a wide range of search problems, usually solving them in O(\\log n) time regardless of the type or structure of the values themselves.\n\nHashing \n\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records; most implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. In addition, all operations possible on a sorted array can be performed—such as finding the smallest and largest key and performing range searches. \n\nTrees \n\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\n\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This applies even to balanced binary search trees, binary search trees that balance their own nodes—as they rarely produce optimally-balanced trees—but to a lesser extent. Although unlikely, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching n comparisons. Binary search trees take more space than sorted arrays.\n\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can effectively be structured in filesystems. The B-tree generalizes this method of tree organization; B-trees are frequently used to organize long-term storage such as databases and filesystems.\n\nLinear search \n\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short. If the array must first be sorted, that cost must be amortized over any searches. Sorting the array also enables efficient approximate matches and other operations.\n\nSet membership algorithms\n\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership.  A bit array is the simplest, useful when the range of keys is limited; it is very fast, requiring only O(1) time.  The Judy1 type of Judy array handles 64-bit keys efficiently.\n\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with k hash functions, membership queries require only O(k) time. However, Bloom filters suffer from false positives.\n\nOther data structures \n\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. However, while these operations can always be done at least efficiently on a sorted array regardless of the keys, such data structures are usually only faster because they exploit the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.\n\nVariations\n\nUniform binary search\n\nUniform binary search stores, instead of the lower and upper bounds, the index of the middle element and the change in the middle element from the current iteration to the next iteration. Each step reduces the change by about half. For example, if the array to be searched was , the middle element would be . Uniform binary search works on the basis that the difference between the index of middle element of the array and the left and right subarrays is the same. In this case, the middle element of the left subarray () is  and the middle element of the right subarray () is . Uniform binary search would store the value of  as both indices differ from  by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the middle element. The main advantage of uniform binary search is that the procedure can store a table of the differences between indices for each iteration of the procedure, which may improve the algorithm's performance on some systems.\n\nExponential search\n\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes \\lfloor \\log_2 x + 1\\rfloor iterations of the exponential search and at most \\lfloor \\log_2 x \\rfloor iterations of the binary search, where x is the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.\n\nInterpolation search\n\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. This is only possible if the array elements are numbers. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array. When the distribution of the array elements is uniform or near uniform, it makes O(\\log \\log n) comparisons.\n\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Although its time complexity grows more slowly than binary search, this only compensates for the extra computation for large arrays.\n\nFractional cascading \n\nFractional cascading is a technique that speeds up binary searches for the same element for both exact and approximate matching in \"catalogs\" (arrays of sorted elements) associated with vertices in graphs. Searching each catalog separately requires O(k \\log n) time, where k is the number of catalogs. Fractional cascading reduces this to O(k + \\log n) by storing specific information in each catalog about other catalogs.\n\nFractional cascading was originally developed to efficiently solve various computational geometry problems, but it also has been applied elsewhere, in domains such as data mining and Internet Protocol routing.\n\nFibonacci search \n\nFibonacci search is a method similar to binary search that successively shortens the interval in which the maximum of a unimodal function lies. Given a finite interval, a unimodal function, and the maximum length of the resulting interval, Fibonacci search finds a Fibonacci number such that if the interval is divided equally into that many subintervals, the subintervals would be shorter than the maximum length. After dividing the interval, it eliminates the subintervals in which the maximum cannot lie until one or more contiguous subintervals remain. \n\nNoisy binary search \n\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, which Alfréd Rényi introduced in 1961.\n\nQuantum binary search \n\nClassical computers are bounded to the worst case of exactly \\lfloor \\log_2 n + 1 \\rfloor iterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of \\log_2 n queries (representing iterations of the classical procedure), but the constant factor is less than one, providing for faster performance on quantum computers.  proved that any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least \\frac{1}{\\pi}(\\ln n - 1) \\approx 0.220 \\log_2 n queries in the worst case, where \\ln is the natural logarithm.  provided an exact quantum binary search procedure that runs in 4 \\log_{605} n \\approx 0.433 \\log_2 n queries in the worst case.\n\nHistory \n\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, the first ever set of lectures regarding any computer-related topic. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was presented to Donald Knuth in 1971 by A. K. Chandra of Stanford University and published in Knuth's The Art of Computer Programming. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.\n\nImplementation issues\n\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky ... — Donald Knuth\n\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, and another study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\n\nIn a practical implementation, the variables used to represent the indices will often be of fixed size, and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as (L + R) / 2, then the value of L + R may exceed the range of integers of the data type used to store the midpoint, even if L and R are within the range. If L and R are nonnegative, this can be avoided by calculating the midpoint as L + (R − L) / 2.\n\nIf the target value is greater than the greatest value in the array, and the last index of the array is the maximum representable value of L, the value of L will eventually become too large and overflow. A similar problem will occur if the target value is smaller than the least value in the array and the first index of the array is the smallest representable value of R. In particular, this means that R must not be an unsigned type if the array starts with index 0.\n\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once L exceeds R, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that, in his assignment of binary search, most of the programmers who implemented binary search incorrectly made an error defining the exit conditions.\n\nLibrary support\n\nMany languages' standard libraries include binary search routines:\n* C provides the function bsearch() in its standard library, which is typically implemented via binary search (although the official standard does not require it so).\n* C++'s Standard Template Library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\n* COBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\n* Java offers a set of overloaded binarySearch() static methods in the classes  and  in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\n* Microsoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch(T[] array, T value).\n* Python provides the bisect module.\n* Ruby's Array class includes a bsearch method with built-in approximate matching.\n* Go's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\n* For Objective-C, the Cocoa framework provides the [https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html#//apple_ref/occ/instm/NSArray/indexOfObject:inSortedRange:options:usingComparator: NSArray -indexOfObject:inSortedRange:options:usingComparator:] method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a [https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFArrayRef/Reference/reference.html#//apple_ref/c/func/CFArrayBSearchValues CFArrayBSearchValues()] function.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Binary search algorithm" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=4266" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array; if they are unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. If the search ends with the remaining half being empty, the target is not in the array.\n\nBinary search runs in at worst logarithmic time, making  comparisons, where  is the number of elements in the array, the  is Big O notation, and  is the logarithm. Binary search takes constant () space, meaning that the space taken by the algorithm is the same for any number of elements in the array. Although specialized data structures designed for fast searching—such as hash tables—can be searched more efficiently, binary search applies to a wider range of problems.\n\nAlthough the idea is simple, implementing binary search correctly requires attention to some subtleties about its exit conditions and midpoint calculation.\n\nThere are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays, efficiently solving a series of search problems in computational geometry and numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search.\n\nAlgorithm \n\nBinary search works on sorted arrays. Binary search begins by comparing the middle element of the array with the target value. If the target value matches the middle element, its position in the array is returned. If the target value is less than or greater than the middle element, the search continues in the lower or upper half of the array, respectively, eliminating the other half from consideration.\n\nProcedure\n\nGiven an array A of n elements with values or records A0, A1, ..., An−1, sorted such that A0 ≤ A1 ≤ ... ≤ An−1, and target value T, the following subroutine uses binary search to find the index of T in A.\n# Set L to 0 and R to n − 1.\n# If L > R, the search terminates as unsuccessful.\n# Set m (the position of the middle element) to the floor (the largest previous integer) of (L + R) / 2.\n# If Am m > T, set R to m − 1 and go to step 2.\n# Now Am = T, the search is done; return m.\n\nThis iterative procedure keeps track of the search boundaries with the two variables. Some implementations may check whether the middle element is equal to the target at the end of the procedure. This results in a faster comparison loop, but requires one more iteration on average. Procedure is described at p. 214 (§43), titled \"Program for Binary Search\".\n\nApproximate matches\n\nThe above procedure only performs exact matches, finding the position of a target value. However, due to the ordered nature of sorted arrays, it is trivial to extend binary search to perform approximate matches. For example, binary search can be used to compute, for a given value, its rank (the number of smaller elements), predecessor (next-smallest element), successor (next-largest element), and nearest neighbor. Range queries seeking the number of elements between two values can be performed with two rank queries.\n* Rank queries can be performed using a modified version of binary search. By returning m on a successful search, and L on an unsuccessful search, the number of elements less than the target value is returned instead.\n* Predecessor and successor queries can be performed with rank queries. Once the rank of the target value is known, its predecessor is the element at the position given by its rank (as it is the largest element that is smaller than the target value). Its successor is the element after it (if it is present in the array) or at the next position after the predecessor (otherwise). The nearest neighbor of the target value is either its predecessor or successor, whichever is closer.\n* Range queries are also straightforward. Once the ranks of the two values are known, the number of elements greater than or equal to the first value and less than the second is the difference of the two ranks. This count can be adjusted up or down by one according to whether the endpoints of the range should be considered to be part of the range and whether the array contains keys matching those endpoints.\n\nPerformance\n\nThe performance of binary search can be analyzed by reducing the procedure to a binary comparison tree, where the root node is the middle element of the array. The middle element of the lower half is the left child node of the root and the middle element of the upper half is the right child node of the root. The rest of the tree is built in a similar fashion. This model represents binary search; starting from the root node, the left or right subtrees are traversed depending on whether the target value is less or more than the node under consideration, representing the successive elimination of elements.\n\nThe worst case is \\lfloor \\log_2 (n) + 1 \\rfloor iterations of the comparison loop, where the \\lfloor \\rfloor notation denotes the floor function that rounds its argument to the next-smallest integer and \\log_2 is the binary logarithm. The worst case is reached when the search reaches the deepest level of the tree, equivalent to a binary search that has reduced to one element and, in each iteration, always eliminates the smaller subarray out of the two if they are not of equal size.\n\nOn average, assuming that each element is equally likely to be searched, the procedure will most likely find the target value the second-deepest level of the tree. This is equivalent to a binary search that completes one iteration before the worst case, reached after \\log_2(n + 1) - 1 iterations. However, the tree may be unbalanced, with the deepest level partially filled. Equivalently, the array may not be divided exactly in half by the search in some iterations, half of the time resulting in the smaller subarray being eliminated. This cannot occur if the size of the array is one less than a power of two, but otherwise the actual number of average iterations is slightly higher, at \\lfloor \\log_2 (n + 1) \\rfloor - \\frac{\\lfloor \\log_2 (n + 1) \\rfloor({\\lfloor \\log_2 (n + 1) \\rfloor} - 1) - 1}{n} iterations. In the best case, where the target value is the middle element of the array, its position is returned after one iteration.\n\nIn terms of iterations, no search algorithm that works only by comparing elements can exhibit better average and worst-case performance than binary search. This is because the comparison tree representing binary search has the fewest levels possible as each level is filled completely with nodes if there are enough. Otherwise, the search algorithm can eliminate few elements in an iteration, increasing the number of iterations required in the average and worst case. This is the case for other search algorithms based on comparisons, as while they may work faster on some target values, the average performance over all elements is affected. This problem is solved by binary search, as dividing the array in half ensures that the size of both subarrays are as similar as possible.\n\nEach iteration of the binary search procedure defined above makes one or two comparisons, checking if the middle element is equal to the target in each iteration. Again assuming that each element is equally likely to be searched, each iteration makes 1.5 comparisons on average. A variation of the algorithm checks whether the middle element is equal to the target at the end of the search, eliminating on average half a comparison from each iteration. This slightly cuts the time taken per iteration on most computers, while guaranteeing that the search takes the maximum number of iterations, on average adding one iteration to the search. Because the comparison loop is performed only \\lfloor \\log_2 (n) + 1 \\rfloor times in the worst case, the slight increase in comparison loop efficiency does not compensate for the extra iteration for all but enormous n.  gives a value of 2^{66} (more than 73 quintillion)Sloane, Neil. [https://oeis.org/A000079/b000079.txt Table of n, 2n for n \n 0..1000]. Part of OEIS [https://oeis.org/A000079 A000079]. Retrieved 30 April 2016. elements for this variation to be faster.\n\nFractional cascading can be used to speed up searches of the same value in multiple arrays. Where k is the number of arrays, searching each array for the target value takes O(k \\log n) time; fractional cascading reduces this to O(k + \\log n).\n\nBinary search versus other schemes \n\nSorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval, taking O(n) time for each such operation, and complicating memory use. Other data structures support much more efficient insertion and deletion, and also fast exact matching. However, binary search applies to a wide range of search problems, usually solving them in O(\\log n) time regardless of the type or structure of the values themselves.\n\nHashing \n\nFor implementing associative arrays, hash tables, a data structure that maps keys to records using a hash function, are generally faster than binary search on a sorted array of records; most implementations require only amortized constant time on average. However, hashing is not useful for approximate matches, such as computing the next-smallest, next-largest, and nearest key, as the only information given on a failed search is that the target is not present in any record. Binary search is ideal for such matches, performing them in logarithmic time. In addition, all operations possible on a sorted array can be performed—such as finding the smallest and largest key and performing range searches. \n\nTrees \n\nA binary search tree is a binary tree data structure that works based on the principle of binary search. The records of the tree are arranged in sorted order, and each record in the tree can be searched using an algorithm similar to binary search, taking on average logarithmic time. Insertion and deletion also require on average logarithmic time in binary search trees. This can be faster than the linear time insertion and deletion of sorted arrays, and binary trees retain the ability to perform all the operations possible on a sorted array, including range and approximate queries.\n\nHowever, binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced, resulting in slightly worse performance than binary search. This applies even to balanced binary search trees, binary search trees that balance their own nodes—as they rarely produce optimally-balanced trees—but to a lesser extent. Although unlikely, the tree may be severely imbalanced with few internal nodes with two children, resulting in the average and worst-case search time approaching n comparisons. Binary search trees take more space than sorted arrays.\n\nBinary search trees lend themselves to fast searching in external memory stored in hard disks, as binary search trees can effectively be structured in filesystems. The B-tree generalizes this method of tree organization; B-trees are frequently used to organize long-term storage such as databases and filesystems.\n\nLinear search \n\nLinear search is a simple search algorithm that checks every record until it finds the target value. Linear search can be done on a linked list, which allows for faster insertion and deletion than an array. Binary search is faster than linear search for sorted arrays except if the array is short. If the array must first be sorted, that cost must be amortized over any searches. Sorting the array also enables efficient approximate matches and other operations.\n\nSet membership algorithms\n\nA related problem to search is set membership. Any algorithm that does lookup, like binary search, can also be used for set membership. There are other algorithms that are more specifically suited for set membership.  A bit array is the simplest, useful when the range of keys is limited; it is very fast, requiring only O(1) time.  The Judy1 type of Judy array handles 64-bit keys efficiently.\n\nFor approximate results, Bloom filters, another probabilistic data structure based on hashing, store a set of keys by encoding the keys using a bit array and multiple hash functions. Bloom filters are much more space-efficient than bit arrays in most cases and not much slower: with k hash functions, membership queries require only O(k) time. However, Bloom filters suffer from false positives.\n\nOther data structures \n\nThere exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays. For example, searches, approximate matches, and the operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van Emde Boas trees, fusion trees, tries, and bit arrays. However, while these operations can always be done at least efficiently on a sorted array regardless of the keys, such data structures are usually only faster because they exploit the properties of keys with a certain attribute (usually keys that are small integers), and thus will be time or space consuming for keys that lack that attribute. Some structures, such as Judy arrays, use a combination of approaches to mitigate this while retaining efficiency and the ability to perform approximate matching.\n\nVariations\n\nUniform binary search\n\nUniform binary search stores, instead of the lower and upper bounds, the index of the middle element and the change in the middle element from the current iteration to the next iteration. Each step reduces the change by about half. For example, if the array to be searched was , the middle element would be . Uniform binary search works on the basis that the difference between the index of middle element of the array and the left and right subarrays is the same. In this case, the middle element of the left subarray () is  and the middle element of the right subarray () is . Uniform binary search would store the value of  as both indices differ from  by this same amount. To reduce the search space, the algorithm either adds or subtracts this change from the middle element. The main advantage of uniform binary search is that the procedure can store a table of the differences between indices for each iteration of the procedure, which may improve the algorithm's performance on some systems.\n\nExponential search\n\nExponential search extends binary search to unbounded lists. It starts by finding the first element with an index that is both a power of two and greater than the target value. Afterwards, it sets that index as the upper bound, and switches to binary search. A search takes \\lfloor \\log_2 x + 1\\rfloor iterations of the exponential search and at most \\lfloor \\log_2 x \\rfloor iterations of the binary search, where x is the position of the target value. Exponential search works on bounded lists, but becomes an improvement over binary search only if the target value lies near the beginning of the array.\n\nInterpolation search\n\nInstead of calculating the midpoint, interpolation search estimates the position of the target value, taking into account the lowest and highest elements in the array as well as length of the array. This is only possible if the array elements are numbers. It works on the basis that the midpoint is not the best guess in many cases. For example, if the target value is close to the highest element in the array, it is likely to be located near the end of the array. When the distribution of the array elements is uniform or near uniform, it makes O(\\log \\log n) comparisons.\n\nIn practice, interpolation search is slower than binary search for small arrays, as interpolation search requires extra computation. Although its time complexity grows more slowly than binary search, this only compensates for the extra computation for large arrays.\n\nFractional cascading \n\nFractional cascading is a technique that speeds up binary searches for the same element for both exact and approximate matching in \"catalogs\" (arrays of sorted elements) associated with vertices in graphs. Searching each catalog separately requires O(k \\log n) time, where k is the number of catalogs. Fractional cascading reduces this to O(k + \\log n) by storing specific information in each catalog about other catalogs.\n\nFractional cascading was originally developed to efficiently solve various computational geometry problems, but it also has been applied elsewhere, in domains such as data mining and Internet Protocol routing.\n\nFibonacci search \n\nFibonacci search is a method similar to binary search that successively shortens the interval in which the maximum of a unimodal function lies. Given a finite interval, a unimodal function, and the maximum length of the resulting interval, Fibonacci search finds a Fibonacci number such that if the interval is divided equally into that many subintervals, the subintervals would be shorter than the maximum length. After dividing the interval, it eliminates the subintervals in which the maximum cannot lie until one or more contiguous subintervals remain. \n\nNoisy binary search \n\nNoisy binary search algorithms solve the case where the algorithm cannot reliably compare elements of the array. For each pair of elements, there is a certain probability that the algorithm makes the wrong comparison. Noisy binary search can find the correct position of the target with a given probability that controls the reliability of the yielded position. The noisy binary search problem can be considered as a case of the Rényi-Ulam game, which Alfréd Rényi introduced in 1961.\n\nQuantum binary search \n\nClassical computers are bounded to the worst case of exactly \\lfloor \\log_2 n + 1 \\rfloor iterations when performing binary search. Quantum algorithms for binary search are still bounded to a proportion of \\log_2 n queries (representing iterations of the classical procedure), but the constant factor is less than one, providing for faster performance on quantum computers.  proved that any exact quantum binary search procedure—that is, a procedure that always yields the correct result—requires at least \\frac{1}{\\pi}(\\ln n - 1) \\approx 0.220 \\log_2 n queries in the worst case, where \\ln is the natural logarithm.  provided an exact quantum binary search procedure that runs in 4 \\log_{605} n \\approx 0.433 \\log_2 n queries in the worst case.\n\nHistory \n\nIn 1946, John Mauchly made the first mention of binary search as part of the Moore School Lectures, the first ever set of lectures regarding any computer-related topic. Every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960, when Derrick Henry Lehmer published a binary search algorithm that worked on all arrays. In 1962, Hermann Bottenbruch presented an ALGOL 60 implementation of binary search that placed the comparison for equality at the end, increasing the average number of iterations by one, but reducing to one the number of comparisons per iteration. The uniform binary search was presented to Donald Knuth in 1971 by A. K. Chandra of Stanford University and published in Knuth's The Art of Computer Programming. In 1986, Bernard Chazelle and Leonidas J. Guibas introduced fractional cascading as a method to solve numerous search problems in computational geometry.\n\nImplementation issues\n\nAlthough the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky ... — Donald Knuth\n\nWhen Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, and another study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years.  The Java programming language library implementation of binary search had the same overflow bug for more than nine years.\n\nIn a practical implementation, the variables used to represent the indices will often be of fixed size, and this can result in an arithmetic overflow for very large arrays. If the midpoint of the span is calculated as (L + R) / 2, then the value of L + R may exceed the range of integers of the data type used to store the midpoint, even if L and R are within the range. If L and R are nonnegative, this can be avoided by calculating the midpoint as L + (R − L) / 2.\n\nIf the target value is greater than the greatest value in the array, and the last index of the array is the maximum representable value of L, the value of L will eventually become too large and overflow. A similar problem will occur if the target value is smaller than the least value in the array and the first index of the array is the smallest representable value of R. In particular, this means that R must not be an unsigned type if the array starts with index 0.\n\nAn infinite loop may occur if the exit conditions for the loop are not defined correctly. Once L exceeds R, the search has failed and must convey the failure of the search. In addition, the loop must be exited when the target element is found, or in the case of an implementation where this check is moved to the end, checks for whether the search was successful or failed at the end must be in place. Bentley found that, in his assignment of binary search, most of the programmers who implemented binary search incorrectly made an error defining the exit conditions.\n\nLibrary support\n\nMany languages' standard libraries include binary search routines:\n* C provides the function bsearch() in its standard library, which is typically implemented via binary search (although the official standard does not require it so).\n* C++'s Standard Template Library provides the functions binary_search(), lower_bound(), upper_bound() and equal_range().\n* COBOL provides the SEARCH ALL verb for performing binary searches on COBOL ordered tables.\n* Java offers a set of overloaded binarySearch() static methods in the classes  and  in the standard java.util package for performing binary searches on Java arrays and on Lists, respectively.\n* Microsoft's .NET Framework 2.0 offers static generic versions of the binary search algorithm in its collection base classes. An example would be System.Array's method BinarySearch(T[] array, T value).\n* Python provides the bisect module.\n* Ruby's Array class includes a bsearch method with built-in approximate matching.\n* Go's sort standard library package contains the functions Search, SearchInts, SearchFloat64s, and SearchStrings, which implement general binary search, as well as specific implementations for searching slices of integers, floating-point numbers, and strings, respectively.\n* For Objective-C, the Cocoa framework provides the [https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html#//apple_ref/occ/instm/NSArray/indexOfObject:inSortedRange:options:usingComparator: NSArray -indexOfObject:inSortedRange:options:usingComparator:] method in Mac OS X 10.6+. Apple's Core Foundation C framework also contains a [https://developer.apple.com/library/mac/documentation/CoreFoundation/Reference/CFArrayRef/Reference/reference.html#//apple_ref/c/func/CFArrayBSearchValues CFArrayBSearchValues()] function. Binary search algorithm. http://en.wikipedia.org/?curid=4266."
  }
}
