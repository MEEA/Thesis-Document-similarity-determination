{
  "datasourceIdentifier" : "awesome wiki export",
  "backlink" : "http://en.wikipedia.org/?curid=10237",
  "eid" : "f47d1fd0-52b1-11e8-ad1f-273b2f3b71fa",
  "loadTime" : 1525778489933,
  "textBody" : "In mathematics and computer programming, exponentiating by squaring is a general method for fast computation of large positive integer powers of a number, or more generally of an element of a semigroup, like a polynomial or a square matrix. Some variants are commonly referred to as square-and-multiply algorithms or binary exponentiation. These can be of quite general use, for example in modular arithmetic or powering of matrices. For semigroups for which additive notation is commonly used, like elliptic curves used in cryptography, this method is also referred to as double-and-add.\n\nBasic method\n\nThe method is based on the observation that, for a positive integer n, we have\n x^n=     \n    \\begin{cases}\n                x \\, ( x^{2})^{\\frac{n - 1}{2}}, & \\mbox{if } n \\mbox{ is odd} \\\\\n                (x^{2})^{\\frac{n}{2}} , & \\mbox{if } n \\mbox{ is even}.\n     \\end{cases}\n\nThis method uses the bits of the exponent to determine which powers are computed.\n\nThis example shows how to compute x^{13} using this method.\nThe exponent, 13, is 1101 in binary. The bits are used in left to right order.\nThe exponent has 4 bits, so there are 4 iterations.\n\nFirst, initialize the result to 1: r \\leftarrow 1 \\, ( = x^0).\nStep 1) r \\leftarrow r^2 \\, ( x^0); bit 1 \n 1, so compute r \\leftarrow r \\cdot x \\,( = x^1);\nStep 2) r \\leftarrow r^2 \\, ( x^2); bit 2 \n 1, so compute r \\leftarrow r \\cdot x \\, ( = x^3);\nStep 3) r \\leftarrow r^2 \\, ( x^6); bit 3 \n 0, so we are done with this step;\nStep 4) r \\leftarrow r^2 \\, ( x^{12}); bit 4 \n 1, so compute r \\leftarrow r \\cdot x \\, ( = x^{13}).\n\nThis may be implemented as the following recursive algorithm: \n\n  Function exp_by_squaring(x, n)\n    if n \n\nAlthough not tail-recursive, this algorithm may be rewritten into a tail recursive algorithm by introducing an auxiliary function:\n\n  Function exp_by_squaring(x, n)\n    exp_by_squaring2(1, x, n)\n  Function exp_by_squaring2(y, x, n)\n    if n \n\nThe iterative version of the algorithm also uses a bounded auxiliary space, and is given by\n\n  Function exp_by_squaring_iterative(x, n)\n    if n  1 do\n      if n is even then \n        x := x * x;\n        n := n / 2;\n      else\n        y := x * y;\n        x := x * x;\n        n := (n – 1) / 2;\n    return x * y\n\nComputational complexity\n\nA brief analysis shows that such an algorithm uses \\lfloor \\log_2n\\rfloor squarings and at most \\lfloor \\log_2n\\rfloor multiplications, where \\lfloor\\;\\rfloor denotes the floor function. More precisely, the number of multiplications is one less than the number of ones present in the binary expansion of n. For n greater than about 4 this is computationally more efficient than naively multiplying the base with itself repeatedly.\n\nEach squaring results in approximately double the number of digits of the previous, and so, if multiplication of two d digit numbers is implemented in O(dk) operations for some fixed k then the complexity of computing xn is given by:\n\n \\sum\\limits_{i0}^{O(\\log(n))} (2^i O(\\log(x)))^k \n O((n \\log(x))^k)  \n\n2k-ary method\n\nThis algorithm calculates the value of xn after expanding the exponent in base  2k. It was first proposed by Brauer in 1939. In the algorithm below we make use of the following function f(0) (k,0) and f(m) \n (s,u) where m = u·2s\nwith u odd.\n\nAlgorithm:\n\n;Input: An element x of G, a parameter k > 0, a non-negative integer  and the precomputed values x^3, x^5, ... , x^{2^k-1}.\n\n;Output: The element xn in G\n\n y :1; i :\n l-1\n while i>=0 do\n     (s,u) := f(ni)\n     for j:=1 to k-s do\n         y := y2 \n     y := y*xu\n     for j:=1 to s do\n         y := y2\n     i := i-1\n return y\n\nFor optimal efficiency, k should be the smallest integer satisfying \n\n\\log(n) \n\nSliding window method\n\nThis method is an efficient variant of the 2k-ary method. For example, to calculate the exponent 398 which has binary expansion (110 001 110)2, we take a window of length 3 using the 2k-ary method algorithm we calculate 1,x3,x6,x12,x24,x48,x49,x98,x99,x198,x199,x398.  \nBut, we can also compute 1,x3,x6,x12,x24,x48,x96,x192,x198,x199,\nx398 which saves one multiplication and amounts to evaluating (110 001 110)n2\n\nHere is the general algorithm:\n\nAlgorithm:\n\n;Input:An element x of G,a non negative integer , a parameter k>0 and the pre-computed values x^3, x^5, ... ,x^{2^k-1}.\n\n;Output: The element xn ∈ G\n\nAlgorithm:\n\n y :1; i :\n l-1\n while i > -1 do\n     if ni=0 then\n         y:y2' i:\ni-1\n     else\n         s:=max{i-k+1,0}\n         while ns=0 do\n             s:s+1 In this line, the loop finds the longest string of length less than or equal to 'k' which ends in a non zero value. And not all odd powers of 2 up to x^{2^k-1} need be computed and only those specifically involved in the computation need be considered.\n         for h:=1 to i-s+1 do\n             y:=y2\n         u:=(ni,ni-1,....,ns)2\n         y:=y*xu\n         i:=s-1\n return y\n\nMontgomery's ladder technique\n\nMany algorithms for exponentiation do not provide defence against side-channel attacks. Namely, an attacker observing the sequence of squarings and multiplications can (partially) recover the exponent involved in the computation. This is a problem if the exponent should remain secret, as with many public-key cryptosystems. A technique called Montgomery's Ladder addresses this concern.\n\nGiven the binary expansion of a positive, non-zero integer n(nk-1...n0)2 with nk-1\n1 we can compute xn as follows:\n x1x; x2\nx2\n for i=k-2 to 0 do\n   If ni=0 then\n     x2x1*x2; x1\nx12\n   else\n     x1x1*x2; x2\nx22\n return x1\n\nThe algorithm performs a fixed sequence of operations (up to log n): a multiplication and squaring takes place for each bit in the exponent, regardless of the bit's specific value.\n\nThis specific implementation of Montgomery's ladder is not yet protected against cache timing attacks: memory access latencies might still be observable to an attacker as you access different variables depending on the value of bits of the secret exponent.\n\nFixed base exponent\n\nThere are several methods which can be employed to calculate xn when the base is fixed and the exponent varies. As one can see, precomputations play a key role in these algorithms.\n\nYao's method\n\nYao's method is orthogonal to the -ary method where the exponent is expanded in radix  and the computation is as performed in the algorithm above. Let \"\", \"\", \"\", and \"\" be integers.\n\nLet the exponent \"\" be written as\n n \\sum_{i\n0}^{w-1} n_ib_i where  0 \\leqslant n_i  for all i \\in [0,w-1] \n\nLet . Then the algorithm uses the equality\n x^n \\prod_{i\n0}^{w-1} {x_i}^{n_i} \\prod_{j\n1}^{h-1}{\\bigg[\\prod_{n_i=j} x_i\\bigg]}^j \n\nGiven the element  of , and the exponent  written in the above form, along with the precomputed values  the element  is calculated using the algorithm below.\n\n  y1,u\n1 and j=h-1\n  while j > 0 do\n    for i=0 to w-1 do\n      if nij then u\nu*xbi\n    y=y*u\n    j=j-1\n  return y\n\nIf we set  and  then the 's are simply the digits of  in base . Yao's method collects in u first those  which appear to the highest power ; in the next round those with power  are collected in  as well etc. The variable y is multiplied  times with the initial ,  times with the next highest powers etc.\nThe algorithm uses  multiplications and  elements must be stored to compute .\n\nEuclidean method\n\nThe Euclidean method was first introduced in Efficient exponentiation using precomputation and vector addition chains by P.D Rooij.\n\nThis method for computing x^n in group , where  is a natural integer, whose algorithm is given below, is using the following equality recursively:\n{x_0}^{n_0} \\cdot {x_1}^{n_1} {\\left( x_0 \\cdot {x_1}^{q} \\right)}^{n_0} \\cdot {x_1}^{n_1 \\mod {n_0}}, where q \n \\left\\lfloor \\frac {n_1} {n_0} \\right\\rfloor\n(in other words a Euclidean division of the exponent  by  is used to return a quotient  and a rest ).\n\nGiven the base element  in group , and the exponent n written as in Yao's method, the element x^n is calculated using l precomputed values x^{b_0}, ..., x^{b_{l_i}} and then the algorithm below.\n\n     Begin loop   \n          \n          \n         Break loop \n          \n          \n     End loop;\n     \n\nThe algorithm first finds the largest value amongst the  and then the supremum within the set of .\nThen it raises  to the power , multiplies this value with , and then assigns  the result of this computation and  the value  modulo .\n\nFurther applications\n\nThe same idea allows fast computation of large exponents modulo a number. Especially in cryptography, it is useful to compute powers in a ring of integers modulo q. It can also be used to compute integer powers in a group, using the rule\n\nPower(x, −n) = (Power(x, n))−1.\n\nThe method works in every semigroup and is often used to compute powers of matrices.\n\nFor example, the evaluation of\n\n13789722341 (mod 2345)\n\nwould take a very long time and lots of storage space if the naïve method were used: compute 13789722341 then take the remainder when divided by 2345. Even using a more effective method will take a long time: square 13789, take the remainder when divided by 2345, multiply the result by 13789, and so on. This will take less than 2\\log_2(722340)\\leq 40 modular multiplications.\n\nApplying above exp-by-squaring algorithm, with \"*\" interpreted as x*y = xy mod 2345 (that is a multiplication followed by a division with remainder) leads to only 27 multiplications and divisions of integers which may all be stored in a single machine word.\n\nExample implementations\n\nComputation by powers of 2\n\nThis is a non-recursive implementation of the above algorithm in Ruby.\n\nnn-1 is redundant when n\nn/2 implicitly rounds towards zero, as lower level languages would do.\nn[0] is the rightmost bit of the binary representation of n, so if it is 1, the number is odd, if it is zero, the number is even. It is also n modulo 2.\n\ndef power(x,n)\n  result = 1\n  while n.nonzero?\n    if n[0].nonzero?\n      result *= x\n      n -= 1\n    end\n    x *= x\n    n /= 2\n  end\n  return result\nend\n\nRuntime example: compute 310\n\n parameter x =  3\n parameter n = 10\n result := 1\n \n Iteration 1\n   n = 10 -> n is even\n   x :x2 \n 32 = 9\n   n :n / 2 \n 5\n \n Iteration 2\n   n = 5 -> n is odd\n       -> result :result * x \n 1 * x 1 * 32 \n 9\n          n :n - 1 \n 4\n   x :x2 \n 92 34 \n 81\n   n :n / 2 \n 2\n \n Iteration 3\n   n = 2 -> n is even\n   x :x2 \n 812 38 \n 6561\n   n :n / 2 \n 1\n \n Iteration 4\n   n = 1 -> n is odd\n       -> result :result * x \n 32 * 38 310 \n 9 * 6561 = 59049\n          n :n - 1 \n 0\n \n return result\n\nRuntime example: compute 310\n\n result := 3\n bin := \"1010\"\n \n Iteration for digit 2:\n   result :result2 \n 32 = 9\n   1010bin - Digit equals \"0\"\n \n Iteration for digit 3:\n   result :result2 \n (32)2 34  \n 81\n   1010bin - Digit equals \"1\" --> result :result*3 \n (32)2*3 35  \n 243\n \n Iteration for digit 4:\n   result :result2 \n ((32)2*3)2 310  \n 59049\n   1010bin - Digit equals \"0\"\n \n return result\n\nJavaScript-Demonstration: http://home.mnet-online.de/wzwz.de/temp/ebs/en.htm\n\nCalculation of products of powers\n\nExponentiation by squaring may also be used to calculate the product of 2 or more powers.\nIf the underlying group or semigroup is commutative then it is often possible to reduce the\nnumber of multiplications by computing the product simultaneously.\n\nExample\n\nThe formula a7×b5 may be calculated within 3 steps:\n((a)2×a)2×a   (four multiplications for calculating a7)\n((b)2)2×b     (three multiplications for calculating b5)\n(a7)×(b5) (one multiplication to calculate the product of the two)\nso one gets eight multiplications in total.\n\nA faster solution is to calculate both powers simultaneously:\n((a×b)2×a)2×a×b\nwhich needs only 6 multiplications in total. Note that a×b is calculated twice; the result could be stored after the first calculation, which reduces the count of multiplication to 5.\n\nExample with numbers:\n27×35  ((2×3)2×2)2×2×3 \n (62×2)2×6  722×6 \n 31,104\n\nCalculating the powers simultaneously instead of calculating them separately always reduces the\ncount of multiplications if at least two of the exponents are greater than 1.\n\nUsing transformation\n\nThe example above a7×b5 may also be calculated with only 5\nmultiplications if the expression is transformed before calculation:\n\na7×b5 a2×(ab)5 with ab :\n a×b\n\nab :a×b (one multiplication)\na2×(ab)5 ((ab)2×a)2×ab (four multiplications)\n\nGeneralization of transformation shows the following scheme:\nFor calculating aA×bB×...×mM×nN\n1st: define ab :a×b, abc \n ab×c, ...\n2nd: calculate the transformed expression aA−B×abB−C×...×abc..mM−N×abc..mnN\n\nTransformation before calculation often reduces the count of multiplications\nbut in some cases it also increases the count (see the last one of the examples below),\nso it may be a good idea to check the count of multiplications before using the transformed expression for calculation.\n\nExamples\n\nFor the following expressions the count of multiplications is shown for calculating each power separately,\ncalculating them simultaneously without transformation, and calculating them simultaneously after transformation.\n\nSigned-digit recoding\n\nIn certain computations it may be more efficient to allow negative coefficients and hence use the inverse of the base, provided inversion in  is 'fast' or has been precomputed. For example, when computing  the binary method requires  multiplications and  squarings. However one could perform  squarings to get  and then multiply by  to obtain .\n\nTo this end we define the signed-digit representation of an integer  in radix  as \nn\\sum_{i\n0}^{l-1}n_ib^i \\text{  with  } |n_i|\n\nSigned binary representation corresponds to the particular choice  and n_i \\in \\{-1,0,1\\}. It is denoted by (n_{l-1}\\dots n_0)_s. There are several methods for computing this representation. The representation is not unique, for example take . Two distinct signed-binary representations are given by (10\\bar 1 1100\\bar 1 10)_s and (100\\bar 1 1000\\bar 1 0)_s, where \\bar 1 is used to denote . Since the binary method computes a multiplication for every non-zero entry in the base 2 representation of , we are interested in finding the signed-binary representation with the smallest number of non-zero entries, that is, the one with minimal Hamming weight. One method of doing this is to compute the representation in non-adjacent form, or NAF for short, which is one that satisfies n_in_{i+1}0\\text{ for all }i\\geqslant 0 and denoted by (n_{l-1}\\dots n_0)_{\\text{NAF}}. For example the NAF representation of 478 is equal to (1000\\bar 1 000\\bar 1 0)_{\\text{NAF}}. This representation always has minimal Hamming weight. A simple algorithm to compute the NAF representation of a given integer n\n(n_ln_{l-1}\\dots n_0)_2 with n_ln_{l-1}\n0 is the following:\n\n \n for  to  do\n   \n   \n }}\n\nAnother algorithm by Koyama and Tsuruoka does not require the condition that n_in_{i+1}\n0; it still minimizes the Hamming weight.\n\nAlternatives and generalizations\n\nExponentiation by squaring can be viewed as a suboptimal addition-chain exponentiation algorithm: it computes the exponent via an addition chain consisting of repeated exponent doublings (squarings) and/or incrementing exponents by one (multiplying by x) only.  More generally, if one allows any previously computed exponents to be summed (by multiplying those powers of x), one can sometimes perform the exponentiation using fewer multiplications (but typically using more memory).  The smallest power where this occurs is for n=15:\n\na^{15} = x \\times (x \\times [x \\times x^2]^2)^2  \\!  (squaring, 6 multiplies)\na^{15} = x^3 \\times ([x^3]^2)^2  \\! (optimal addition chain, 5 multiplies if x3 is re-used)\n\nIn general, finding the optimal addition chain for a given exponent is a hard problem, for which no efficient algorithms are known, so optimal chains are typically only used for small exponents (e.g. in compilers where the chains for small powers have been pre-tabulated).  However, there are a number of heuristic algorithms that, while not being optimal, have fewer multiplications than exponentiation by squaring at the cost of additional bookkeeping work and memory usage.  Regardless, the number of multiplications never grows more slowly than Θ(log n), so these algorithms only improve asymptotically upon exponentiation by squaring by a constant factor at best.",
  "entityProperties" : [ {
    "name" : "title",
    "type" : "String",
    "values" : [ "Exponentiation by squaring" ],
    "synthetic" : false
  }, {
    "name" : "url",
    "type" : "String",
    "values" : [ "http://en.wikipedia.org/?curid=10237" ],
    "synthetic" : false
  } ],
  "classifications" : [ "xml-export" ],
  "technicalAttributes" : {
    "technicalAttributes" : null,
    "aggregatedText" : "In mathematics and computer programming, exponentiating by squaring is a general method for fast computation of large positive integer powers of a number, or more generally of an element of a semigroup, like a polynomial or a square matrix. Some variants are commonly referred to as square-and-multiply algorithms or binary exponentiation. These can be of quite general use, for example in modular arithmetic or powering of matrices. For semigroups for which additive notation is commonly used, like elliptic curves used in cryptography, this method is also referred to as double-and-add.\n\nBasic method\n\nThe method is based on the observation that, for a positive integer n, we have\n x^n=     \n    \\begin{cases}\n                x \\, ( x^{2})^{\\frac{n - 1}{2}}, & \\mbox{if } n \\mbox{ is odd} \\\\\n                (x^{2})^{\\frac{n}{2}} , & \\mbox{if } n \\mbox{ is even}.\n     \\end{cases}\n\nThis method uses the bits of the exponent to determine which powers are computed.\n\nThis example shows how to compute x^{13} using this method.\nThe exponent, 13, is 1101 in binary. The bits are used in left to right order.\nThe exponent has 4 bits, so there are 4 iterations.\n\nFirst, initialize the result to 1: r \\leftarrow 1 \\, ( = x^0).\nStep 1) r \\leftarrow r^2 \\, ( x^0); bit 1 \n 1, so compute r \\leftarrow r \\cdot x \\,( = x^1);\nStep 2) r \\leftarrow r^2 \\, ( x^2); bit 2 \n 1, so compute r \\leftarrow r \\cdot x \\, ( = x^3);\nStep 3) r \\leftarrow r^2 \\, ( x^6); bit 3 \n 0, so we are done with this step;\nStep 4) r \\leftarrow r^2 \\, ( x^{12}); bit 4 \n 1, so compute r \\leftarrow r \\cdot x \\, ( = x^{13}).\n\nThis may be implemented as the following recursive algorithm: \n\n  Function exp_by_squaring(x, n)\n    if n \n\nAlthough not tail-recursive, this algorithm may be rewritten into a tail recursive algorithm by introducing an auxiliary function:\n\n  Function exp_by_squaring(x, n)\n    exp_by_squaring2(1, x, n)\n  Function exp_by_squaring2(y, x, n)\n    if n \n\nThe iterative version of the algorithm also uses a bounded auxiliary space, and is given by\n\n  Function exp_by_squaring_iterative(x, n)\n    if n  1 do\n      if n is even then \n        x := x * x;\n        n := n / 2;\n      else\n        y := x * y;\n        x := x * x;\n        n := (n – 1) / 2;\n    return x * y\n\nComputational complexity\n\nA brief analysis shows that such an algorithm uses \\lfloor \\log_2n\\rfloor squarings and at most \\lfloor \\log_2n\\rfloor multiplications, where \\lfloor\\;\\rfloor denotes the floor function. More precisely, the number of multiplications is one less than the number of ones present in the binary expansion of n. For n greater than about 4 this is computationally more efficient than naively multiplying the base with itself repeatedly.\n\nEach squaring results in approximately double the number of digits of the previous, and so, if multiplication of two d digit numbers is implemented in O(dk) operations for some fixed k then the complexity of computing xn is given by:\n\n \\sum\\limits_{i0}^{O(\\log(n))} (2^i O(\\log(x)))^k \n O((n \\log(x))^k)  \n\n2k-ary method\n\nThis algorithm calculates the value of xn after expanding the exponent in base  2k. It was first proposed by Brauer in 1939. In the algorithm below we make use of the following function f(0) (k,0) and f(m) \n (s,u) where m = u·2s\nwith u odd.\n\nAlgorithm:\n\n;Input: An element x of G, a parameter k > 0, a non-negative integer  and the precomputed values x^3, x^5, ... , x^{2^k-1}.\n\n;Output: The element xn in G\n\n y :1; i :\n l-1\n while i>=0 do\n     (s,u) := f(ni)\n     for j:=1 to k-s do\n         y := y2 \n     y := y*xu\n     for j:=1 to s do\n         y := y2\n     i := i-1\n return y\n\nFor optimal efficiency, k should be the smallest integer satisfying \n\n\\log(n) \n\nSliding window method\n\nThis method is an efficient variant of the 2k-ary method. For example, to calculate the exponent 398 which has binary expansion (110 001 110)2, we take a window of length 3 using the 2k-ary method algorithm we calculate 1,x3,x6,x12,x24,x48,x49,x98,x99,x198,x199,x398.  \nBut, we can also compute 1,x3,x6,x12,x24,x48,x96,x192,x198,x199,\nx398 which saves one multiplication and amounts to evaluating (110 001 110)n2\n\nHere is the general algorithm:\n\nAlgorithm:\n\n;Input:An element x of G,a non negative integer , a parameter k>0 and the pre-computed values x^3, x^5, ... ,x^{2^k-1}.\n\n;Output: The element xn ∈ G\n\nAlgorithm:\n\n y :1; i :\n l-1\n while i > -1 do\n     if ni=0 then\n         y:y2' i:\ni-1\n     else\n         s:=max{i-k+1,0}\n         while ns=0 do\n             s:s+1 In this line, the loop finds the longest string of length less than or equal to 'k' which ends in a non zero value. And not all odd powers of 2 up to x^{2^k-1} need be computed and only those specifically involved in the computation need be considered.\n         for h:=1 to i-s+1 do\n             y:=y2\n         u:=(ni,ni-1,....,ns)2\n         y:=y*xu\n         i:=s-1\n return y\n\nMontgomery's ladder technique\n\nMany algorithms for exponentiation do not provide defence against side-channel attacks. Namely, an attacker observing the sequence of squarings and multiplications can (partially) recover the exponent involved in the computation. This is a problem if the exponent should remain secret, as with many public-key cryptosystems. A technique called Montgomery's Ladder addresses this concern.\n\nGiven the binary expansion of a positive, non-zero integer n(nk-1...n0)2 with nk-1\n1 we can compute xn as follows:\n x1x; x2\nx2\n for i=k-2 to 0 do\n   If ni=0 then\n     x2x1*x2; x1\nx12\n   else\n     x1x1*x2; x2\nx22\n return x1\n\nThe algorithm performs a fixed sequence of operations (up to log n): a multiplication and squaring takes place for each bit in the exponent, regardless of the bit's specific value.\n\nThis specific implementation of Montgomery's ladder is not yet protected against cache timing attacks: memory access latencies might still be observable to an attacker as you access different variables depending on the value of bits of the secret exponent.\n\nFixed base exponent\n\nThere are several methods which can be employed to calculate xn when the base is fixed and the exponent varies. As one can see, precomputations play a key role in these algorithms.\n\nYao's method\n\nYao's method is orthogonal to the -ary method where the exponent is expanded in radix  and the computation is as performed in the algorithm above. Let \"\", \"\", \"\", and \"\" be integers.\n\nLet the exponent \"\" be written as\n n \\sum_{i\n0}^{w-1} n_ib_i where  0 \\leqslant n_i  for all i \\in [0,w-1] \n\nLet . Then the algorithm uses the equality\n x^n \\prod_{i\n0}^{w-1} {x_i}^{n_i} \\prod_{j\n1}^{h-1}{\\bigg[\\prod_{n_i=j} x_i\\bigg]}^j \n\nGiven the element  of , and the exponent  written in the above form, along with the precomputed values  the element  is calculated using the algorithm below.\n\n  y1,u\n1 and j=h-1\n  while j > 0 do\n    for i=0 to w-1 do\n      if nij then u\nu*xbi\n    y=y*u\n    j=j-1\n  return y\n\nIf we set  and  then the 's are simply the digits of  in base . Yao's method collects in u first those  which appear to the highest power ; in the next round those with power  are collected in  as well etc. The variable y is multiplied  times with the initial ,  times with the next highest powers etc.\nThe algorithm uses  multiplications and  elements must be stored to compute .\n\nEuclidean method\n\nThe Euclidean method was first introduced in Efficient exponentiation using precomputation and vector addition chains by P.D Rooij.\n\nThis method for computing x^n in group , where  is a natural integer, whose algorithm is given below, is using the following equality recursively:\n{x_0}^{n_0} \\cdot {x_1}^{n_1} {\\left( x_0 \\cdot {x_1}^{q} \\right)}^{n_0} \\cdot {x_1}^{n_1 \\mod {n_0}}, where q \n \\left\\lfloor \\frac {n_1} {n_0} \\right\\rfloor\n(in other words a Euclidean division of the exponent  by  is used to return a quotient  and a rest ).\n\nGiven the base element  in group , and the exponent n written as in Yao's method, the element x^n is calculated using l precomputed values x^{b_0}, ..., x^{b_{l_i}} and then the algorithm below.\n\n     Begin loop   \n          \n          \n         Break loop \n          \n          \n     End loop;\n     \n\nThe algorithm first finds the largest value amongst the  and then the supremum within the set of .\nThen it raises  to the power , multiplies this value with , and then assigns  the result of this computation and  the value  modulo .\n\nFurther applications\n\nThe same idea allows fast computation of large exponents modulo a number. Especially in cryptography, it is useful to compute powers in a ring of integers modulo q. It can also be used to compute integer powers in a group, using the rule\n\nPower(x, −n) = (Power(x, n))−1.\n\nThe method works in every semigroup and is often used to compute powers of matrices.\n\nFor example, the evaluation of\n\n13789722341 (mod 2345)\n\nwould take a very long time and lots of storage space if the naïve method were used: compute 13789722341 then take the remainder when divided by 2345. Even using a more effective method will take a long time: square 13789, take the remainder when divided by 2345, multiply the result by 13789, and so on. This will take less than 2\\log_2(722340)\\leq 40 modular multiplications.\n\nApplying above exp-by-squaring algorithm, with \"*\" interpreted as x*y = xy mod 2345 (that is a multiplication followed by a division with remainder) leads to only 27 multiplications and divisions of integers which may all be stored in a single machine word.\n\nExample implementations\n\nComputation by powers of 2\n\nThis is a non-recursive implementation of the above algorithm in Ruby.\n\nnn-1 is redundant when n\nn/2 implicitly rounds towards zero, as lower level languages would do.\nn[0] is the rightmost bit of the binary representation of n, so if it is 1, the number is odd, if it is zero, the number is even. It is also n modulo 2.\n\ndef power(x,n)\n  result = 1\n  while n.nonzero?\n    if n[0].nonzero?\n      result *= x\n      n -= 1\n    end\n    x *= x\n    n /= 2\n  end\n  return result\nend\n\nRuntime example: compute 310\n\n parameter x =  3\n parameter n = 10\n result := 1\n \n Iteration 1\n   n = 10 -> n is even\n   x :x2 \n 32 = 9\n   n :n / 2 \n 5\n \n Iteration 2\n   n = 5 -> n is odd\n       -> result :result * x \n 1 * x 1 * 32 \n 9\n          n :n - 1 \n 4\n   x :x2 \n 92 34 \n 81\n   n :n / 2 \n 2\n \n Iteration 3\n   n = 2 -> n is even\n   x :x2 \n 812 38 \n 6561\n   n :n / 2 \n 1\n \n Iteration 4\n   n = 1 -> n is odd\n       -> result :result * x \n 32 * 38 310 \n 9 * 6561 = 59049\n          n :n - 1 \n 0\n \n return result\n\nRuntime example: compute 310\n\n result := 3\n bin := \"1010\"\n \n Iteration for digit 2:\n   result :result2 \n 32 = 9\n   1010bin - Digit equals \"0\"\n \n Iteration for digit 3:\n   result :result2 \n (32)2 34  \n 81\n   1010bin - Digit equals \"1\" --> result :result*3 \n (32)2*3 35  \n 243\n \n Iteration for digit 4:\n   result :result2 \n ((32)2*3)2 310  \n 59049\n   1010bin - Digit equals \"0\"\n \n return result\n\nJavaScript-Demonstration: http://home.mnet-online.de/wzwz.de/temp/ebs/en.htm\n\nCalculation of products of powers\n\nExponentiation by squaring may also be used to calculate the product of 2 or more powers.\nIf the underlying group or semigroup is commutative then it is often possible to reduce the\nnumber of multiplications by computing the product simultaneously.\n\nExample\n\nThe formula a7×b5 may be calculated within 3 steps:\n((a)2×a)2×a   (four multiplications for calculating a7)\n((b)2)2×b     (three multiplications for calculating b5)\n(a7)×(b5) (one multiplication to calculate the product of the two)\nso one gets eight multiplications in total.\n\nA faster solution is to calculate both powers simultaneously:\n((a×b)2×a)2×a×b\nwhich needs only 6 multiplications in total. Note that a×b is calculated twice; the result could be stored after the first calculation, which reduces the count of multiplication to 5.\n\nExample with numbers:\n27×35  ((2×3)2×2)2×2×3 \n (62×2)2×6  722×6 \n 31,104\n\nCalculating the powers simultaneously instead of calculating them separately always reduces the\ncount of multiplications if at least two of the exponents are greater than 1.\n\nUsing transformation\n\nThe example above a7×b5 may also be calculated with only 5\nmultiplications if the expression is transformed before calculation:\n\na7×b5 a2×(ab)5 with ab :\n a×b\n\nab :a×b (one multiplication)\na2×(ab)5 ((ab)2×a)2×ab (four multiplications)\n\nGeneralization of transformation shows the following scheme:\nFor calculating aA×bB×...×mM×nN\n1st: define ab :a×b, abc \n ab×c, ...\n2nd: calculate the transformed expression aA−B×abB−C×...×abc..mM−N×abc..mnN\n\nTransformation before calculation often reduces the count of multiplications\nbut in some cases it also increases the count (see the last one of the examples below),\nso it may be a good idea to check the count of multiplications before using the transformed expression for calculation.\n\nExamples\n\nFor the following expressions the count of multiplications is shown for calculating each power separately,\ncalculating them simultaneously without transformation, and calculating them simultaneously after transformation.\n\nSigned-digit recoding\n\nIn certain computations it may be more efficient to allow negative coefficients and hence use the inverse of the base, provided inversion in  is 'fast' or has been precomputed. For example, when computing  the binary method requires  multiplications and  squarings. However one could perform  squarings to get  and then multiply by  to obtain .\n\nTo this end we define the signed-digit representation of an integer  in radix  as \nn\\sum_{i\n0}^{l-1}n_ib^i \\text{  with  } |n_i|\n\nSigned binary representation corresponds to the particular choice  and n_i \\in \\{-1,0,1\\}. It is denoted by (n_{l-1}\\dots n_0)_s. There are several methods for computing this representation. The representation is not unique, for example take . Two distinct signed-binary representations are given by (10\\bar 1 1100\\bar 1 10)_s and (100\\bar 1 1000\\bar 1 0)_s, where \\bar 1 is used to denote . Since the binary method computes a multiplication for every non-zero entry in the base 2 representation of , we are interested in finding the signed-binary representation with the smallest number of non-zero entries, that is, the one with minimal Hamming weight. One method of doing this is to compute the representation in non-adjacent form, or NAF for short, which is one that satisfies n_in_{i+1}0\\text{ for all }i\\geqslant 0 and denoted by (n_{l-1}\\dots n_0)_{\\text{NAF}}. For example the NAF representation of 478 is equal to (1000\\bar 1 000\\bar 1 0)_{\\text{NAF}}. This representation always has minimal Hamming weight. A simple algorithm to compute the NAF representation of a given integer n\n(n_ln_{l-1}\\dots n_0)_2 with n_ln_{l-1}\n0 is the following:\n\n \n for  to  do\n   \n   \n }}\n\nAnother algorithm by Koyama and Tsuruoka does not require the condition that n_in_{i+1}\n0; it still minimizes the Hamming weight.\n\nAlternatives and generalizations\n\nExponentiation by squaring can be viewed as a suboptimal addition-chain exponentiation algorithm: it computes the exponent via an addition chain consisting of repeated exponent doublings (squarings) and/or incrementing exponents by one (multiplying by x) only.  More generally, if one allows any previously computed exponents to be summed (by multiplying those powers of x), one can sometimes perform the exponentiation using fewer multiplications (but typically using more memory).  The smallest power where this occurs is for n=15:\n\na^{15} = x \\times (x \\times [x \\times x^2]^2)^2  \\!  (squaring, 6 multiplies)\na^{15} = x^3 \\times ([x^3]^2)^2  \\! (optimal addition chain, 5 multiplies if x3 is re-used)\n\nIn general, finding the optimal addition chain for a given exponent is a hard problem, for which no efficient algorithms are known, so optimal chains are typically only used for small exponents (e.g. in compilers where the chains for small powers have been pre-tabulated).  However, there are a number of heuristic algorithms that, while not being optimal, have fewer multiplications than exponentiation by squaring at the cost of additional bookkeeping work and memory usage.  Regardless, the number of multiplications never grows more slowly than Θ(log n), so these algorithms only improve asymptotically upon exponentiation by squaring by a constant factor at best. Exponentiation by squaring. http://en.wikipedia.org/?curid=10237."
  }
}
